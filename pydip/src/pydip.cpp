/*
 * PyDIP 3.0, Python bindings for DIPlib 3.0
 *
 * (c)2017, Flagship Biosciences, Inc., written by Cris Luengo.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "pydip.h"
#include "diplib/neighborlist.h"
#include "diplib/multithreading.h"

static_assert( sizeof( bool ) == sizeof( dip::bin ), "bool is not one byte, how can I work with logical Python buffers?" );

namespace {

dip::String TensorRepr( dip::Tensor const& tensor ) {
   std::ostringstream os;
   os << "<Tensor (" << tensor << ")>";
   return os.str();
}

dip::String MetricRepr( dip::Metric const& s ) {
   std::ostringstream os;
   os << "<";
   switch( s.Type() ) {
      case dip::Metric::TypeCode::CHAMFER:
         os << "Chamfer";
         break;
      case dip::Metric::TypeCode::CONNECTED:
         os << "Connected";
         break;
      case dip::Metric::TypeCode::IMAGE:
         os << "Custom";
         break;
      default:
         os << "Unknown";
         break;
   }
   os << " Metric with parameter " << s.Param();
   os << ">";
   return os.str();
}

} // namespace

PYBIND11_MODULE( PyDIP_bin, m ) {
   m.doc() = "The portion of the PyDIP module that contains the C++ DIPlib bindings.";

   // diplib/library/tensor.h

   auto tensor = py::class_< dip::Tensor >( m, "Tensor", "Represents the tensor size and shape." );
   tensor.def( py::init<>() );
   tensor.def( py::init< dip::uint >(), "n"_a );
   tensor.def( py::init< dip::uint, dip::uint >(), "rows"_a, "cols"_a );
   tensor.def( py::init< dip::Tensor::Shape, dip::uint, dip::uint >(), "shape"_a, "rows"_a, "cols"_a );
   tensor.def( "__repr__", &TensorRepr );
   tensor.def( "IsScalar", &dip::Tensor::IsScalar );
   tensor.def( "IsVector", &dip::Tensor::IsVector );
   tensor.def( "IsDiagonal", &dip::Tensor::IsDiagonal );
   tensor.def( "IsSymmetric", &dip::Tensor::IsSymmetric );
   tensor.def( "IsTriangular", &dip::Tensor::IsTriangular );
   tensor.def( "IsSquare", &dip::Tensor::IsSquare );
   tensor.def( "TensorShape", &dip::Tensor::TensorShape );
   tensor.def( "Elements", &dip::Tensor::Elements );
   tensor.def( "Rows", &dip::Tensor::Rows );
   tensor.def( "Columns", &dip::Tensor::Columns );
   tensor.def( "Sizes", &dip::Tensor::Sizes );
   tensor.def( "SetShape", &dip::Tensor::SetShape, "shape"_a, "rows"_a, "cols"_a  );
   tensor.def( "SetScalar", &dip::Tensor::SetScalar );
   tensor.def( "SetVector", &dip::Tensor::SetVector, "n"_a );
   tensor.def( "SetMatrix", &dip::Tensor::SetMatrix, "rows"_a, "cols"_a );
   tensor.def( "SetSizes", &dip::Tensor::SetSizes, "sizes"_a );
   tensor.def( "ChangeShape", py::overload_cast<>( &dip::Tensor::ChangeShape ) );
   tensor.def( "ChangeShape", py::overload_cast< dip::uint >( &dip::Tensor::ChangeShape ), "rows"_a );
   tensor.def( "ChangeShape", py::overload_cast< dip::Tensor const& >( &dip::Tensor::ChangeShape ), "example"_a );
   tensor.def( "Transpose", &dip::Tensor::Transpose );
   tensor.def( "ExtractDiagonal", &dip::Tensor::ExtractDiagonal, "stride"_a );
   tensor.def( "ExtractRow", &dip::Tensor::ExtractRow, "index"_a, "stride"_a );
   tensor.def( "ExtractColumn", &dip::Tensor::ExtractColumn, "index"_a, "stride"_a );
   tensor.def( "HasNormalOrder", &dip::Tensor::HasNormalOrder );
   tensor.def( "Index", &dip::Tensor::Index, "indices"_a );
   tensor.def( "LookUpTable", &dip::Tensor::LookUpTable );
   tensor.def( py::self == py::self );
   tensor.def( py::self != py::self );

   // diplib/library/physical_dimensions.h

   auto units = py::class_< dip::Units >( m, "Units", "Represents physical units." );
   units.def( py::init<>() );
   units.def( py::init< dip::String const& >(), "string"_a );
   units.def( "__repr__", &dip::Units::StringUnicode );
   units.def( dip::dfloat() * py::self ); // PyDIP.PhysicalQuantity generated by float * PyDIP.Units
   units.def( py::self * dip::dfloat() ); // PyDIP.PhysicalQuantity generated by PyDIP.Units * float
   py::implicitly_convertible< py::str, dip::Units >();

   auto physQ = py::class_< dip::PhysicalQuantity >( m, "PhysicalQuantity", "Represents a physical quantity." );
   physQ.def( py::init<>() );
   physQ.def( py::init< dip::dfloat, dip::Units >(), "magnitude"_a, "units"_a = dip::Units{} );
   physQ.def( py::init< dip::Units >(), "units"_a );
   physQ.def( "__repr__", []( dip::PhysicalQuantity const& self ) { std::ostringstream os; os << "<PhysicalQuantity {" << self << "}>"; return os.str(); } );
   physQ.def( "__str__", []( dip::PhysicalQuantity const& self ) { std::ostringstream os; os << self; return os.str(); } );
   physQ.def_readwrite( "magnitude", &dip::PhysicalQuantity::magnitude );
   physQ.def_readwrite( "units", &dip::PhysicalQuantity::units );
   physQ.def( py::self += py::self );
   physQ.def( py::self + py::self );
   physQ.def( py::self -= py::self );
   physQ.def( py::self - py::self );
   physQ.def( py::self *= py::self );
   physQ.def( py::self *= dip::dfloat() );
   physQ.def( py::self * py::self );
   physQ.def( py::self * dip::dfloat() );
   physQ.def( dip::dfloat() * py::self );
   physQ.def( py::self /= py::self );
   physQ.def( py::self /= dip::dfloat() );
   physQ.def( py::self / py::self );
   physQ.def( py::self / dip::dfloat() );
   physQ.def( dip::dfloat() / py::self );
   physQ.def( "__pow__", []( dip::PhysicalQuantity a, dip::sint8 p ) { return a.Power( p ); }, py::is_operator() );
   physQ.def( py::self == py::self );
   physQ.def( py::self != py::self );
   physQ.def( -py::self );
   physQ.def( "Invert", &dip::PhysicalQuantity::Invert );
   physQ.def( "IsDimensionless", &dip::PhysicalQuantity::IsDimensionless );
   physQ.def( "IsPhysical", &dip::PhysicalQuantity::IsPhysical );
   physQ.def( "Normalize", &dip::PhysicalQuantity::Normalize, py::return_value_policy::reference_internal );
   physQ.def( "RemovePrefix", &dip::PhysicalQuantity::RemovePrefix, py::return_value_policy::reference_internal );

   auto pixSz = py::class_< dip::PixelSize >( m, "PixelSize", "Represents the physical size of a pixel." );
   pixSz.def( py::init<>() );
   pixSz.def( py::init< dip::PhysicalQuantity const& >(), "physicalQuantity"_a );
   pixSz.def( py::init< dip::PhysicalQuantityArray const& >(), "physicalQuantities"_a );
   pixSz.def( "__repr__", []( dip::PixelSize const& self ) { std::ostringstream os; os << "<PixelSize " << self << ">"; return os.str(); } );
   pixSz.def( "__str__", []( dip::PixelSize const& self ) { std::ostringstream os; os << self; return os.str(); } );
   pixSz.def( "__len__", []( dip::PixelSize const& self ) { return self.Size(); } );
   pixSz.def( "__getitem__", &dip::PixelSize::Get );
   pixSz.def( "__setitem__", py::overload_cast< dip::uint, dip::PhysicalQuantity >( &dip::PixelSize::Set ));
   pixSz.def( py::self == py::self );
   pixSz.def( py::self != py::self );
   pixSz.def( "Scale", py::overload_cast< dip::uint, dip::dfloat >( &dip::PixelSize::Scale ), "d"_a, "s"_a );
   pixSz.def( "Scale", py::overload_cast< dip::dfloat >( &dip::PixelSize::Scale ), "s"_a );
   pixSz.def( "Scale", py::overload_cast< dip::FloatArray const& >( &dip::PixelSize::Scale ), "s"_a );
   pixSz.def( "Invert", py::overload_cast< dip::uint >( &dip::PixelSize::Invert ), "d"_a );
   pixSz.def( "Invert", py::overload_cast<>( &dip::PixelSize::Invert ));
   pixSz.def( "IsIsotropic", &dip::PixelSize::IsIsotropic );
   pixSz.def( "IsDefined", &dip::PixelSize::IsDefined );
   pixSz.def( "Product", &dip::PixelSize::Product );
   pixSz.def( "ToPixels", &dip::PixelSize::ToPixels );
   pixSz.def( "ToPhysical", &dip::PixelSize::ToPhysical );

   // diplib/neighborlist.h

   auto metric = py::class_< dip::Metric >( m, "Metric", "Represents the metric to use in some neighbor-based operations." );
   metric.def( py::init<>() );
   metric.def( py::init< dip::Image const& >(), "image"_a );
   metric.def( py::init< dip::String const&, dip::uint, dip::PixelSize const& >(), "type"_a, "param"_a = 1, "pixelSize"_a = dip::PixelSize{} );
   metric.def( "__repr__", &MetricRepr );
   py::implicitly_convertible< py::buffer, dip::Metric >();
   py::implicitly_convertible< py::str, dip::Metric >();

   // diplib/multitheading.h

   m.def( "SetNumberOfThreads", &dip::SetNumberOfThreads, "nThreads"_a );
   m.def( "GetNumberOfThreads", &dip::GetNumberOfThreads );

   // Include definitions from all other source files

   init_image( m );
   init_math( m );
   init_statistics( m );
   init_filtering( m );
   init_morphology( m );
   init_analysis( m );
   init_measurement( m );
   init_assorted( m );
}
