// This is an automatically generated file, do not edit.

namespace doc_strings {
constexpr char const* dml = "The `dml` namespace contains the interface between *MATLAB* and *DIPlib*.";
constexpr char const* dml·IsScalar·mxArray·CP = "True if array is scalar (has single value)";
constexpr char const* dml·IsVector·mxArray·CP = "True if empty or a one-dimensional array";
constexpr char const* dml·IsString·mxArray·CP = "True if `mx` is a string (char vector or string class)";
constexpr char const* dml·GetUnsigned·mxArray·CP = "Convert an unsigned integer from `mxArray` to `dip::uint` by copy.";
constexpr char const* dml·GetInteger·mxArray·CP = "Convert a signed integer from `mxArray` to `dip::sint` by copy.";
constexpr char const* dml·GetFloat·mxArray·CP = "Convert a floating-point number from `mxArray` to `dip::dfloat` by copy.";
constexpr char const* dml·GetComplex·mxArray·CP = "Convert a complex floating-point number from `mxArray` to `dip::dcomplex` by\ncopy.";
constexpr char const* dml·GetBooleanArray·mxArray·CP = "Convert a boolean (logical) array from `mxArray` to `dip::BooleanArray` by\ncopy.";
constexpr char const* dml·GetUnsignedArray·mxArray·CP = "Convert an unsigned integer array from `mxArray` to `dip::UnsignedArray` by\ncopy.";
constexpr char const* dml·GetIntegerArray·mxArray·CP = "Convert a signed integer array from `mxArray` to `dip::IntegerArray` by copy.";
constexpr char const* dml·GetFloatArray·mxArray·CP = "Convert a floating-point array from `mxArray` to `dip::FloatArray` by copy.";
constexpr char const* dml·GetStdVector·T·mxArray·CP = "Convert a 1D real-valued numeric array from `mxArray` to `std::vector< T >` by\ncopy. Data is cast as usual from doubles to the target type (see\n`dip::clamp_cast`).";
constexpr char const* dml·GetStdVectorOfFloats·mxArray·CP = "Convert a floating-point array from `mxArray` to `std::vector<dip::dfloat>` by\ncopy.";
constexpr char const* dml·GetProcessArray·mxArray·CP·dip·uint· = "Convert an unsigned integer `mxArray` to a `dip::BooleanArray`, where elements\nof the input are indices where the output array is set. The output array has\n`nDims` elements. In *MATLAB*, dimensions start with 1. If `mx` is empty, all\ndimensions are to be processed.";
constexpr char const* dml·GetCoordinateArray·mxArray·CP = "Convert a coordinates array from `mxArray` to `dip::CoordinateArray` by copy.";
constexpr char const* dml·GetFloatCoordinateArray·mxArray·CP = "Convert a coordinates array from `mxArray` to `dip::FloatCoordinateArray` by\ncopy.";
constexpr char const* dml·HandleNewStyleString·mxArray·CP = "If `mx` is a \"string\" class object, return a char vector or a cell array of\nchar vectors.";
constexpr char const* dml·GetString·mxArray·CP = "Convert a string from `mxArray` to `dip::String` by copy.";
constexpr char const* dml·GetStringUnicode·mxArray·CP = "Convert a string from `mxArray` to a UTF-8 encoded `dip::String` by copy.";
constexpr char const* dml·GetStringArray·mxArray·CP = "Convert a cell array of strings from `mxArray` to `dip::StringArray` by copy.";
constexpr char const* dml·GetStringSet·mxArray·CP = "Convert a cell array of string from `mxArray` to `dip::StringSet` by copy.";
constexpr char const* dml·GetBoolean·mxArray·CP = "Convert a boolean (logical) from `mxArray` to `bool` by copy. Accepts\n`\"yes\"` and `\"no\"` as well.";
constexpr char const* dml·GetRange·mxArray·CP = "Convert an integer array from `mxArray` to `dip::Range` by copy.";
constexpr char const* dml·GetRangeArray·mxArray·CP = "Convert a cell array of integer array from `mxArray` to `dip::RangeArray` by\ncopy.";
constexpr char const* dml·GetPixel·mxArray·CP = "Convert a numeric array from `mxArray` to `dip::Image::Pixel` by copy.";
constexpr char const* dml·GetHistogramConfiguration·mxArray·CP = "Reads a histogram `Configuration` struct from a cell `mxArray` with key-value\npairs.";
constexpr char const* dml·CreateDouble2Vector·dip·dfloat··dip·dfloat· = "Create a two-element mxArray and write the two values in it.";
constexpr char const* dml·GetArray·bool· = "Convert an boolean from `bool` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·uint· = "Convert an unsigned integer from `dip::uint` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·sint· = "Convert a signed integer from `dip::sint` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·dfloat· = "Convert a floating-point number from `dip::dfloat` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·dcomplex· = "Convert a complex floating-point number from `dip::dcomplex` to `mxArray` by\ncopy.";
constexpr char const* dml·GetArray·T·dip·DimensionArraygtTlt·CL = "Convert a numeric array from `dip::DimensionArray` to `mxArray` by copy. Works\nfor `dip::UnsignedArray`, `dip::IntegerArray` and `dip::FloatArray`.";
constexpr char const* dml·GetArray·dip·CoordinateArray·CL = "Convert a coordinates array from `mxArray` to `dip::CoordinateArray` by copy.";
constexpr char const* dml·GetArray·dip·String·CL = "Convert a string from `dip::String` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·StringArray·CL = "Convert a string array from `dip::StringArray` to `mxArray` by copy.";
constexpr char const* dml·GetArrayUnicode·dip·String·CL = "Convert a UTF-8 encoded string from `dip::String` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·Image·Sample·CL = "Convert a sample from `dip::Image::Sample` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·Image·Pixel·CL = "Convert a set of samples from `dip::Image::Pixel` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·PixelSize·CL = "Convert a pixel size object `dip::PixelSize` to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·FileInformation·CL = "Convert a `dip::FileInformation` structure to `mxArray` by copy.";
constexpr char const* dml·GetArray·dip·Distribution·CL = "Convert a `dip::Distribution` object to `mxArray` by copy.";
constexpr char const* dml·GetImageMode = "`dml::GetImage` can optionally create a shared copy of the input `mxArray`,\nwhich extends its lifetime. This is useful if the MEX-file needs to keep a\nreference to the object.";
constexpr char const* dml·GetImageMode·REFERENCE = "Reference the `mxArray` in the `dip::Image` object.";
constexpr char const* dml·GetImageMode·SHARED_COPY = "Make a shared copy of the `mxArray` and take ownership of the copy.";
constexpr char const* dml·ArrayConversionMode = "`dml::GetImage` can optionally turn an input numeric array to a tensor image.\nIf the numeric array is a short vector (up to 5 elements) or a small matrix\n(up to 5x5 elements) it will be seen as a 0D tensor image.";
constexpr char const* dml·ArrayConversionMode·STANDARD = "All arrays are scalar images.";
constexpr char const* dml·ArrayConversionMode·TENSOR_OPERATOR = "Small arrays are 0D tensor images.";
constexpr char const* dml·GetImage·mxArray·CP·GetImageMode··ArrayConversionMode· = "Passing an `mxArray` to *DIPlib*, keeping ownership of the data.";
constexpr char const* dml·GetImageArray·mxArray·CP = "Convert a cell array of images from `mxArray` to `dip::ImageArray`, using\n`dml::GetImage` for each element of the cell array.";
constexpr char const* dml·MatlabInterface = "This class is the `dip::ExternalInterface` for the *MATLAB* interface.";
constexpr char const* dml·MatlabInterface·AllocateData·void·PL·dip·DataType··dip·UnsignedArray·CL·dip·IntegerArray·L·dip·Tensor·CL·dip·sint·L = "This function overrides `dip::ExternalInterface::AllocateData`.";
constexpr char const* dml·MatlabInterface·NewImage = "Constructs a `dip::Image` object with the external interface set so that, when\nforged, a *MATLAB* `mxArray` will be allocated to hold the samples.";
constexpr char const* dml·GetArrayAsArray·dip·Image·CL·bool· = "Find the `mxArray` that holds the data for the `dip::Image` `img`.";
constexpr char const* dml·GetArray·dip·Image·CL·bool· = "Find the `mxArray` that holds the data for the `dip::Image` `img`, and create\na *MATLAB* `dip_image` object around it.";
constexpr char const* dml·GetKernel·T·int··mxArray·CPA·int·L·dip·uint· = "Gets a structuring element or kernel from the input argument(s) at `index`,\nand `index+1`. `index` is updated to point to the next unused input argument.";
constexpr char const* dml·streambuf = "An output stream buffer for MEX-files.";
constexpr char const* dml·GetPreference·T·dip·String·CL = "Get the value of a property, equivalent to calling `dipgetpref` in *MATLAB*.";
constexpr char const* dip_opencv = "The `dip_opencv` namespace contains the interface between *OpenCV 2* (or\nlater) and *DIPlib*.";
constexpr char const* dip_opencv·MatToDip·cv·Mat·CL·bool· = "Creates a *DIPlib* image around an *OpenCV* `cv::Mat`, without taking\nownership of the data.";
constexpr char const* dip_opencv·DipToMat·dip·Image·CL = "Creates an *OpenCV* `cv::Mat` object around a *DIPlib* image, without taking\nownership of the data.";
constexpr char const* dip_opencv·CopyDipToMat·dip·Image·CL = "Creates an *OpenCV* `cv::Mat` object from a *DIPlib* image by copy.";
constexpr char const* dip_opencv·ExternalInterface = "This class is the `dip::ExternalInterface` for the *OpenCV* interface.";
constexpr char const* dip_opencv·ExternalInterface·GetMat·dip·Image·CL = "Returns the *OpenCV* `cv::Mat` that holds the data for the `dip::Image` `img`.";
constexpr char const* dip_opencv·ExternalInterface·NewImage = "Constructs a `dip::Image` object with the external interface set so that, when\nforged, a *OpenCV* `cv::Mat` will be allocated to hold the samples.";
constexpr char const* dip_opencv·FixBinaryImageForDip·dip·Image·L = "Fixes the binary image `img` to match expectations of *DIPlib* (i.e. only the\nbottom bit is used).";
constexpr char const* dip_opencv·FixBinaryImageForOpenCv·dip·Image·L = "Fixes the binary image `img` to match expectations of *OpenCV* (i.e. all bits\nhave the same value).";
constexpr char const* dip_vigra = "The `dip_vigra` namespace contains the interface between *Vigra* and *DIPlib*.";
constexpr char const* dip_vigra·VigraToDip·T·vigra·MultiArrayViewgtDimensionality__PixelType__StrideTaglt·CL = "Creates a *DIPlib* image around a *Vigra* `vigra::MultiArrayView`, without\ntaking ownership of the data.";
constexpr char const* dip_vigra·DipToVigra·T·dip·Image·CL = "Creates a *Vigra* `vigra::MultiArrayView` object around a *DIPlib* image,\nwithout taking ownership of the data.";
constexpr char const* dip_vigra·CopyDipToVigra·T·dip·Image·CL = "Creates a *Vigra* `vigra::MultiArrayView` object from a *DIPlib* image by\ncopy.";
constexpr char const* dip = "The `dip` namespace contains all the library functionality.";
constexpr char const* dip·LibraryInformation = "Holds information about the *DIPlib* binary.";
constexpr char const* dip·LibraryInformation·name = "The library name, always `\"DIPlib\"`.";
constexpr char const* dip·LibraryInformation·description = "A short description string.";
constexpr char const* dip·LibraryInformation·copyright = "Copyright string for the library.";
constexpr char const* dip·LibraryInformation·URL = "Library website, with contact information etc.";
constexpr char const* dip·LibraryInformation·version = "The library version number.";
constexpr char const* dip·LibraryInformation·date = "Compilation date.";
constexpr char const* dip·LibraryInformation·type = "Describes options enabled during compilation, providing a string\nrepresentation of the boolean flags.";
constexpr char const* dip·LibraryInformation·isReleaseBuild = "If true, this is a release build; otherwise, this is a debug build.";
constexpr char const* dip·LibraryInformation·usingOpenMP = "If true, multithreading is enabled; otherwise, the library is single-threaded.";
constexpr char const* dip·LibraryInformation·stackTracesEnabled = "If true, exceptions report a stack trace, rather than only show the function\nthat threw it.";
constexpr char const* dip·LibraryInformation·assertsEnabled = "If true, additional run-time tests for consistency are executed.";
constexpr char const* dip·LibraryInformation·usingUnicode = "If true, Unicode text is used for example to represent units.";
constexpr char const* dip·LibraryInformation·hasICS = "If true, ICS file reading and writing is available.";
constexpr char const* dip·LibraryInformation·hasTIFF = "If true, TIFF file reading and writing is available.";
constexpr char const* dip·LibraryInformation·hasJPEG = "If true, JPEG file reading and writing is available.";
constexpr char const* dip·LibraryInformation·hasPNG = "If true, PNG file reading and writing is available.";
constexpr char const* dip·LibraryInformation·usingFFTW = "If true, FFTW is used for FFTs; otherwise, PocketFFT is used.";
constexpr char const* dip·LibraryInformation·usingFreeType = "If true, FreeType text rendering functionality is available.";
constexpr char const* dip·libraryInformation = "Constant that holds information about the *DIPlib* binary.";
constexpr char const* dip·viewer = "Contains all functionality for *DIPviewer*.";
constexpr char const* dip·viewer·Show·Image·CL·String·CL·dip·uint··dip·uint· = "Show an image in the slice viewer.";
constexpr char const* dip·viewer·ShowSimple·Image·CL·String·CL·dip·uint··dip·uint· = "Show a 2D grey-value or RGB image, of type `dip::DT_UINT8`.";
constexpr char const* dip·viewer·Spin = "Wait until all windows are closed.";
constexpr char const* dip·viewer·Draw = "Process user event queue.";
constexpr char const* dip·viewer·CloseAll = "Close all open windows.";
constexpr char const* dip·viewer·ControlViewPort = "Allows the user to control how the image is displayed.";
constexpr char const* dip·viewer·GLFWManager = "Simple GLFW window manager.";
constexpr char const* dip·viewer·GLUTManager = "Simple GLUT window manager.";
constexpr char const* dip·viewer·HistogramViewPort = "Controls grey-value mapping range and shows color mapping.";
constexpr char const* dip·viewer·ImageView·image_ = "2D RGB image";
constexpr char const* dip·viewer·ImageView·texture_ = "OpenGL texture identifier.";
constexpr char const* dip·viewer·ImageViewer = "Non-interactive 2D RGB image viewer.";
constexpr char const* dip·viewer·ImageViewer·Ptr = "A pointer to an `ImageViewer`.";
constexpr char const* dip·viewer·ImageViewer·Create·dip·Image·CL·std·string··dip·uint··dip·uint· = "Construct a new `ImageViewer`.";
constexpr char const* dip·viewer·LinkViewPort = "Handles viewer linking.";
constexpr char const* dip·viewer·LinkViewPort·update = "Update linked viewers' options";
constexpr char const* dip·viewer·LinkViewPort·update·ViewingOptions·CL = "Update from linked viewer's options";
constexpr char const* dip·viewer·LinkViewPort·link·LinkViewPort·P = "Add linked viewer";
constexpr char const* dip·viewer·LinkViewPort·unlink·LinkViewPort·P = "Remove linked viewer";
constexpr char const* dip·viewer·Window = "Simple GL window";
constexpr char const* dip·viewer·Window·refresh = "Refresh window contents.";
constexpr char const* dip·viewer·Window·destroy = "Marks the window for destruction.";
constexpr char const* dip·viewer·Window·destroyed·C = "Returns whether the window is marked for destruction.";
constexpr char const* dip·viewer·Window·drawString·char·CP = "Draw a string onto the window.";
constexpr char const* dip·viewer·Window·width·C = "Returns the window's width.";
constexpr char const* dip·viewer·Window·height·C = "Returns the window's height.";
constexpr char const* dip·viewer·Window·setPosition·int··int· = "Set the window's screen position.";
constexpr char const* dip·viewer·Window·setSize·int··int· = "Set the window's size.";
constexpr char const* dip·viewer·Window·manager = "Returns the `dip::viewer::Manager` that manages this window.";
constexpr char const* dip·viewer·Window·id = "Returns the window's identity.";
constexpr char const* dip·viewer·Window·title·char·CP = "Sets the window's title.";
constexpr char const* dip·viewer·Window·swap = "Swaps display buffers.";
constexpr char const* dip·viewer·Window·requestSize·dip·uint··dip·uint· = "Suggests a window's size.";
constexpr char const* dip·viewer·Window·release = "Release any resources held or referenced by this window.";
constexpr char const* dip·viewer·Window·draw = "Overridable callback that draws the visualization.";
constexpr char const* dip·viewer·Window·idle = "Overridable callback that is called periodically to allow for animation.";
constexpr char const* dip·viewer·Window·reshape·int··int· = "Overridable callback that is called when the window shape is changed.";
constexpr char const* dip·viewer·Window·visible·int· = "Overridable callback that is called when the window visibility changes.";
constexpr char const* dip·viewer·Window·create = "Overridable callback that is called when the window is created.";
constexpr char const* dip·viewer·Window·close = "Overridable callback that is called when the window is closed.";
constexpr char const* dip·viewer·Window·key·unsigned_char··int··int··int· = "Overridable callback that is called when a key is pressed.";
constexpr char const* dip·viewer·Window·click·int··int··int··int··int· = "Overridable callback that is called when a mouse button is clicked.";
constexpr char const* dip·viewer·Window·motion·int··int· = "Overridable callback that is called when the mouse is moved while a button is\nclicked.";
constexpr char const* dip·viewer·Window·manager·Manager·P = "Sets the window's manager.";
constexpr char const* dip·viewer·Window·id·void·P = "Sets the window's identity.";
constexpr char const* dip·viewer·Window·resize·int··int· = "Sets the window's size.";
constexpr char const* dip·viewer·WindowPtr = "Shared pointer to a Window";
constexpr char const* dip·viewer·Manager = "Simple window manager.";
constexpr char const* dip·viewer·Manager·createWindow·WindowPtr· = "Create a window.";
constexpr char const* dip·viewer·Manager·activeWindows = "Returns the number of managed windows.";
constexpr char const* dip·viewer·Manager·destroyWindows = "Destroys all windows.";
constexpr char const* dip·viewer·Manager·processEvents = "Processes event queue.";
constexpr char const* dip·viewer·Manager·swapBuffers·Window·P = "Swap display buffers.";
constexpr char const* dip·viewer·Manager·setWindowTitle·Window·P·char·CP = "Sets a Window's title.";
constexpr char const* dip·viewer·Manager·refreshWindow·Window·P = "Refresh a Window's contents.";
constexpr char const* dip·viewer·Manager·setWindowPosition·Window·P·int··int· = "Set a Window's screen position.";
constexpr char const* dip·viewer·Manager·setWindowSize·Window·P·int··int· = "Set a Window's size.";
constexpr char const* dip·viewer·SliceView·projected_ = "Projected (2D) image.";
constexpr char const* dip·viewer·SliceView·colored_ = "Colored (RGB) image.";
constexpr char const* dip·viewer·SliceView·csm_ = "For `dip::viewer::ViewingOptions::LookupTable::ColorSpace`";
constexpr char const* dip·viewer·SliceView·dimx_ = "Indices in options.dims_.";
constexpr char const* dip·viewer·SliceView·dimy_ = "Indices in options.dims_.";
constexpr char const* dip·viewer·SliceView·texture_ = "OpenGL texture identifier.";
constexpr char const* dip·viewer·SliceView·dirty_ = "Texture needs to be rebuilt.";
constexpr char const* dip·viewer·SliceViewer = "Interactive nD tensor image viewer.";
constexpr char const* dip·viewer·SliceViewer·Ptr = "A pointer to a `SliceViewer`.";
constexpr char const* dip·viewer·SliceViewer·Create·dip·Image·CL·std·string··dip·uint··dip·uint· = "Construct a new `SliceViewer`.";
constexpr char const* dip·viewer·SliceViewer·updateLinkedViewers = "Update linked viewers.";
constexpr char const* dip·viewer·SliceViewer·link·SliceViewer·L = "Link this viewer to another, compatible one.";
constexpr char const* dip·viewer·StatusViewPort = "Displays the `dip::viewer::Viewer`'s status.";
constexpr char const* dip·viewer·TensorViewPort = "Allows the user to control which tensor elements are visualized.";
constexpr char const* dip·viewer·FloatRange = "Specifies a range of values between a lower and upper limit";
constexpr char const* dip·viewer·FloatRangeArray = "Specifies an array of ranges (typically one per tensor element)";
constexpr char const* dip·viewer·ViewingOptions = "Model that determines the `dip::viewer::SliceViewer`'s behavior";
constexpr char const* dip·viewer·ViewingOptions·ComplexToReal = "Complex-to-real mapping options";
constexpr char const* dip·viewer·ViewingOptions·Mapping = "Grey-value mapping options";
constexpr char const* dip·viewer·ViewingOptions·Projection = "Slice projection options";
constexpr char const* dip·viewer·ViewingOptions·LookupTable = "Grey-value to color mapping options";
constexpr char const* dip·viewer·ViewingOptions·Diff = "Defines which view (parts) need to be recalculated";
constexpr char const* dip·viewer·ViewingOptions·dims_ = "Dimensions to visualize (MainX, MainY, LeftX, TopY). Use -1 to not map to any\nimage dimension.";
constexpr char const* dip·viewer·ViewingOptions·operating_point_ = "Coordinates of selected point, which also determines which slice is shown.";
constexpr char const* dip·viewer·ViewingOptions·complex_ = "What to do with complex numbers.";
constexpr char const* dip·viewer·ViewingOptions·projection_ = "Type of projection.";
constexpr char const* dip·viewer·ViewingOptions·roi_origin_ = "Origin of projection ROI.";
constexpr char const* dip·viewer·ViewingOptions·roi_sizes_ = "Sizes of projection ROI.";
constexpr char const* dip·viewer·ViewingOptions·labels_ = "Labels to use for axes, one character per axis.";
constexpr char const* dip·viewer·ViewingOptions·range_ = "value range across image (histogram limits).";
constexpr char const* dip·viewer·ViewingOptions·tensor_range_ = "value range per tensor.";
constexpr char const* dip·viewer·ViewingOptions·mapping_range_ = "mapped value range (colorbar limits).";
constexpr char const* dip·viewer·ViewingOptions·mapping_ = "Grey-value mapping options, sets mapping_range_.";
constexpr char const* dip·viewer·ViewingOptions·element_ = "Tensor element to visualize.";
constexpr char const* dip·viewer·ViewingOptions·lut_ = "Grey-value to color mapping options.";
constexpr char const* dip·viewer·ViewingOptions·color_elements_ = "Which tensor element is R, G, and B.";
constexpr char const* dip·viewer·ViewingOptions·split_ = "Split point between projections (pixels).";
constexpr char const* dip·viewer·ViewingOptions·zoom_ = "Zoom factor per dimension (from physical dimensions + user). Also determines\nrelative viewport sizes.";
constexpr char const* dip·viewer·ViewingOptions·origin_ = "Display origin for moving the image around.";
constexpr char const* dip·viewer·ViewingOptions·offset_ = "Offset of origin pixel in real-world coordinates.";
constexpr char const* dip·viewer·ViewingOptions·status_ = "Status bar text.";
constexpr char const* dip·viewer·ViewingOptions·ViewingOptions·dip·Image·CL = "Calculate default options from an image";
constexpr char const* dip·viewer·ViewingOptions·diff·ViewingOptions·CL·C = "Calculates which view (parts) need to be recalculated";
constexpr char const* dip·viewer·ViewingOptions·needsReproject·ViewingOptions·CL·dip·uint··dip·uint··C = "Calculates whether a particular slice projection needs to be recalculated";
constexpr char const* dip·viewer·ViewingOptions·setAutomaticRange = "Sets automatic range based on current lookup table and mapping";
constexpr char const* dip·viewer·ViewingOptions·setMappingRange·ViewingOptions·Mapping· = "Sets mapping range based on mapping";
constexpr char const* dip·viewer·ViewingOptions·getComplexDescription·C = "Returns a textual description of the current complex-to-real mapping";
constexpr char const* dip·viewer·ViewingOptions·getMappingDescription·C = "Returns a textual description of the current grey-value mapping";
constexpr char const* dip·viewer·ViewingOptions·getProjectionDescription·C = "Returns a textual description of the current slice projection";
constexpr char const* dip·viewer·ViewingOptions·getLookupTableDescription·C = "Returns a textual description of the current grey-value to color mapping";
constexpr char const* dip·viewer·View = "Displays a view of the `dip::viewer::ViewingOptions` model";
constexpr char const* dip·viewer·View·rebuild = "Set up rendering. May take a while.";
constexpr char const* dip·viewer·View·render = "Render to screen.";
constexpr char const* dip·viewer·View·size·dip·uint· = "Size in internal coordinates.";
constexpr char const* dip·viewer·View·viewport = "Parent viewport";
constexpr char const* dip·viewer·ViewPort = "Handles interaction in a certain display area to control the\n`dip::viewer::ViewingOptions` model";
constexpr char const* dip·viewer·ViewPort·place·int··int··int··int· = "Places the viewport";
constexpr char const* dip·viewer·ViewPort·rebuild = "Prepares the associated view for rendering";
constexpr char const* dip·viewer·ViewPort·render = "Renders the associated view";
constexpr char const* dip·viewer·ViewPort·click·int··int··int··int··int· = "Handles mouse clicking interaction";
constexpr char const* dip·viewer·ViewPort·motion·int··int··int· = "Handles mouse dragging interaction";
constexpr char const* dip·viewer·ViewPort·screenToView·int··int··double·P·double·P = "Converts screen coordinates into local view coordinates";
constexpr char const* dip·viewer·ViewPort·viewer = "Parent viewer";
constexpr char const* dip·viewer·ViewPort·x·C = "Screen coordinate of left edge";
constexpr char const* dip·viewer·ViewPort·y·C = "Screen coordinate of bottom edge";
constexpr char const* dip·viewer·ViewPort·width·C = "Viewport width";
constexpr char const* dip·viewer·ViewPort·height·C = "Viewport height";
constexpr char const* dip·viewer·Viewer = "A Window for viewing a `dip::Image`";
constexpr char const* dip·viewer·Viewer·options = "Returns the `Viewer`'s model";
constexpr char const* dip·viewer·Viewer·image = "Returns the `dip::Image` being visualized, converted to real valued.";
constexpr char const* dip·viewer·Viewer·original = "Returns the `dip::Image` being visualized.";
constexpr char const* dip·viewer·Viewer·setImage·dip·Image·CL = "Sets the image to be visualized.";
constexpr char const* dip·viewer·Viewer·name = "Returns the `Viewer`'s name";
constexpr char const* dip·viewer·Viewer·setWindowTitle·char·CP = "Set window title, in addition to the `Viewer`'s name";
constexpr char const* dip·viewer·Viewer·lock = "Lock the viewer. Necessary before making programmatic changes.";
constexpr char const* dip·viewer·Viewer·unlock = "Unlock the viewer.";
constexpr char const* dip·viewer·rangeMap·T·T··double··double··ViewingOptions·Mapping· = "Maps an image grey-value onto [0,255]";
constexpr char const* dip·viewer·rangeMap·T·T··ViewingOptions·CL = "Maps an image grey-value onto [0,255]";
constexpr char const* dip·viewer·to_string·T·dip·DimensionArraygtTlt· = "String conversion for `dip::DimensionArray`";
constexpr char const* dip·viewer·ApplyViewerColorMap·dip·Image·L·dip·Image·L·ViewingOptions·L = "Applies the colormap defined by the `dip::viewer::ViewingOptions`";
constexpr char const* dip·clamp_cast·T·SourceType· = "Casts a value of any pixel type to any other pixel type, clamping it to the\ndestination range.";
constexpr char const* dip·BoundaryCondition = "Enumerates various ways of extending image data beyond its boundary.";
constexpr char const* dip·DataType = "`DataType` objects are used to indicate what the data type of an image is.";
constexpr char const* dip·DataType·DataType = "The default data type is single-precision Float (`dip::DT_SFLOAT`).";
constexpr char const* dip·DataType·DataType·T·T· = "Get the data type value of any expression, as long as that expression is of\none of the known data types";
constexpr char const* dip·DataType·DataType·String·CL = "A string can be cast to a data type. See Pixel data types for recognized\nstrings.";
constexpr char const* dip·DataType·swap·DataType·L = "Swaps the values of `this` and `other`";
constexpr char const* dip·DataType·operator_int·C = "`DataType` objects implicitly convert to the enumeration integer.";
constexpr char const* dip·DataType·operatoreqeq·DataType··C = "`DataType` objects can be compared.";
constexpr char const* dip·DataType·Name·C = "Returns a C-style string constant with a representation of the data type name.\nSee Pixel data types for returned strings.";
constexpr char const* dip·DataType·SizeOf·C = "Returns the size in bytes of the data type.";
constexpr char const* dip·DataType·IsInRange·dip·sint··C = "Returns true if the integer `value` is within the range representable by the\ndata type.";
constexpr char const* dip·DataType·IsInRange·dip·uint··C = "Returns true if the integer `value` is within the range representable by the\ndata type.";
constexpr char const* dip·DataType·Real·C = "Returns the real data type corresponding to a complex data type";
constexpr char const* dip·DataType·Classes = "Specifies a collection of data types.";
constexpr char const* dip·DataType·operator_Classes·C = "Implicit conversion to `dip::DataType::Classes` options class.";
constexpr char const* dip·DataType·IsA·Classes··C = "Returns `true` if the data type is of the given class.";
constexpr char const* dip·DataType·IsBinary·C = "Returns `true` if the data type is binary.";
constexpr char const* dip·DataType·IsUInt·C = "Returns `true` if the data type is an unsigned integer type.";
constexpr char const* dip·DataType·IsSInt·C = "Returns `true` if the data type is a signed integer type.";
constexpr char const* dip·DataType·IsInteger·C = "Returns `true` if the data type is an integer type.";
constexpr char const* dip·DataType·IsFloat·C = "Returns `true` if the data type is a floating point type.";
constexpr char const* dip·DataType·IsReal·C = "Returns `true` if the data type is real (floating point or integer).";
constexpr char const* dip·DataType·IsFlex·C = "Returns `true` if the data type is one of the \"flex\" types (floating point\nor complex).";
constexpr char const* dip·DataType·IsFlexBin·C = "Returns `true` if the data type is floating point, complex or binary.";
constexpr char const* dip·DataType·IsComplex·C = "Returns `true` if the data type is complex.";
constexpr char const* dip·DataType·IsUnsigned·C = "Returns `true` if the data type is an unsigned type (binary or unsigned\ninteger).";
constexpr char const* dip·DataType·IsSigned·C = "Returns `true` if the data type is a signed type (signed integer, floating\npoint or complex)";
constexpr char const* dip·DataType·SuggestInteger·DataType· = "Returns an integer type that is most suitable to hold samples of `type`. See\nPixel data types.";
constexpr char const* dip·DataType·SuggestSigned·DataType· = "Returns a signed type that is most suitable to hold samples of `type`. See\nPixel data types.";
constexpr char const* dip·DataType·SuggestFloat·DataType· = "Returns a suitable floating-point type that can hold the samples of `type`.\nSee Pixel data types.";
constexpr char const* dip·DataType·SuggestDouble·DataType· = "Returns a suitable double precision floating-point type (real or complex) that\ncan hold large sums of `type`. See Pixel data types.";
constexpr char const* dip·DataType·SuggestComplex·DataType· = "Returns a suitable complex type that can hold the samples of `type`. See Pixel\ndata types.";
constexpr char const* dip·DataType·SuggestFlex·DataType· = "Returns a suitable floating-point or complex type that can hold the samples of\n`type`. See Pixel data types.";
constexpr char const* dip·DataType·SuggestFlexBin·DataType· = "Returns a suitable floating-point, complex or binary type that can hold the\nsamples of `type`. See Pixel data types.";
constexpr char const* dip·DataType·SuggestAbs·DataType· = "Returns a suitable type that can hold samples of type `abs(type)`. See Pixel\ndata types.";
constexpr char const* dip·DataType·SuggestReal·DataType· = "Returns a suitable real type that can hold the samples of `type`. See Pixel\ndata types.";
constexpr char const* dip·DataType·SuggestArithmetic·DataType··DataType· = "Returns a suitable floating-point, complex or binary type (\"FlexBin\") that\ncan hold the result of an arithmetic computation performed with the two data\ntypes.";
constexpr char const* dip·DataType·SuggestDyadicOperation·DataType··DataType· = "Returns a suitable type that can hold any samples of the two data types.";
constexpr char const* dip·operatorltlt·std·ostream·L·DataType· = "You can output a `dip::DataType` to `std::cout` or any other stream. The\nresult of `type.Name()` is written.";
constexpr char const* dip·DataTypeArray = "An array to hold data types";
constexpr char const* dip·DT_BIN = "Constant representing the type `dip::bin`.";
constexpr char const* dip·DT_UINT8 = "Constant representing the type `dip::uint8`.";
constexpr char const* dip·DT_SINT8 = "Constant representing the type `dip::sint8`.";
constexpr char const* dip·DT_UINT16 = "Constant representing the type `dip::uint16`.";
constexpr char const* dip·DT_SINT16 = "Constant representing the type `dip::sint16`.";
constexpr char const* dip·DT_UINT32 = "Constant representing the type `dip::uint32`.";
constexpr char const* dip·DT_SINT32 = "Constant representing the type `dip::sint32`.";
constexpr char const* dip·DT_UINT64 = "Constant representing the type `dip::uint64`.";
constexpr char const* dip·DT_SINT64 = "Constant representing the type `dip::sint64`.";
constexpr char const* dip·DT_SFLOAT = "Constant representing the type `dip::sfloat`.";
constexpr char const* dip·DT_DFLOAT = "Constant representing the type `dip::dfloat`.";
constexpr char const* dip·DT_SCOMPLEX = "Constant representing the type `dip::scomplex`.";
constexpr char const* dip·DT_DCOMPLEX = "Constant representing the type `dip::dcomplex`.";
constexpr char const* dip·DT_LABEL = "Type currently used for all labeled images, see `dip::LabelType`.";
constexpr char const* dip·DimensionArray·T = "A dynamic array type optimized for few elements.";
constexpr char const* dip·DimensionArray·T·value_type = "Type of values stored in container";
constexpr char const* dip·DimensionArray·T·iterator = "Type of container's iterator";
constexpr char const* dip·DimensionArray·T·const_iterator = "Type of container's const iterator";
constexpr char const* dip·DimensionArray·T·reverse_iterator = "Type of container's reverse iterator";
constexpr char const* dip·DimensionArray·T·const_reverse_iterator = "Type of container's const reverse iterator";
constexpr char const* dip·DimensionArray·T·size_type = "Type of index into container";
constexpr char const* dip·DimensionArray·T·DimensionArray = "The default-initialized array has zero size.";
constexpr char const* dip·DimensionArray·T·DimensionArray·size_type··T· = "Like `std::vector`, you can initialize with a size and a default value.";
constexpr char const* dip·DimensionArray·T·DimensionArray·std·initializer_listgtTlt·C = "Like `std::vector`, you can initialize with a set of values in braces.";
constexpr char const* dip·DimensionArray·T·DimensionArray·DimensionArraygtTlt·CL = "Copy constructor, initializes with a copy of `other`.";
constexpr char const* dip·DimensionArray·T·DimensionArrayltTgt·T·DimensionArraygtOlt·CL = "Cast constructor, initializes with a copy of `other`. Casting done as default\nin C++, not through `dip::clamp_cast`.";
constexpr char const* dip·DimensionArray·T·DimensionArray·DimensionArraygtTlt·R = "Move constructor, initializes by stealing the contents of `other`.";
constexpr char const* dip·DimensionArray·T·operatoreq·DimensionArraygtTlt·CL = "Copy assignment, copies over data from `other`.";
constexpr char const* dip·DimensionArray·T·operatoreq·DimensionArraygtTlt·R = "Move assignment, steals the contents of `other`.";
constexpr char const* dip·DimensionArray·T·swap·DimensionArraygtTlt·L = "Swaps the contents of two arrays.";
constexpr char const* dip·DimensionArray·T·resize·size_type··T· = "Resizes the array, making it either larger or smaller. Initializes new\nelements with `newval`.";
constexpr char const* dip·DimensionArray·T·clear = "Clears the contents of the array, set its length to 0.";
constexpr char const* dip·DimensionArray·T·empty·C = "Checks whether the array is empty (size is 0).";
constexpr char const* dip·DimensionArray·T·size·C = "Returns the size of the array.";
constexpr char const* dip·DimensionArray·T·operatorsqbra·size_type· = "Accesses an element of the array";
constexpr char const* dip·DimensionArray·T·operatorsqbra·size_type··C = "Accesses an element of the array";
constexpr char const* dip·DimensionArray·T·front = "Accesses the first element of the array";
constexpr char const* dip·DimensionArray·T·front·C = "Accesses the first element of the array";
constexpr char const* dip·DimensionArray·T·back = "Accesses the last element of the array";
constexpr char const* dip·DimensionArray·T·back·C = "Accesses the last element of the array";
constexpr char const* dip·DimensionArray·T·data = "Returns a pointer to the underlying data";
constexpr char const* dip·DimensionArray·T·data·C = "Returns a pointer to the underlying data";
constexpr char const* dip·DimensionArray·T·begin = "Returns an iterator to the beginning";
constexpr char const* dip·DimensionArray·T·begin·C = "Returns an iterator to the beginning";
constexpr char const* dip·DimensionArray·T·end = "Returns an iterator to the end";
constexpr char const* dip·DimensionArray·T·end·C = "Returns an iterator to the end";
constexpr char const* dip·DimensionArray·T·rbegin = "Returns a reverse iterator to the beginning";
constexpr char const* dip·DimensionArray·T·rbegin·C = "Returns a reverse iterator to the beginning";
constexpr char const* dip·DimensionArray·T·rend = "Returns a reverse iterator to the end";
constexpr char const* dip·DimensionArray·T·rend·C = "Returns a reverse iterator to the end";
constexpr char const* dip·DimensionArray·T·insert·size_type··T·CL = "Adds a value at the given location, moving the current value at that location\nand subsequent values forward by one.";
constexpr char const* dip·DimensionArray·T·push_back·T·CL = "Adds a value to the back. Not efficient -- prefer `std::vector` if you need to\nuse this repeatedly.";
constexpr char const* dip·DimensionArray·T·append·DimensionArraygtTlt·CL = "Adds all values in source array to the back.";
constexpr char const* dip·DimensionArray·T·erase·size_type· = "Removes the value at the given location, moving subsequent values forward by\none.";
constexpr char const* dip·DimensionArray·T·pop_back = "Removes the value at the back.";
constexpr char const* dip·DimensionArray·T·operatorpluseq·T·CL = "Adds a constant to each element in the array.";
constexpr char const* dip·DimensionArray·T·operatorpluseq·T·DimensionArraygtSlt·CL = "Adds an array to `this`, element-wise. `other` must have the same number of\nelements.";
constexpr char const* dip·DimensionArray·T·operatorminuseq·T·CL = "Subtracts a constant from each element in the array.";
constexpr char const* dip·DimensionArray·T·operatorminuseq·T·DimensionArraygtSlt·CL = "Subtracts an array from `this`, element-wise. `other` must have the same\nnumber of elements.";
constexpr char const* dip·DimensionArray·T·operatortimeseq·T·CL = "Multiplies each element in the array by a constant.";
constexpr char const* dip·DimensionArray·T·operatordiveq·T·CL = "Divides each element in the array by a constant.";
constexpr char const* dip·DimensionArray·T·sort = "Sort the contents of the array from smallest to largest.";
constexpr char const* dip·DimensionArray·T·sort·T·DimensionArraygtSlt·L = "Sort the contents of the array from smallest to largest, and keeping `other`\nin the same order.";
constexpr char const* dip·DimensionArray·T·reverse = "Reverses the elements in the array, putting the first element at the end.";
constexpr char const* dip·DimensionArray·T·sorted_indices·C = "Returns an array with indices into the array, sorted from smallest value to\nlargest.";
constexpr char const* dip·DimensionArray·T·permute·DimensionArraygtsize_typelt·CL·C = "Order the elements in the array according to the `order` array, such as\nreturned by `sorted_indices`.";
constexpr char const* dip·DimensionArray·T·inverse_permute·DimensionArraygtsize_typelt·CL·C = "Inverse orders the elements in the array according to the `order` array, such\nas returned by `sorted_indices`.";
constexpr char const* dip·DimensionArray·T·find·T··C = "Finds the first occurrence of `value` in the array, returns the index or\n`size()` if it is not present.";
constexpr char const* dip·DimensionArray·T·sum·C = "Compute the sum of the elements in the array.";
constexpr char const* dip·DimensionArray·T·product·C = "Compute the product of the elements in the array. Returns 1 for an empty\narray.";
constexpr char const* dip·DimensionArray·T·norm_square·C = "Compute the sum of the squares of the elements in the array.";
constexpr char const* dip·DimensionArray·T·minimum·C = "Find the minimum element in the array, returns the index or 0 if the array is\nempty.";
constexpr char const* dip·DimensionArray·T·maximum·C = "Find the maximum element in the array, returns the index or 0 if the array is\nempty.";
constexpr char const* dip·DimensionArray·T·minimum_value·C = "Find the minimum element in the array, returns the value. The array must not\nbe empty.";
constexpr char const* dip·DimensionArray·T·minimum_value = "Find the minimum element in the array, returns the value. The array must not\nbe empty.";
constexpr char const* dip·DimensionArray·T·maximum_value·C = "Find the maximum element in the array, returns the value. The array must not\nbe empty.";
constexpr char const* dip·DimensionArray·T·maximum_value = "Find the maximum element in the array, returns the value. The array must not\nbe empty.";
constexpr char const* dip·DimensionArray·T·all·C = "True if all elements are non-zero.";
constexpr char const* dip·DimensionArray·T·any·C = "True if one element is non-zero.";
constexpr char const* dip·DimensionArray·T·count·C = "Count of number of elements that are non-zero.";
constexpr char const* dip·DimensionArray·T·fill·T·CL = "Assigns one same value to each element in the array";
constexpr char const* dip·operatoreqeq·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true only if they have the same size and contain\nthe same values.";
constexpr char const* dip·operatornoteq·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true if they have different size and/or contain\ndifferent values.";
constexpr char const* dip·operatorgt·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true only if they have the same size and all\n`lhs` elements are larger than all `rhs` elements.";
constexpr char const* dip·operatorlt·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true only if they have the same size and all\n`lhs` elements are smaller than all `rhs` elements.";
constexpr char const* dip·operatorgteq·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true only if they have the same size and all\n`lhs` elements are larger or equal than all `rhs` elements.";
constexpr char const* dip·operatorlteq·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Compares two arrays, returns true only if they have the same size and all\n`lhs` elements are smaller or equal than all `rhs` elements.";
constexpr char const* dip·operatoreqeq·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatornoteq·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatorgt·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatorlt·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatorgteq·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatorlteq·T·DimensionArraygtTlt·CL·T·CL = "Compares an array to a scalar, returns a boolean array.";
constexpr char const* dip·operatorltlt·T·std·ostream·L·DimensionArraygtTlt·CL = "Writes the array to a stream";
constexpr char const* dip·sortIndices·T·DimensionArraygttypename_DimensionArraygtTlt·size_typelt·L·DimensionArraygtTlt·CL = "Sorts the `indices` array with indices into the `data` array, from smallest to\nlargest. The sort is stable.";
constexpr char const* dip·SquareDistance·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Computes the Square Euclidean distance between two points.";
constexpr char const* dip·Distance·T·DimensionArraygtTlt·CL·DimensionArraygtTlt·CL = "Computes the Square Euclidean distance between two points.";
constexpr char const* dip·Error = "Base exception class. All exceptions thrown in *DIPlib* are derived of this\nclass.";
constexpr char const* dip·Error·what·C = "Return a message indicating what caused the exception to be thrown, as well as\nthe location where the error occurred.";
constexpr char const* dip·Error·Message·C = "Return a message indicating what caused the exception to be thrown, without\nlocation information.";
constexpr char const* dip·Error·AddStackTrace·std·string·CL·std·string·CL·unsigned_int· = "Add an entry to the stack trace. Typically called through the\n`DIP_ADD_STACK_TRACE` macro.";
constexpr char const* dip·Error·IsSet·C = "Returns true if an error message is set. Use this to distinguish from a\ndefault-constructed error.";
constexpr char const* dip·AssertionError = "Exception class indicating that an internal inconsistency was found (the\nlibrary code is wrong).";
constexpr char const* dip·ParameterError = "Exception class indicating that a function received an inconsistent or out of\nrange parameter (the calling code is wrong).";
constexpr char const* dip·RunTimeError = "Exception class indicating that something happened that we couldn't predict\n(e.g. file error).";
constexpr char const* dip·DataSegment = "A `dip::Image` holds a shared pointer to the data segment using this type.";
constexpr char const* dip·NonOwnedRefToDataSegment·void·P = "This function converts a pointer to a `dip::DataSegment` that does not own the\ndata pointed to.";
constexpr char const* dip·NonOwnedRefToDataSegment·void·CP = "This function converts a pointer to a `dip::DataSegment` that does not own the\ndata pointed to.";
constexpr char const* dip·ExternalInterface = "Support for external interfaces.";
constexpr char const* dip·ExternalInterface·AllocateData·void·PL·dip·DataType··UnsignedArray·CL·IntegerArray·L·dip·Tensor·CL·dip·sint·L = "Allocates the data for an image. The function is required to set `strides`,";
constexpr char const* dip·AlignedAllocInterface = "`dip::ExternalInterface` that allocates aligned data.";
constexpr char const* dip·AlignedAllocInterface·AllocateData·void·PL·dip·DataType··UnsignedArray·CL·IntegerArray·L·dip·Tensor·CL·dip·sint·L = "Called by `dip::Image::Forge`.";
constexpr char const* dip·AlignedAllocInterface·GetInstance·T = "Singleton interface, templated in the `alignment` parameter. Only one instance\nis needed for each distinct alignment. `alignment` is in bytes.";
constexpr char const* dip·CoordinatesComputer = "Computes pixel coordinates based on an index or offset.";
constexpr char const* dip·IsOnEdge·UnsignedArray·CL·UnsignedArray·CL·dip·uint· = "Determines whether the pixel at `coords` is on the edge of an image of size\n`sizes`.";
constexpr char const* dip·ImageArray = "An array of images";
constexpr char const* dip·ImageRefArray = "An array of image references";
constexpr char const* dip·ImageConstRefArray = "An array of const image references";
constexpr char const* dip·Image = "Represents an image with all associated information.";
constexpr char const* dip·Image·Image = "The default-initialized image is 0D (an empty sizes array), one tensor\nelement, `dip::DT_SFLOAT`, and raw (it has no data segment).";
constexpr char const* dip·Image·Image·Image·R = "Move constructor, `rhs` ends up in default-initialized state, `this` even robs\nthe external interface from `rhs`.";
constexpr char const* dip·Image·operatoreq·Image·CL = "Copy assignment";
constexpr char const* dip·Image·operatoreq·Image·R = "Move assignment";
constexpr char const* dip·Image·Image·UnsignedArray··dip·uint··dip·DataType· = "Forged image of given sizes and data type. The data is left uninitialized.";
constexpr char const* dip·Image·Image·Pixel·CL = "Create a 0-D image with the data type, tensor shape, and values of `pixel`.";
constexpr char const* dip·Image·Image·Pixel·CL·dip·DataType· = "Create a 0-D image with data type `dt`, and tensor shape and values of\n`pixel`.";
constexpr char const* dip·Image·Image·Sample·CL = "Create a 0-D image with the data type and value of `sample`.";
constexpr char const* dip·Image·Image·Sample·CL·dip·DataType· = "Create a 0-D image with data type `dt` and value of `sample`.";
constexpr char const* dip·Image·Image·FloatArray·CL·dip·DataType· = "Create a 0-D vector image with data type `dt`, and values of `values`.";
constexpr char const* dip·Image·Image·View·CL = "A `dip::Image::View` implicitly converts to a `dip::Image`.";
constexpr char const* dip·Image·Image·View·R = "A `dip::Image::View` implicitly converts to a `dip::Image`.";
constexpr char const* dip·Image·Image·DataSegment·CL·void·P·dip·DataType··UnsignedArray··IntegerArray··dip·Tensor·CL·dip·sint··dip·ExternalInterface·P = "Create an image around existing data.";
constexpr char const* dip·Image·Image·T·T·CP·UnsignedArray··dip·uint· = "Create an image around existing data. No ownership is transferred.";
constexpr char const* dip·Image·Similar·C = "Create a new forged image similar to `this`. The data is not copied.";
constexpr char const* dip·Image·Similar·dip·DataType··C = "Create a new forged image similar to `this`, but with different data type. The\ndata is not copied.";
constexpr char const* dip·Image·Dimensionality·C = "Get the number of spatial dimensions.";
constexpr char const* dip·Image·Sizes·C = "Get a const reference to the sizes array (image size).";
constexpr char const* dip·Image·Size·dip·uint··C = "Get the image size along a specific dimension, without test for\ndimensionality.";
constexpr char const* dip·Image·NumberOfPixels·C = "Get the number of pixels. Works also for a raw image, using current values of\nsizes.";
constexpr char const* dip·Image·NumberOfSamples·C = "Get the number of samples. Works also for a raw image, using current values of\nsizes and tensor elements.";
constexpr char const* dip·Image·SetSizes·UnsignedArray· = "Set the image sizes. The image must be raw.";
constexpr char const* dip·Image·Strides·C = "Get a const reference to the strides array.";
constexpr char const* dip·Image·Stride·dip·uint··C = "Get the stride along a specific dimension, without test for dimensionality.";
constexpr char const* dip·Image·TensorStride·C = "Get the tensor stride.";
constexpr char const* dip·Image·SetStrides·IntegerArray· = "Set the strides array. The image must be raw.";
constexpr char const* dip·Image·SetTensorStride·dip·sint· = "Set the tensor stride. The image must be raw.";
constexpr char const* dip·Image·ComputeStrides·UnsignedArray·CL·dip·uint· = "Computes Normal strides given the sizes array and the number of tensor\nelements. Note that the tensor stride is presumed to be 1. If tensor dimension\nis to be sorted at the end, set `tensorElements` to 1.";
constexpr char const* dip·Image·SetNormalStrides = "Set the strides array and tensor stride so strides are normal (see Normal\nstrides). The image must be raw, but its sizes should be set first.";
constexpr char const* dip·Image·MatchStrideOrder·Image·CL = "Set the strides array and tensor stride to match the dimension order of `src`.\nThe image must be raw, but its sizes should be set first.";
constexpr char const* dip·Image·HasContiguousData·C = "Test if all the pixels are contiguous.";
constexpr char const* dip·Image·HasNormalStrides·C = "Test if strides are as by default (see Normal strides). The image must be\nforged.";
constexpr char const* dip·Image·HasSingletonDimension·C = "Test if any of the image dimensions is a singleton dimension (size is 1).\nSingleton expanded dimensions are not considered. The image must be forged.";
constexpr char const* dip·Image·IsSingletonExpanded·C = "Test if the image has been singleton expanded.";
constexpr char const* dip·Image·HasSimpleStride·C = "Test if the whole image can be traversed with a single stride value.";
constexpr char const* dip·Image·GetSimpleStrideAndOrigin·C = "Return a single stride to walk through all pixels and pointer to the start of\nthe data.";
constexpr char const* dip·Image·HasSameDimensionOrder·Image·CL·C = "Checks to see if `other` and `this` have their dimensions ordered in the same\nway.";
constexpr char const* dip·Image·TensorSizes·C = "Get the tensor sizes. The array returned can have 0, 1 or 2 elements, as those\nare the allowed tensor dimensionalities.";
constexpr char const* dip·Image·TensorElements·C = "Get the number of tensor elements (i.e. the number of samples per pixel), the\nproduct of the elements in the array returned by TensorSizes.";
constexpr char const* dip·Image·TensorColumns·C = "Get the number of tensor columns.";
constexpr char const* dip·Image·TensorRows·C = "Get the number of tensor rows.";
constexpr char const* dip·Image·TensorShape·C = "Get the tensor shape.";
constexpr char const* dip·Image·Tensor·C = "Get the tensor shape.";
constexpr char const* dip·Image·IsScalar·C = "True for non-tensor (grey-value) images.";
constexpr char const* dip·Image·IsVector·C = "True for vector images, where the tensor is one-dimensional.";
constexpr char const* dip·Image·IsSquare·C = "True for square matrix images, independent from how they are stored.";
constexpr char const* dip·Image·SetTensorSizes·UnsignedArray·CL = "Set tensor sizes. The image must be raw.";
constexpr char const* dip·Image·SetTensorSizes·dip·uint· = "Set tensor sizes. The image must be raw.";
constexpr char const* dip·Image·DataType·C = "Get the image's data type.";
constexpr char const* dip·Image·SetDataType·dip·DataType· = "Set the image's data type. The image must be raw.";
constexpr char const* dip·Image·ColorSpace·C = "Get the image's color space name.";
constexpr char const* dip·Image·IsColor·C = "Returns true if the image is in color, false if the image is grey-valued.";
constexpr char const* dip·Image·SetColorSpace·String· = "Sets the image's color space name. This causes the image to be a color image,\nbut will cause errors to occur (eventually, not immediately) if the number of\ntensor elements does not match the expected number of channels for the given\ncolor space.";
constexpr char const* dip·Image·ResetColorSpace = "Resets the image's color space information, turning the image into a non-color\nimage.";
constexpr char const* dip·Image·PixelSize = "Get the pixels' size in physical units, by reference, allowing to modify it at\nwill.";
constexpr char const* dip·Image·PixelSize·C = "Get the pixels' size in physical units.";
constexpr char const* dip·Image·PixelSize·dip·uint··C = "Get the pixels' size along the given dimension in physical units.";
constexpr char const* dip·Image·SetPixelSize·dip·PixelSize· = "Set the pixels' size in physical units.";
constexpr char const* dip·Image·SetPixelSize·dip·uint··PhysicalQuantity· = "Set the pixels' size along the given dimension in physical units.";
constexpr char const* dip·Image·ResetPixelSize = "Reset the pixels' size, so that `HasPixelSize` returns false.";
constexpr char const* dip·Image·HasPixelSize·C = "Returns true if the pixel has physical dimensions.";
constexpr char const* dip·Image·IsIsotropic·C = "Returns true if the pixel has the same size in all dimensions.";
constexpr char const* dip·Image·AspectRatio·C = "Returns an array with aspect ratios: [1, y/x, z/x, ...]. If dimensions don't\nmatch, returns 0 for that dimension.";
constexpr char const* dip·Image·PixelsToPhysical·FloatArray·CL·C = "Converts a size in pixels to a size in physical units.";
constexpr char const* dip·Image·PhysicalToPixels·PhysicalQuantityArray·CL·C = "Converts a size in physical units to a size in pixels.";
constexpr char const* dip·Image·CompareProperties·Image·CL·Option·CmpPropFlags··Option·ThrowException··C = "Compare properties of an image against a template, either returns true/false\nor throws an error.";
constexpr char const* dip·Image·CheckProperties·dip·uint··dip·DataType·Classes··Option·ThrowException··C = "Check image properties, either returns true/false or throws an error.";
constexpr char const* dip·Image·CheckProperties·dip·uint··dip·uint··dip·DataType·Classes··Option·ThrowException··C = "Check image properties, either returns true/false or throws an error.";
constexpr char const* dip·Image·CheckProperties·UnsignedArray·CL·dip·DataType·Classes··Option·ThrowException··C = "Check image properties, either returns true/false or throws an error.";
constexpr char const* dip·Image·CheckProperties·UnsignedArray·CL·dip·uint··dip·DataType·Classes··Option·ThrowException··C = "Check image properties, either returns true/false or throws an error.";
constexpr char const* dip·Image·CheckIsMask·UnsignedArray·CL·Option·AllowSingletonExpansion··Option·ThrowException··C = "Check image properties for a mask image, either returns true/false or throws\nan error.";
constexpr char const* dip·Image·CopyProperties·Image·CL = "Copy all image properties from `src`, including strides. The image must be\nraw.";
constexpr char const* dip·Image·CopyNonDataProperties·Image·CL = "Copy non-data image properties from `src`.";
constexpr char const* dip·Image·ResetNonDataProperties = "Reset non-data image properties.";
constexpr char const* dip·Image·swap·Image·L = "Swaps `this` and `other`.";
constexpr char const* dip·Image·Data·C = "Get pointer to the data segment.";
constexpr char const* dip·Image·IsShared·C = "Check to see if the data segment is shared with other images.";
constexpr char const* dip·Image·ShareCount·C = "Get the number of images that share their data with this image.";
constexpr char const* dip·Image·SharesData·Image·CL·C = "Determine if `this` shares its data pointer with `other`.";
constexpr char const* dip·Image·IsExternalData·C = "Returns true if the data segment was not allocated by *DIPlib*. See\nControlling data segment allocation.";
constexpr char const* dip·Image·Aliases·Image·CL·C = "Determine if `this` shares any samples with `other`.";
constexpr char const* dip·Image·IsIdenticalView·Image·CL·C = "Determine if `this` and `other` offer an identical view of the same set of\npixels.";
constexpr char const* dip·Image·IsOverlappingView·Image·CL·C = "Determine if `this` and `other` offer different views of the same data\nsegment, and share at least one sample.";
constexpr char const* dip·Image·IsOverlappingView·ImageConstRefArray·CL·C = "Determine if `this` and any of those in `other` offer different views of the\nsame data segment, and share at least one sample.";
constexpr char const* dip·Image·IsOverlappingView·ImageArray·CL·C = "Determine if `this` and any of those in `other` offer different views of the";
constexpr char const* dip·Image·Forge = "Allocate data segment.";
constexpr char const* dip·Image·ReForge·Image·CL·Option·AcceptDataTypeChange· = "Modify image properties and forge the image.";
constexpr char const* dip·Image·ReForge·Image·CL·dip·DataType··Option·AcceptDataTypeChange· = "Modify image properties and forge the image.";
constexpr char const* dip·Image·ReForge·UnsignedArray·CL·dip·uint··dip·DataType··Option·AcceptDataTypeChange· = "Modify image properties and forge the image.";
constexpr char const* dip·Image·Strip = "Disassociate the data segment from the image. If there are no other images\nusing the same data segment, it will be freed. Throws if the image is\nprotected and has a data segment.";
constexpr char const* dip·Image·IsForged·C = "Test if forged.";
constexpr char const* dip·Image·Protect·bool· = "Set protection flag.";
constexpr char const* dip·Image·Unprotect = "Reset protection flag. Alias for `Protect(false)`.";
constexpr char const* dip·Image·IsProtected·C = "Test if protected. See `dip::Image::Protect` for information.";
constexpr char const* dip·Image·SetExternalInterface·dip·ExternalInterface·P = "Set external interface pointer. The image must be raw. See Define an image's\nallocator.";
constexpr char const* dip·Image·ResetExternalInterface = "Remove external interface pointer. The image behaves like a native one (for\nassignment, reforging, etc.), but the current pixel buffer (if forged) is not\naffected. See Define an image's allocator.";
constexpr char const* dip·Image·ExternalInterface·C = "Get external interface pointer. See Define an image's allocator";
constexpr char const* dip·Image·HasExternalInterface·C = "Test if an external interface is set. See Define an image's allocator";
constexpr char const* dip·Image·Origin·C = "Get pointer to the first sample in the image, the first tensor element at\ncoordinates (0,0,0,...). The image must be forged.";
constexpr char const* dip·Image·Pointer·dip·sint··C = "Get a pointer to the pixel given by the offset.";
constexpr char const* dip·Image·Pointer·UnsignedArray·CL·C = "Get a pointer to the pixel given by the coordinates index.";
constexpr char const* dip·Image·Pointer·IntegerArray·CL·C = "Get a pointer to the pixel given by the coordinates index.";
constexpr char const* dip·Image·IsOnEdge·UnsignedArray·CL·C = "Return true if the coordinates are on the image edge.";
constexpr char const* dip·Image·IsInside·T·DimensionArraygtCoordTypelt·CL·C = "Returns whether the coordinates are inside the image";
constexpr char const* dip·Image·Offset·UnsignedArray·CL·IntegerArray·CL·UnsignedArray·CL = "Compute offset given coordinates and strides.";
constexpr char const* dip·Image·Offset·IntegerArray·CL·IntegerArray·CL = "Compute offset given coordinates.";
constexpr char const* dip·Image·Offset·UnsignedArray·CL·C = "Compute offset given coordinates.";
constexpr char const* dip·Image·Offset·IntegerArray·CL·C = "Compute offset given coordinates.";
constexpr char const* dip·Image·OffsetToCoordinates·dip·sint··C = "Compute coordinates given an offset.";
constexpr char const* dip·Image·OffsetToCoordinatesComputer·C = "Returns a functor that computes coordinates given an offset.";
constexpr char const* dip·Image·Index·UnsignedArray·CL·UnsignedArray·CL = "Compute linear index (not offset) given coordinates and image sizes.";
constexpr char const* dip·Image·Index·UnsignedArray·CL·C = "Compute linear index (not offset) given coordinates.";
constexpr char const* dip·Image·IndexToCoordinates·dip·uint··C = "Compute coordinates given a linear index.";
constexpr char const* dip·Image·IndexToCoordinatesComputer·C = "Returns a functor that computes coordinates given a linear index.";
constexpr char const* dip·Image·GetCenter·String·CL·C = "Returns the coordinates for the center of the image.";
constexpr char const* dip·Image·PermuteDimensions·UnsignedArray·CL = "Permute dimensions.";
constexpr char const* dip·Image·SwapDimensions·dip·uint··dip·uint· = "Swap dimensions d1 and d2. This is a simplified version of\n`PermuteDimensions`.";
constexpr char const* dip·Image·ReverseDimensions = "Reverses the dimensions, such that indexing switches from (x,y,z) to (z,y,x).";
constexpr char const* dip·Image·Flatten = "Make image 1D.";
constexpr char const* dip·Image·FlattenAsMuchAsPossible = "Make image have as few dimensions as possible.";
constexpr char const* dip·Image·SplitDimension·dip·uint··dip·uint· = "Splits a dimension into two.";
constexpr char const* dip·Image·Squeeze·UnsignedArray·L = "Remove singleton dimensions (dimensions with size==1).";
constexpr char const* dip·Image·Squeeze = "Remove singleton dimensions (dimensions with size==1).";
constexpr char const* dip·Image·Squeeze·dip·uint· = "Remove singleton dimension `dim` (has size==1).";
constexpr char const* dip·Image·AddSingleton·dip·uint· = "Add a singleton dimension (with size==1) to the image.";
constexpr char const* dip·Image·AddSingleton·UnsignedArray·CL = "Add a singleton dimensions (with size==1) to the image.";
constexpr char const* dip·Image·ExpandDimensionality·dip·uint· = "Append singleton dimensions to increase the image dimensionality.";
constexpr char const* dip·Image·ExpandSingletonDimension·dip·uint··dip·uint· = "Expand singleton dimension `dim` to `sz` pixels, setting the corresponding\nstride to 0.";
constexpr char const* dip·Image·ExpandSingletonDimensions·UnsignedArray·CL = "Performs singleton expansion.";
constexpr char const* dip·Image·UnexpandSingletonDimensions = "Unexpands singleton-expanded dimensions.";
constexpr char const* dip·Image·UnexpandSingletonDimension·dip·uint· = "Unexpands a singleton-expanded dimension.";
constexpr char const* dip·Image·IsSingletonExpansionPossible·UnsignedArray·CL·C = "Tests if the image can be singleton-expanded to `size`.";
constexpr char const* dip·Image·ExpandSingletonTensor·dip·uint· = "Expand singleton tensor dimension `sz` samples, setting the tensor stride to\n0.";
constexpr char const* dip·Image·UnexpandSingletonTensor = "Unexpands the singleton-expanded tensor dimension.";
constexpr char const* dip·Image·Mirror·dip·uint· = "Mirror the image about a single axes.";
constexpr char const* dip·Image·Mirror·BooleanArray· = "Mirror the image about selected axes.";
constexpr char const* dip·Image·Rotation90·dip·sint··dip·uint··dip·uint· = "Rotates the image by `n` times 90 degrees, in the plane defined by dimensions\n`dimension1` and `dimension2`.";
constexpr char const* dip·Image·Rotation90·dip·sint··dip·uint· = "Rotates the 3D image by `n` times 90 degrees, in the plane perpendicular to\ndimension `axis`.";
constexpr char const* dip·Image·Rotation90·dip·sint· = "Rotates the image by `n` times 90 degrees, in the x-y plane.";
constexpr char const* dip·Image·StandardizeStrides = "Undo the effects of `Mirror`, `Rotation90`, `PermuteDimensions`, and singleton\nexpansion. Also removes singleton dimensions.";
constexpr char const* dip·Image·StandardizeStrides·IntegerArray·L·UnsignedArray·L = "Transforms input arrays and outputs ordering required to standardize an\nimage's strides.";
constexpr char const* dip·Image·ReshapeTensor·dip·uint··dip·uint· = "Change the tensor shape, without changing the number of tensor elements.";
constexpr char const* dip·Image·ReshapeTensor·dip·Tensor·CL = "Change the tensor shape, without changing the number of tensor elements.";
constexpr char const* dip·Image·ReshapeTensorAsVector = "Change the tensor to a vector, without changing the number of tensor elements.";
constexpr char const* dip·Image·ReshapeTensorAsDiagonal = "Change the tensor to a diagonal matrix, without changing the number of tensor\nelements.";
constexpr char const* dip·Image·Transpose = "Transpose the tensor.";
constexpr char const* dip·Image·TensorToSpatial·dip·uint· = "Convert tensor dimensions to spatial dimension.";
constexpr char const* dip·Image·SpatialToTensor·dip·uint··dip·uint··dip·uint· = "Convert spatial dimension to tensor dimensions. The image must be scalar.";
constexpr char const* dip·Image·SplitComplex·dip·uint· = "Split the two values in a complex sample into separate samples, creating a new\nspatial dimension of size 2.";
constexpr char const* dip·Image·MergeComplex·dip·uint· = "Merge the two samples along dimension `dim` into a single complex-valued\nsample.";
constexpr char const* dip·Image·SplitComplexToTensor = "Split the two values in a complex sample into separate samples of a tensor.\nThe image must be scalar and forged.";
constexpr char const* dip·Image·MergeTensorToComplex = "Merge the two samples in the tensor into a single complex-valued sample.";
constexpr char const* dip·Image·ReinterpretCast·dip·DataType· = "Changes the data type of `this` without copying or changing the data.";
constexpr char const* dip·Image·ReinterpretCastToSignedInteger = "Changes the data type of `this` to a signed integer of the same size, without\ncopying or changing the data.";
constexpr char const* dip·Image·ReinterpretCastToUnsignedInteger = "Changes the data type of `this` to an unsigned integer of the same size,\nwithout copying or changing the data.";
constexpr char const* dip·Image·ReinterpretCastBinToUint8 = "Changes the data type of the binary image to `dip::uint8` without copying or\nchanging the data.";
constexpr char const* dip·Image·ReinterpretCastUint8ToBin = "Changes the data type of the uint8 image to `dip::bin` without copying or\nchanging the data.";
constexpr char const* dip·Image·Crop·UnsignedArray·CL·Option·CropLocation· = "Reduces the size of the image by cropping off the borders.";
constexpr char const* dip·Image·Crop·UnsignedArray·CL·String·CL = "Reduces the size of the image by cropping off the borders.";
constexpr char const* dip·Image·CropWindow·UnsignedArray·CL·Option·CropLocation··C = "Returns the `dip::RangeArray` indexing data that corresponds to the result of\n`dip::Image::Crop`.";
constexpr char const* dip·Image·CropWindow·UnsignedArray·CL·String·CL·C = "Returns the `dip::RangeArray` indexing data that corresponds to the result of\n`dip::Image::Crop`.";
constexpr char const* dip·Image·CropWindow·UnsignedArray·CL·UnsignedArray·CL·Option·CropLocation· = "Returns the `dip::RangeArray` indexing data that corresponds to the result of\n`dip::Image::Crop`, for an image of size `imageSizes`.";
constexpr char const* dip·Image·CropWindow·UnsignedArray·CL·UnsignedArray·CL·String·CL = "Returns the `dip::RangeArray` indexing data that corresponds to the result of\n`dip::Image::Crop`, for an image of size `imageSizes`.";
constexpr char const* dip·Image·operatorsqbra·UnsignedArray·CL·C = "Extract a tensor element, `indices` must have one or two elements. The image\nmust be forged.";
constexpr char const* dip·Image·operatorsqbra·T·T··C = "Extract a tensor element using linear indexing. Negative indices start at the\nend. The image must be forged.";
constexpr char const* dip·Image·operatorsqbra·Range··C = "Extract tensor elements using linear indexing. The image must be forged.";
constexpr char const* dip·Image·Diagonal·C = "Extracts the tensor elements along the diagonal. The image must be forged.";
constexpr char const* dip·Image·TensorRow·dip·uint··C = "Extracts the tensor elements along the given row. The image must be forged and\nthe tensor representation must be full (i.e. no symmetric or triangular\nmatrices). Use `dip::Image::ExpandTensor` to obtain a full representation.";
constexpr char const* dip·Image·TensorColumn·dip·uint··C = "Extracts the tensor elements along the given column. The image must be forged\nand the tensor representation must be full (i.e. no symmetric or triangular\nmatrices). Use `dip::Image::ExpandTensor` to obtain a full representation.";
constexpr char const* dip·Image·At·UnsignedArray·CL·C = "Extracts the pixel at the given coordinates. The image must be forged.";
constexpr char const* dip·Image·At·T·UnsignedArray·CL·C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·At·dip·uint··C = "Extracts the pixel at the given linear index (inefficient if image is not\n1D!). The image must be forged.";
constexpr char const* dip·Image·At·T·dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·At·dip·uint··dip·uint··C = "Extracts the pixel at the given coordinates from a 2D image. The image must be\nforged.";
constexpr char const* dip·Image·At·T·dip·uint··dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·At·dip·uint··dip·uint··dip·uint··C = "Extracts the pixel at the given coordinates from a 3D image. The image must be\nforged.";
constexpr char const* dip·Image·At·T·dip·uint··dip·uint··dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·begin = "Returns an iterator to the first pixel in the image. Include\ndiplib/generic_iterators.h to use this.";
constexpr char const* dip·Image·end = "Returns an iterator to the end of the iterator range. It cannot be\ndereferenced or manipulated, and is meant solely as an end-of-iteration\nmarker.";
constexpr char const* dip·Image·At·Range·CL·C = "Extracts a subset of pixels from a 1D image. The image must be forged.";
constexpr char const* dip·Image·At·Range·CL·Range·CL·C = "Extracts a subset of pixels from a 2D image. The image must be forged.";
constexpr char const* dip·Image·At·Range·CL·Range·CL·Range·CL·C = "Extracts a subset of pixels from a 3D image. The image must be forged.";
constexpr char const* dip·Image·At·RangeArray··C = "Extracts a subset of pixels from an image. The image must be forged.";
constexpr char const* dip·Image·At·Image··C = "Creates a 1D image view containing the pixels selected by `mask`.";
constexpr char const* dip·Image·At·CoordinateArray·CL·C = "Creates a 1D image view containing the pixels selected by `coordinates`.";
constexpr char const* dip·Image·AtIndices·UnsignedArray·CL·C = "Creates a 1D image view containing the pixels selected by `indices`.";
constexpr char const* dip·Image·Cropped·UnsignedArray·CL·Option·CropLocation··C = "Extracts a subset of pixels from an image.";
constexpr char const* dip·Image·Cropped·UnsignedArray·CL·String·CL·C = "Extracts a subset of pixels from an image.";
constexpr char const* dip·Image·Real·C = "Extracts the real component of a complex-typed image. The image must be\nforged.";
constexpr char const* dip·Image·Imaginary·C = "Extracts the imaginary component of a complex-typed image. The image must be\nforged and complex-valued.";
constexpr char const* dip·Image·AsScalar·dip·uint··C = "Creates a scalar view of the image, where the tensor dimension is converted to\na new spatial dimension. See `dip::Image::TensorToSpatial`.";
constexpr char const* dip·Image·AsScalar·C = "overload";
constexpr char const* dip·Image·QuickCopy·C = "Quick copy, returns a new image that points at the same data as `this`, and\nhas mostly the same properties.";
constexpr char const* dip·Image·Pad·UnsignedArray·CL·Pixel·CL·Option·CropLocation··C = "Extends the image by padding with `value`.";
constexpr char const* dip·Image·Pad·UnsignedArray·CL·Option·CropLocation··C = "Extends the image by padding with zeros, overload for function above with\n`value` equal to 0.";
constexpr char const* dip·Image·Pad·UnsignedArray·CL·Pixel·CL·String·CL·C = "Extends the image by padding with `value`.";
constexpr char const* dip·Image·Pad·UnsignedArray·CL·String·CL·C = "Extends the image by padding with zeros, overload for function above with\n`value` equal to 0.";
constexpr char const* dip·Image·Copy·Image·CL = "Deep copy, `this` will become a copy of `src` with its own data.";
constexpr char const* dip·Image·Copy·Image·View·CL = "Idem as above, but with a `dip::Image::View` as input.";
constexpr char const* dip·Image·Copy·C = "Deep copy, returns a copy of `this` with its own data.";
constexpr char const* dip·Image·Convert·dip·DataType· = "Converts the image to another data type.";
constexpr char const* dip·Image·SwapBytesInSample = "Swaps bytes in each sample, converting from little endian to big endian or\nvice versa.";
constexpr char const* dip·Image·ExpandTensor = "Expands the image's tensor, such that the tensor representation is a column-\nmajor matrix.";
constexpr char const* dip·Image·ForceNormalStrides = "Copies pixel data over to a new data segment if the strides are not normal.";
constexpr char const* dip·Image·ForceContiguousData = "Copies pixel data over to a new data segment if the data is not contiguous.";
constexpr char const* dip·Image·Separate = "If the image shares its data segment with another image, create a data copy so\nit no longer shares data.";
constexpr char const* dip·Image·Fill·Pixel·CL = "Sets all pixels in the image to the value `pixel`.";
constexpr char const* dip·Image·Fill·Sample·CL = "Sets all samples in the image to the value `sample`.";
constexpr char const* dip·Image·operatoreq·Pixel·CL = "Sets all pixels in the image to the value `pixel`.";
constexpr char const* dip·Image·operatoreq·Sample·CL = "Sets all samples in the image to the value `sample`.";
constexpr char const* dip·Image·As·T·C = "Returns the value of the first sample in the first pixel in the image as the\ngiven numeric type.";
constexpr char const* dip·Image·operator_FloatArray·C = "Returns a FloatArray containing the sample values of the first pixel in the\nimage. For a complex-valued image, the modulus (absolute value) is returned.";
constexpr char const* dip·Image·Mask·dip·Image·CL = "Sets all pixels not in `mask` to zero. `img.Mask(mask)` is equivalent to\n`img.At(~mask).Fill(0)`, but without creating an intermediate copy of `mask`.\nCan also be expressed as `img *= mask`.";
constexpr char const* dip·Image·CopyDataToNewDataSegment = "Allocates a new data segment and copies the data over. The image will be the\nsame as before, but have Normal strides and not share data with another image.";
constexpr char const* dip·Image·Sample = "A sample represents a single numeric value in an image, see Image\nrepresentation.";
constexpr char const* dip·Image·Sample·Sample·dip·DataType· = "Construct a new `Sample` by giving the data type. Initialized to 0.";
constexpr char const* dip·Image·Sample·Sample·T·T· = "A numeric value implicitly converts to a `Sample`.";
constexpr char const* dip·Image·Sample·Sample·Pixel·CL = "A `dip::Image::Pixel`, when cast to a `Sample`, references the first value in\nthe pixel.";
constexpr char const* dip·Image·Sample·Sample·Image·CL = "A `dip::Image`, when cast to a `Sample`, references the first sample in the\nfirst pixel in the image.";
constexpr char const* dip·Image·Sample·swap·Sample·L = "Swaps `*this` and `other`.";
constexpr char const* dip·Image·Sample·Maximum·dip·DataType· = "Creates a sample with the largest finite value for the given data type. Not\nimplemented for complex types.";
constexpr char const* dip·Image·Sample·Minimum·dip·DataType· = "Creates a sample with the lowest finite value for the given data type. Not\nimplemented for complex types.";
constexpr char const* dip·Image·Sample·As·T·C = "Returns the value of the sample as the given numeric type, similar to using\n`static_cast`.";
constexpr char const* dip·Image·Sample·operator_bool·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operator_dipcoloncolonuint·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operator_dipcoloncolonsint·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operator_sfloat·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operator_dfloat·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operator_scomplex·C = "A `Sample` can be cast to basic numerical types.";
constexpr char const* dip·Image·Sample·operatoreq·Sample·CL = "Assigning to a `Sample` copies the value over to the sample referenced.";
constexpr char const* dip·Image·Sample·operatoreq·T·T· = "It is also possible to assign a constant directly.";
constexpr char const* dip·Image·Sample·Origin·C = "Returns a pointer to the sample referenced.";
constexpr char const* dip·Image·Sample·DataType·C = "The data type of the sample referenced.";
constexpr char const* dip·Image·Sample·operatorpluseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Sample·operatorminuseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Sample·operatortimeseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Sample·operatordiveq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Sample·operatormodeq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Sample·operatorandeq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·Sample·operatororeq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·Sample·operatorxoreq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·Pixel = "A pixel represents a set of numeric value in an image, see Image\nrepresentation.";
constexpr char const* dip·Image·Pixel·Pixel·dip·DataType··dip·uint· = "Construct a new `Pixel` by giving data type and number of tensor elements.\nInitialized to 0.";
constexpr char const* dip·Image·Pixel·Pixel·Sample·CL = "A `Pixel` can be constructed from a single sample, yielding a scalar pixel\nwith the same data type as the sample.";
constexpr char const* dip·Image·Pixel·Pixel·FloatArray·CL·dip·DataType· = "A `Pixel` can be constructed from a `dip::FloatArray`. The pixel will be a\ncolumn vector.";
constexpr char const* dip·Image·Pixel·Pixel·T·std·initializer_listgtTlt· = "A `Pixel` can be constructed from an initializer list, yielding a pixel with\nthe same data type and number of tensor elements as the initializer list. The\npixel will be a column vector.";
constexpr char const* dip·Image·Pixel·Pixel·Image·CL = "A `dip::Image`, when cast to a `Pixel`, references the first pixel in the\nimage.";
constexpr char const* dip·Image·Pixel·swap·Pixel·L = "Swaps `*this` and `other`.";
constexpr char const* dip·Image·Pixel·As·T·C = "Returns the value of the first sample in the pixel as the given numeric type,\nsimilar to using `static_cast`.";
constexpr char const* dip·Image·Pixel·operator_bool·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_dipcoloncolonuint·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_dipcoloncolonsint·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_sfloat·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_dfloat·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_scomplex·C = "A `Pixel` can be cast to basic numerical types. The first sample in the pixel\nis used.";
constexpr char const* dip·Image·Pixel·operator_DimensionArray·C = "Returns a FloatArray containing the sample values of the pixel. For a complex-\nvalued pixel, the modulus (absolute value) is returned.";
constexpr char const* dip·Image·Pixel·operatoreq·Sample·CL = "Assigning a number or sample to a `Pixel` copies the value over each of the\nsamples in the pixel.";
constexpr char const* dip·Image·Pixel·operatoreq·Pixel·CL = "Assigning to a `Pixel` copies the values over to the pixel referenced.";
constexpr char const* dip·Image·Pixel·operatoreq·T·std·initializer_listgtTlt· = "It is also possible to assign from an initializer list.";
constexpr char const* dip·Image·Pixel·Origin·C = "Returns a pointer to the first sample referenced.";
constexpr char const* dip·Image·Pixel·DataType·C = "The data type of the pixel referenced.";
constexpr char const* dip·Image·Pixel·Tensor·C = "The tensor shape for the pixel referenced.";
constexpr char const* dip·Image·Pixel·TensorElements·C = "The number of samples in the pixel referenced.";
constexpr char const* dip·Image·Pixel·IsScalar·C = "Is it a scalar pixel?";
constexpr char const* dip·Image·Pixel·TensorStride·C = "The stride to use to access the various samples in the pixel referenced.";
constexpr char const* dip·Image·Pixel·ReshapeTensor·dip·uint··dip·uint· = "Change the tensor shape, without changing the number of tensor elements.";
constexpr char const* dip·Image·Pixel·ReshapeTensor·dip·Tensor·CL = "Change the tensor shape, without changing the number of tensor elements.";
constexpr char const* dip·Image·Pixel·ReshapeTensorAsVector = "Change the tensor to a vector, without changing the number of tensor elements.";
constexpr char const* dip·Image·Pixel·ReshapeTensorAsDiagonal = "Change the tensor to a diagonal matrix, without changing the number of tensor\nelements.";
constexpr char const* dip·Image·Pixel·operatorsqbra·dip·uint··C = "Indexing into a `Pixel` retrieves a reference to the specific sample.";
constexpr char const* dip·Image·Pixel·operatorsqbra·UnsignedArray·CL·C = "Indexing into a `Pixel` retrieves a reference to the specific sample,\n`indices` must have one or two elements.";
constexpr char const* dip·Image·Pixel·Diagonal·C = "Extracts the tensor elements along the diagonal.";
constexpr char const* dip·Image·Pixel·TensorRow·dip·uint··C = "Extracts the tensor elements along the given row. The tensor representation\nmust be full (i.e. no symmetric or triangular matrices).";
constexpr char const* dip·Image·Pixel·TensorColumn·dip·uint··C = "Extracts the tensor elements along the given column. The tensor representation\nmust be full (i.e. no symmetric or triangular matrices).";
constexpr char const* dip·Image·Pixel·Real·C = "Extracts the real component of the pixel values, returns an identical copy if\nthe data type is not complex.";
constexpr char const* dip·Image·Pixel·Imaginary·C = "Extracts the imaginary component of the pixel values, throws an exception if\nthe data type is not complex.";
constexpr char const* dip·Image·Pixel·Iterator = "An iterator to iterate over the samples in the pixel. Mutable forward\niterator.";
constexpr char const* dip·Image·Pixel·Iterator·iterator_category = "Iterator category";
constexpr char const* dip·Image·Pixel·Iterator·value_type = "The data type of a sample, obtained when dereferencing the iterator";
constexpr char const* dip·Image·Pixel·Iterator·reference = "The type of a reference to a sample";
constexpr char const* dip·Image·Pixel·Iterator·pointer = "The type of a pointer to a sample";
constexpr char const* dip·Image·Pixel·Iterator·Iterator = "Default initializable, results in invalid iterator";
constexpr char const* dip·Image·Pixel·Iterator·swap·Iterator·L = "Swap two iterators";
constexpr char const* dip·Image·Pixel·Iterator·operatortimes = "Dereference";
constexpr char const* dip·Image·Pixel·Iterator·operatorminusgt = "Dereference";
constexpr char const* dip·Image·Pixel·Iterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·Image·Pixel·Iterator·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·Image·Pixel·Iterator·operatoreqeq·Iterator·CL·C = "Equality comparison";
constexpr char const* dip·Image·Pixel·Iterator·operatornoteq·Iterator·CL·C = "Inequality comparison";
constexpr char const* dip·Image·Pixel·begin·C = "Returns an iterator to the first sample in the pixel.";
constexpr char const* dip·Image·Pixel·end·C = "Returns an iterator to one past the last sample in the pixel.";
constexpr char const* dip·Image·Pixel·All·C = "True if all tensor elements are non-zero.";
constexpr char const* dip·Image·Pixel·Any·C = "True if one tensor element is non-zero.";
constexpr char const* dip·Image·Pixel·operatorpluseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatorminuseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatortimeseq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatordiveq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatormodeq·T·T·CL = "Compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatorandeq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatororeq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·Pixel·operatorxoreq·T·T·CL = "Bit-wise compound assignment operator.";
constexpr char const* dip·Image·CastSample·T = "Derived from `dip::Image::Sample`, works identically except it implicitly\nconverts to type `T`. relates dip::Image::Sample";
constexpr char const* dip·Image·CastPixel·T = "Derived from `dip::Image::Pixel`, works identically except it implicitly\nconverts to type `T`. relates dip::Image::Pixel";
constexpr char const* dip·Image·View = "A view represents a subset of samples in an image. It can be assigned to to\nchange those samples.";
constexpr char const* dip·Image·View·operatoreq·View·R = "Move assignment doesn't move, this behaves in the same way as the copy\nassignment.";
constexpr char const* dip·Image·View·operatoreq·View·CL = "Assigning an image `source` to a view causes the pixels from `source` to be\ncopied to the view. See `dip::Image::View::Copy`.";
constexpr char const* dip·Image·View·operatoreq·Image·CL = "Assigning an image `source` to a view causes the pixels from `source` to be\ncopied to the view. See `dip::Image::View::Copy`.";
constexpr char const* dip·Image·View·operatoreq·Pixel·CL = "Assigning a pixel to a view causes all pixels in the view to be set to the\nsame value. See `dip::Image::View::Fill`.";
constexpr char const* dip·Image·View·operatoreq·Sample·CL = "Assigning a sample to a view causes all samples in the view to be set to the\nsame value. See `dip::Image::View::Fill`.";
constexpr char const* dip·Image·View·Copy·View·CL = "Copy the pixels from `source` to the view.";
constexpr char const* dip·Image·View·Copy·Image·CL = "Copy the pixels from `source` to the view.";
constexpr char const* dip·Image·View·Copy·C = "Creates a copy of the view as a new image. The output will not share data with\nthe view.";
constexpr char const* dip·Image·View·Fill·Pixel·CL = "Sets all pixels in the view to the value `pixel`.";
constexpr char const* dip·Image·View·Fill·Sample·CL = "Sets all samples in the view to the value `sample`.";
constexpr char const* dip·Image·View·operatorsqbra·UnsignedArray·CL·C = "Extract a tensor element, `indices` must have one or two elements.";
constexpr char const* dip·Image·View·operatorsqbra·dip·uint··C = "Extract a tensor element using linear indexing.";
constexpr char const* dip·Image·View·operatorsqbra·Range··C = "Extract tensor elements using linear indexing.";
constexpr char const* dip·Image·View·At·UnsignedArray·CL·C = "Extracts the pixel at the given coordinates.";
constexpr char const* dip·Image·View·At·T·UnsignedArray·CL·C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·View·At·dip·uint··C = "Extracts the pixel at the given linear index (inefficient if view is not 1D!).";
constexpr char const* dip·Image·View·At·T·dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·View·At·dip·uint··dip·uint··C = "Extracts the pixel at the given coordinates from a 2D view.";
constexpr char const* dip·Image·View·At·T·dip·uint··dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·View·At·dip·uint··dip·uint··dip·uint··C = "Extracts the pixel at the given coordinates from a 3D view.";
constexpr char const* dip·Image·View·At·T·dip·uint··dip·uint··dip·uint··C = "Same as above, but returns a type that implicitly casts to `T`.";
constexpr char const* dip·Image·View·At·Range··C = "Extracts a subset of pixels from a 1D view.";
constexpr char const* dip·Image·View·At·Range··Range··C = "Extracts a subset of pixels from a 2D view.";
constexpr char const* dip·Image·View·At·Range··Range··Range··C = "Extracts a subset of pixels from a 3D view.";
constexpr char const* dip·Image·View·At·RangeArray··C = "Extracts a subset of pixels from a view.";
constexpr char const* dip·Image·View·Dimensionality·C = "Returns the dimensionality of the view. Non-regular views (created by indexing\nusing a mask image or a coordinate array) are always 1D.";
constexpr char const* dip·Image·View·TensorElements·C = "Returns the number of tensor elements of the view.";
constexpr char const* dip·Image·View·begin·C = "Returns an iterator to the first pixel in the view.";
constexpr char const* dip·Image·View·end·C = "Returns an iterator to one past the last pixel in the view.";
constexpr char const* dip·Image·View·IsRegular·C = "Returns true if the view was obtained by regular indexing. If `true`, `Mask`\nand `Offset` will be empty.";
constexpr char const* dip·Image·View·Reference·C = "Returns the image being referenced.";
constexpr char const* dip·Image·View·Mask·C = "Returns the view's mask image. Will only be forged if the view was created\nwith a mask image.";
constexpr char const* dip·Image·View·Offsets·C = "Returns the view's offsets into the referenced image. Will be empty if the\nview was not created using offsets.";
constexpr char const* dip·Image·View·Iterator = "View iterator, similar in functionality to `dip::GenericImageIterator`.";
constexpr char const* dip·Image·View·Iterator·iterator_category = "Iterator category";
constexpr char const* dip·Image·View·Iterator·value_type = "The data type obtained when dereferencing the iterator";
constexpr char const* dip·Image·View·Iterator·reference = "The type of a reference to a pixel";
constexpr char const* dip·Image·View·Iterator·pointer = "The type of a pointer to a pixel";
constexpr char const* dip·Image·View·Iterator·Iterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·Image·View·Iterator·Iterator·View·CL = "To construct a useful iterator, provide a view";
constexpr char const* dip·Image·View·Iterator·Iterator·View·R = "To construct a useful iterator, provide a view";
constexpr char const* dip·Image·View·Iterator·operatortimes·C = "Dereference";
constexpr char const* dip·Image·View·Iterator·operatorminusgt·C = "Dereference";
constexpr char const* dip·Image·View·Iterator·operatorsqbra·dip·uint··C = "Index into tensor, `it[index]` is equal to `(*it)[index]`.";
constexpr char const* dip·Image·View·Iterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·Image·View·Iterator·begin·C = "Get an iterator over the tensor for the current pixel, `it.begin()` is equal\nto `(*it).begin()`.";
constexpr char const* dip·Image·View·Iterator·end·C = "Get an end iterator over the tensor for the current pixel";
constexpr char const* dip·Image·View·Iterator·operatoreqeq·Iterator·CL·C = "Equality comparison, is equal if the two iterators have the same position.";
constexpr char const* dip·Image·View·Iterator·operatornoteq·Iterator·CL·C = "Inequality comparison";
constexpr char const* dip·Image·View·Iterator·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·Image·View·Iterator·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·Image·View·Iterator·Pointer·C = "Return the current pointer";
constexpr char const* dip·Image·View·Iterator·Pointer·dip·uint··C = "Return a pointer to the tensor element `index`";
constexpr char const* dip·Image·View·Iterator·Offset·C = "Return the current offset";
constexpr char const* dip·Image·View·Iterator·Position·C = "Return the current position within the view (i.e. how many times we've\nadvanced the iterator)";
constexpr char const* dip·Image·View·Iterator·Reset = "Reset the iterator to the first pixel in the image (as it was when first\ncreated)";
constexpr char const* dip·operatorltlt·std·ostream·L·Image·CL = "You can output a `dip::Image` to `std::cout` or any other stream. Some\ninformation about the image is printed.";
constexpr char const* dip·Alias·Image·CL·Image·CL = "Calls `img1.Aliases( img2 )`. See `dip::Image::Aliases`.";
constexpr char const* dip·DefineROI·Image·CL·Image·L·UnsignedArray··UnsignedArray··UnsignedArray· = "Makes a new image object pointing to same pixel data as `src`, but with\ndifferent origin, strides and size.";
constexpr char const* dip·Copy·Image·CL·Image·L = "Copies samples over from `src` to `dest`, identical to the `dip::Image::Copy`\nmethod.";
constexpr char const* dip·Copy·Image·View·CL·Image·L = "Copies samples over from `src` to `dest`, identical to the `dip::Image::Copy`\nmethod.";
constexpr char const* dip·Copy·Image·CL·Image·View·L = "Copies samples over from `src` to `dest`, identical to the\n`dip::Image::View::Copy` method.";
constexpr char const* dip·Copy·Image·View·CL·Image·View·L = "Copies samples over from `src` to `dest`, identical to the\n`dip::Image::View::Copy` method.";
constexpr char const* dip·CopyFrom·Image·CL·Image·L·Image·CL = "Copies the pixels selected by `srcMask` in `src` over to `dest`. `dest` will\nbe a 1D image.";
constexpr char const* dip·CopyFrom·Image·CL·Image·L·IntegerArray·CL = "Copies the pixels selected by `srcOffsets` over from `src` to `dest`. `dest`\nwill be a 1D image.";
constexpr char const* dip·CopyTo·Image·CL·Image·L·Image·CL = "Copies all pixels from `src` over to the pixels selected by `destMask` in\n`dest`. `dest` must be forged.";
constexpr char const* dip·CopyTo·Image·CL·Image·L·IntegerArray·CL = "Copies all pixels from `src` over to the pixels selected by `destOffsets` in\n`dest`. `dest` must be forged.";
constexpr char const* dip·ExpandTensor·Image·CL·Image·L = "Copies samples over from `src` to `dest`, expanding the tensor so it's a\nstandard, column-major matrix.";
constexpr char const* dip·Convert·Image·CL·Image·L·dip·DataType· = "Copies samples over from `src` to `dest`, with data type conversion.";
constexpr char const* dip·CreateImageRefArray·ImageArray·L = "Creates a `dip::ImageRefArray` from a `dip::ImageArray`.";
constexpr char const* dip·CreateImageConstRefArray·ImageArray·CL = "Creates a `dip::ImageConstRefArray` from a `dip::ImageArray`.";
constexpr char const* dip·operatorltlt·std·ostream·L·Image·Sample·CL = "You can output a `dip::Image::Sample` to `std::cout` or any other stream. It\nis printed like any numeric value of the same type.";
constexpr char const* dip·operatorplus·Image·Pixel·CL·Image·Pixel·CL = "Arithmetic operator, element-wise.";
constexpr char const* dip·operatorminus·Image·Pixel·CL·Image·Pixel·CL = "Arithmetic operator, element-wise.";
constexpr char const* dip·operatortimes·Image·Pixel·CL·Image·Pixel·CL = "Arithmetic operator, tensor multiplication.";
constexpr char const* dip·operatordiv·Image·Pixel·CL·Image·Pixel·CL = "Arithmetic operator, element-wise.";
constexpr char const* dip·operatormod·Image·Pixel·CL·Image·Pixel·CL = "Arithmetic operator, element-wise.";
constexpr char const* dip·operatorand·Image·Pixel·CL·Image·Pixel·CL = "Bit-wise operator, element-wise.";
constexpr char const* dip·operatoror·Image·Pixel·CL·Image·Pixel·CL = "Bit-wise operator, element-wise.";
constexpr char const* dip·operatorxor·Image·Pixel·CL·Image·Pixel·CL = "Bit-wise operator, element-wise.";
constexpr char const* dip·operatorminus·Image·Pixel·CL = "Unary operator, element-wise.";
constexpr char const* dip·operatorneg·Image·Pixel·CL = "Bit-wise unary operator operator.";
constexpr char const* dip·operatornot·Image·Pixel·CL = "Boolean unary operator, element-wise.";
constexpr char const* dip·operatoreqeq·Image·Pixel·CL·Image·Pixel·CL = "Comparison operator, can only be true if the two pixels have compatible number\nof tensor elements.";
constexpr char const* dip·operatornoteq·T·Image·Pixel·CL·T·CL = "Comparison operator, equivalent to `!(lhs==rhs)`.";
constexpr char const* dip·operatorlt·Image·Pixel·CL·Image·Pixel·CL = "Comparison operator, can only be true if the two pixels have compatible number\nof tensor elements.";
constexpr char const* dip·operatorgt·Image·Pixel·CL·Image·Pixel·CL = "Comparison operator, can only be true if the two pixels have compatible number\nof tensor elements.";
constexpr char const* dip·operatorlteq·Image·Pixel·CL·Image·Pixel·CL = "Comparison operator, can only be true if the two pixels have compatible number\nof tensor elements.";
constexpr char const* dip·operatorgteq·Image·Pixel·CL·Image·Pixel·CL = "Comparison operator, can only be true if the two pixels have compatible number\nof tensor elements.";
constexpr char const* dip·operatorltlt·std·ostream·L·Image·Pixel·CL = "You can output a `dip::Image::Pixel` to `std::cout` or any other stream. It is\nprinted as a sequence of values, prepended with \"Pixel with values:\".";
constexpr char const* dip·pi = "The constant &pi;.";
constexpr char const* dip·nan = "A NaN value.";
constexpr char const* dip·infinity = "Infinity.";
constexpr char const* dip·maximum_gauss_truncation·T = "Maximum meaningful truncation value for a Gaussian. Larger truncation values\nwill lead to differences of more than one machine epsilon between the middle\nand the ends of the Gaussian. `T` must be a floating-point type.";
constexpr char const* dip·gcd·dip·uint··dip·uint· = "Compute the greatest common denominator of two positive integers.";
constexpr char const* dip·div_ceil·T·T··T· = "Integer division, unsigned, return ceil.";
constexpr char const* dip·div_floor·T·T··T· = "Integer division, unsigned, return floor.";
constexpr char const* dip·div_round·T·T··T· = "Integer division, return rounded.";
constexpr char const* dip·modulo·dip·uint··dip·uint· = "Integer modulo, result is always positive, as opposed to % operator.";
constexpr char const* dip·modulo·dip·sint··dip·sint· = "Integer modulo, result is always positive, as opposed to % operator.";
constexpr char const* dip·floor_cast·T·T· = "Fast floor operation, without checks, returning a `dip::sint`.";
constexpr char const* dip·ceil_cast·T·T· = "Fast ceil operation, without checks, returning a `dip::sint`.";
constexpr char const* dip·round_cast·T·T· = "Fast round operation, without checks, returning a `dip::sint`.";
constexpr char const* dip·consistent_round·T·T· = "Consistent rounding, without checks, returning a `dip::sint`.";
constexpr char const* dip·abs·T·T· = "`constexpr` version of `std::abs`. Prefer `std::abs` outside of `constexpr`\nfunctions.";
constexpr char const* dip·clamp·T·T·CL·T·CL·T·CL = "Clamps a value between a min and max value (a.k.a. clip, saturate, etc.).";
constexpr char const* dip·pow10·dip·sint· = "Computes integer powers of 10, assuming the power is relatively small.";
constexpr char const* dip·ApproximatelyEquals·dfloat··dfloat··dfloat· = "Approximate floating-point equality: `abs(lhs-rhs)/lhs <= tolerance`.";
constexpr char const* dip·LengthUnicode·String·CL = "Counts the length of a (UTF-8 encoded) Unicode string.";
constexpr char const* dip·BesselJ0·dfloat· = "Computes the Bessel function J of the order 0 (with around 7 digits of\nprecision).";
constexpr char const* dip·BesselJ1·dfloat· = "Computes the Bessel function J of the order 1 (with around 7 digits of\nprecision).";
constexpr char const* dip·BesselJN·dfloat··dip·uint· = "Computes the Bessel function J of the order `n` (with around 7 digits of\nprecision).";
constexpr char const* dip·BesselY0·dfloat· = "Computes the Bessel function Y of the order 0 (with around 7 digits of\nprecision).";
constexpr char const* dip·BesselY1·dfloat· = "Computes the Bessel function Y of the order 1 (with around 7 digits of\nprecision).";
constexpr char const* dip·BesselYN·dfloat··dip·uint· = "Computes the Bessel function Y of the order `n` (with around 7 digits of\nprecision).";
constexpr char const* dip·Sinc·dfloat· = "Computes the sinc function.";
constexpr char const* dip·Phi·dfloat· = "Computes phi, the integral of the PDF of a Normal distribution with unit\nvariance and zero mean from minus infinity to `x`.";
constexpr char const* dip·Phi·dfloat··dfloat··dfloat· = "Computes phi, the integral of the PDF of a Normal distribution with standard\ndeviation `s` and mean `m` from minus infinity to `x`.";
constexpr char const* dip·HypersphereSurface·dip·uint··dfloat· = "Computes the surface area of an `n`-dimensional hypersphere with radius `r`.";
constexpr char const* dip·HypersphereVolume·dip·uint··dfloat· = "Computes the volume of an `n`-dimensional hypersphere with radius `r`.";
constexpr char const* dip·SymmetricEigenDecomposition·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the eigenvalues and eigenvectors of a symmetric, real-valued matrix.";
constexpr char const* dip·SymmetricEigenDecomposition2·ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the eigenvalues and eigenvectors of a 2x2 symmetric, real-valued matrix.";
constexpr char const* dip·SymmetricEigenDecomposition3·ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the eigenvalues and eigenvectors of a 3x3 symmetric, real-valued matrix.";
constexpr char const* dip·LargestEigenvector·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the largest eigenvector of a symmetric, real-valued matrix.";
constexpr char const* dip·SmallestEigenvector·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the smallest eigenvector of a symmetric, real-valued matrix.";
constexpr char const* dip·SymmetricEigenDecompositionPacked·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Finds the eigenvalues and eigenvectors of a symmetric, real-valued matrix,\nwhere only the unique values are given.";
constexpr char const* dip·EigenDecomposition·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt· = "Finds the eigenvalues and eigenvectors of a square, real-valued matrix.";
constexpr char const* dip·EigenDecomposition·dip·uint··ConstSampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt· = "Finds the eigenvalues and eigenvectors of a square, complex-valued matrix.";
constexpr char const* dip·Sum·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the sum of the values of a vector.";
constexpr char const* dip·SumAbsSquare·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the sum of the square of the values of a vector.";
constexpr char const* dip·Product·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the product of the values of a vector.";
constexpr char const* dip·Norm·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the norm of a vector.";
constexpr char const* dip·SquareNorm·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the square norm of a vector.";
constexpr char const* dip·Determinant·dip·uint··ConstSampleIteratorgtdfloatlt· = "Computes the determinant of a square, real-valued matrix.";
constexpr char const* dip·Determinant·dip·uint··ConstSampleIteratorgtdcomplexlt· = "Computes the determinant of a square, complex-valued matrix.";
constexpr char const* dip·DeterminantDiagonal·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the determinant of a diagonal matrix.";
constexpr char const* dip·Trace·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the trace of a square matrix.";
constexpr char const* dip·TraceDiagonal·T·dip·uint··ConstSampleIteratorgtTlt· = "Computes the trace of a diagonal matrix.";
constexpr char const* dip·SingularValueDecomposition·dip·uint··dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Computes the \"thin\" singular value decomposition of a real-valued matrix";
constexpr char const* dip·SingularValueDecomposition·dip·uint··dip·uint··ConstSampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt· = "Computes the \"thin\" singular value decomposition of a complex-valued matrix";
constexpr char const* dip·Inverse·dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Computes the inverse of a square, real-valued matrix.";
constexpr char const* dip·Inverse·dip·uint··ConstSampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt· = "Computes the inverse of a square, complex-valued matrix.";
constexpr char const* dip·PseudoInverse·dip·uint··dip·uint··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··dfloat· = "Computes the Moore-Penrose pseudo-inverse of a real-valued matrix, using the\nJacobi SVD decomposition.";
constexpr char const* dip·PseudoInverse·dip·uint··dip·uint··ConstSampleIteratorgtdcomplexlt··SampleIteratorgtdcomplexlt··dfloat· = "Computes the Moore-Penrose pseudo-inverse of a complex-valued matrix, using\nthe Jacobi SVD decomposition.";
constexpr char const* dip·Rank·dip·uint··dip·uint··ConstSampleIteratorgtdfloatlt· = "Computes the rank of a real-valued matrix.";
constexpr char const* dip·Rank·dip·uint··dip·uint··ConstSampleIteratorgtdcomplexlt· = "Computes the rank of a complex-valued matrix.";
constexpr char const* dip·Solve·dip·uint··dip·uint··ConstSampleIteratorgtdfloatlt··ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt· = "Solves a system of real-valued equations, using the Jacobi SVD decomposition.";
constexpr char const* dip·ThinPlateSpline = "Fits a thin plate spline function to a set of points. Useful for interpolation\nof scattered points.";
constexpr char const* dip·ThinPlateSpline·ThinPlateSpline·FloatCoordinateArray··FloatCoordinateArray·CL·dfloat· = "Creates a function that maps `coordinate` to `value`.";
constexpr char const* dip·ThinPlateSpline·Evaluate·FloatArray·CL = "Evaluates the thin plate spline function at point `pt`.";
constexpr char const* dip·Option = "Enumerated options are defined in the namespace `dip::Option`, unless they are\nspecific to some other sub-namespace.";
constexpr char const* dip·Option·Periodicity = "Select if the operation is periodic or not. Used in\n`dip::GaussianMixtureModel`.";
constexpr char const* dip·Option·Periodicity·NOT_PERIODIC = "The operation is not periodic";
constexpr char const* dip·Option·Periodicity·PERIODIC = "The operation is periodic, left and right ends of the data are contiguous";
constexpr char const* dip·Option·ThrowException = "Some functions that check for a condition optionally throw an exception if\nthat condition is not met.";
constexpr char const* dip·Option·ThrowException·DONT_THROW = "Do not throw and exception, return false if the condition is not met.";
constexpr char const* dip·Option·ThrowException·DO_THROW = "Throw an exception if the condition is not met.";
constexpr char const* dip·Option·AllowSingletonExpansion = "The function `dip::Image::CheckIsMask` takes this option to control how sizes\nare compared.";
constexpr char const* dip·Option·AllowSingletonExpansion·DONT_ALLOW = "Do not allow singleton expansion.";
constexpr char const* dip·Option·AllowSingletonExpansion·DO_ALLOW = "Allow singleton expansion.";
constexpr char const* dip·Option·AcceptDataTypeChange = "The function `dip::Image::ReForge` takes this option to control how to handle\nprotected images.";
constexpr char const* dip·Option·AcceptDataTypeChange·DONT_ALLOW = "Do not allow data type change, the output image is always of the requested\ntype.";
constexpr char const* dip·Option·AcceptDataTypeChange·DO_ALLOW = "Allow data type change, if the output image is protected, it will be used as\nis.";
constexpr char const* dip·Option·CropLocation = "The function `dip::Image::Crop` takes this option to control which pixels are\ntaken.";
constexpr char const* dip·Option·CropLocation·CENTER = "The pixel at the origin of the input image is also at the origin in the output\nimage.";
constexpr char const* dip·Option·CropLocation·MIRROR_CENTER = "Same as `CENTER`, but for even-sized images, the origin is presumed to be left\nof center, rather than right of center.";
constexpr char const* dip·Option·CropLocation·TOP_LEFT = "The corner of the image at coordinates {0,0,0...} is kept in the corner.";
constexpr char const* dip·Option·CropLocation·BOTTOM_RIGHT = "The corner of the image opposite that of `TOP_LEFT` is kept in the corner.";
constexpr char const* dip·Option·CmpPropEnumerator = "Determines which properties to compare.";
constexpr char const* dip·Option·CmpPropEnumerator·DataType = "Compares data type";
constexpr char const* dip·Option·CmpPropEnumerator·Dimensionality = "Compares number of dimensions";
constexpr char const* dip·Option·CmpPropEnumerator·Sizes = "Compares image size";
constexpr char const* dip·Option·CmpPropEnumerator·Strides = "Compares image strides";
constexpr char const* dip·Option·CmpPropEnumerator·TensorShape = "Compares tensor size and shape";
constexpr char const* dip·Option·CmpPropEnumerator·TensorElements = "Compares number of tensor elements";
constexpr char const* dip·Option·CmpPropEnumerator·TensorStride = "Compares tensor stride";
constexpr char const* dip·Option·CmpPropEnumerator·ColorSpace = "Compares color space";
constexpr char const* dip·Option·CmpPropEnumerator·PixelSize = "Compares pixel size";
constexpr char const* dip·Option·CmpPropFlags = "Determines which properties to compare. Combines multiple\n`dip::Option::CmpPropEnumerator` values, predefined values are in\n`dip::Option::CmpProp`.";
constexpr char const* dip·Option·CmpProp = "Namespace to emulate an enumerator, contains values";
constexpr char const* dip·Option·CmpProp·DataType = "`dip::Option::CmpPropEnumerator::DataType`.";
constexpr char const* dip·Option·CmpProp·Dimensionality = "`dip::Option::CmpPropEnumerator::Dimensionality`.";
constexpr char const* dip·Option·CmpProp·Sizes = "`dip::Option::CmpPropEnumerator::Sizes`.";
constexpr char const* dip·Option·CmpProp·Strides = "`dip::Option::CmpPropEnumerator::Strides`.";
constexpr char const* dip·Option·CmpProp·TensorShape = "`dip::Option::CmpPropEnumerator::TensorShape`.";
constexpr char const* dip·Option·CmpProp·TensorElements = "`dip::Option::CmpPropEnumerator::TensorElements`.";
constexpr char const* dip·Option·CmpProp·TensorStride = "`dip::Option::CmpPropEnumerator::TensorStride`.";
constexpr char const* dip·Option·CmpProp·ColorSpace = "`dip::Option::CmpPropEnumerator::ColorSpace`.";
constexpr char const* dip·Option·CmpProp·PixelSize = "`dip::Option::CmpPropEnumerator::PixelSize`.";
constexpr char const* dip·Option·CmpProp·AllSizes = "`dip::Option::CmpProp::Sizes` + `dip::Option::CmpProp::TensorElements`.";
constexpr char const* dip·Option·CmpProp·Samples = "`dip::Option::CmpProp::DataType` + `dip::Option::CmpProp::Sizes` +\n`dip::Option::CmpProp::TensorElements`.";
constexpr char const* dip·Option·CmpProp·Shape = "`dip::Option::CmpProp::DataType` + `dip::Option::CmpProp::Sizes` +\n`dip::Option::CmpProp::TensorShape`.";
constexpr char const* dip·Option·CmpProp·Full = "`dip::Option::CmpProp::Shape` + `dip::Option::CmpProp::Strides` +\n`dip::Option::CmpProp::TensorStride`.";
constexpr char const* dip·Option·CmpProp·All = "`dip::Option::CmpProp::Shape` + `dip::Option::CmpProp::ColorSpace` +\n`dip::Option::CmpProp::PixelSize`.";
constexpr char const* dip·Option·ExtendImage = "Defines options to the `dip::ExtendImage` function.";
constexpr char const* dip·Option·ExtendImage·Masked = "The output image is a window on the boundary-extended image of the same size\nas the input.";
constexpr char const* dip·Option·ExtendImage·ExpandTensor = "The output image has normal tensor storage.";
constexpr char const* dip·Option·ExtendImageFlags = "Combines any number of `dip::Option::ExtendImage` constants together.";
constexpr char const* dip·Option·DFTOption = "Determines working mode for `dip::DFT` and `dip::RDFT`.";
constexpr char const* dip·Option·DFTOption·InPlace = "Work in place, the input and output buffers are the same.";
constexpr char const* dip·Option·DFTOption·TrashInput = "Allowed to trash the input buffer, we don't need to preserve it.";
constexpr char const* dip·Option·DFTOption·Aligned = "Both buffers are aligned to 16-byte boundaries.";
constexpr char const* dip·Option·DFTOptions = "Determines working mode for `dip::DFT` and `dip::RDFT`. Combines multiple\n`dip::Option::DFTOption` values,.";
constexpr char const* dip·Option·CompareImagesMode = "How to compare images in `dip::testing::CompareImages`.";
constexpr char const* dip·Option·CompareImagesMode·EXACT = "Compare only the sample values (and image sizes).";
constexpr char const* dip·Option·CompareImagesMode·APPROX = "Compare the sample values (and image sizes), to match within `epsilon` in\nabsolute terms.";
constexpr char const* dip·Option·CompareImagesMode·APPROX_REL = "Compare the sample values (and image sizes), to match within `epsilon` in\nrelative terms.";
constexpr char const* dip·Option·CompareImagesMode·FULL = "Compare for identical sample values as well as tensor shape, color space, and\npixel size.";
constexpr char const* dip·GaussianParameters = "Parameters defining a 1D Gaussian. Returned by `dip::GaussianMixtureModel`.";
constexpr char const* dip·GaussianParameters·position = "The location of the origin, in pixels";
constexpr char const* dip·GaussianParameters·amplitude = "The amplitude (value at the origin)";
constexpr char const* dip·GaussianParameters·sigma = "The sigma (width)";
constexpr char const* dip·GaussianMixtureModel·ConstSampleIteratorgtdfloatlt··SampleIteratorgtdfloatlt··dip·uint··dip·uint··dip·uint··Option·Periodicity· = "Determines the parameters for a Gaussian Mixture Model.";
constexpr char const* dip·RankFromPercentile·dfloat··dip·uint· = "Computes the rank (index into array) for a given percentile and an array of\nlength `n`.";
constexpr char const* dip·Add·Image·CL·Image·CL·Image·L·DataType· = "Adds two images, sample-wise, with singleton expansion, and using saturated\narithmetic.";
constexpr char const* dip·Subtract·Image·CL·Image·CL·Image·L·DataType· = "Subtracts two images, sample-wise, with singleton expansion, and using\nsaturated arithmetic.";
constexpr char const* dip·Multiply·Image·CL·Image·CL·Image·L·DataType· = "Multiplies two images, pixel-wise, with singleton expansion, and using\nsaturated arithmetic.";
constexpr char const* dip·MultiplySampleWise·Image·CL·Image·CL·Image·L·DataType· = "Multiplies two images, sample-wise, with singleton expansion, and using\nsaturated arithmetic.";
constexpr char const* dip·MultiplyConjugate·Image·CL·Image·CL·Image·L·DataType· = "Multiplies two images with complex conjugation, sample-wise, with singleton\nexpansion.";
constexpr char const* dip·Divide·Image·CL·Image·CL·Image·L·DataType· = "Divides two images, sample-wise, with singleton expansion.";
constexpr char const* dip·SafeDivide·Image·CL·Image·CL·Image·L·DataType· = "Divides two images, sample-wise, with singleton expansion. Tests for division\nby zero, filling in 0 instead.";
constexpr char const* dip·Modulo·Image·CL·Image·CL·Image·L·DataType· = "Computes the modulo of two images, sample-wise, with singleton expansion.";
constexpr char const* dip·Power·Image·CL·Image·CL·Image·L·DataType· = "Elevates `lhs` to the power of `rhs`, sample-wise, with singleton expansion.";
constexpr char const* dip·Invert·Image·CL·Image·L = "Inverts each sample of the input image, yielding an image of the same type.";
constexpr char const* dip·And·Image·CL·Image·CL·Image·L = "Bit-wise AND of two integer images, or logical AND of two binary images,\nsample-wise, with singleton expansion.";
constexpr char const* dip·Or·Image·CL·Image·CL·Image·L = "Bit-wise OR of two integer images, or logical OR of two binary images, sample-\nwise, with singleton expansion.";
constexpr char const* dip·Xor·Image·CL·Image·CL·Image·L = "Bit-wise XOR of two integer images, or logical XOR of two binary images,\nsample-wise, with singleton expansion.";
constexpr char const* dip·Not·Image·CL·Image·L = "Bit-wise NOT of an integer image, or logical NOT of a binary image, sample-\nwise.";
constexpr char const* dip·operatorplus·T·T1·CL·T2·CL = "Arithmetic operator, calls `dip::Add`.";
constexpr char const* dip·operatorminus·T·T1·CL·T2·CL = "Arithmetic operator, calls `dip::Subtract`.";
constexpr char const* dip·operatortimes·T·T1·CL·T2·CL = "Arithmetic operator, calls `dip::Multiply`.";
constexpr char const* dip·operatordiv·T·T1·CL·T2·CL = "Arithmetic operator, calls `dip::Divide`.";
constexpr char const* dip·operatormod·T·T1·CL·T2·CL = "Arithmetic operator, calls `dip::Modulo`.";
constexpr char const* dip·operatorand·T·Image·CL·T·CL = "Bit-wise and logical operator, calls `dip::And`.";
constexpr char const* dip·operatoror·T·Image·CL·T·CL = "Bit-wise and logical operator, calls `dip::Or`.";
constexpr char const* dip·operatorxor·T·Image·CL·T·CL = "Bit-wise and logical operator, calls `dip::Xor`.";
constexpr char const* dip·operatorplus·Image·CL = "Unary operator, converts binary image to `dip::DT_UINT` and leaves other\nimages unchanged, does not copy data.";
constexpr char const* dip·operatorminus·Image·CL = "Unary operator, calls `dip::Invert`.";
constexpr char const* dip·operatorneg·Image·CL = "Bit-wise and logical unary operator, calls `dip::Not`.";
constexpr char const* dip·operatornot·Image·CL = "Logical unary operator. The input is converted to a binary image, then calls\n`dip::Invert`.";
constexpr char const* dip·operatorpluseq·T·Image·L·T·CL = "Compound assignment operator, calls `dip::Add`.";
constexpr char const* dip·operatorminuseq·T·Image·L·T·CL = "Compound assignment operator, calls `dip::Subtract`.";
constexpr char const* dip·operatortimeseq·T·Image·L·T·CL = "Compound assignment operator, calls `dip::Multiply`.";
constexpr char const* dip·operatordiveq·T·Image·L·T·CL = "Compound assignment operator, calls `dip::Divide`.";
constexpr char const* dip·operatormodeq·T·Image·L·T·CL = "Compound assignment operator, calls `dip::Modulo`.";
constexpr char const* dip·operatorandeq·T·Image·L·T·CL = "Bit-wise compound assignment operator, calls `dip::And`.";
constexpr char const* dip·operatororeq·T·Image·L·T·CL = "Bit-wise compound assignment operator, calls `dip::Or`.";
constexpr char const* dip·operatorxoreq·T·Image·L·T·CL = "Bit-wise compound assignment operator, calls `dip::Xor`.";
constexpr char const* dip·Equal·Image·CL·Image·CL·Image·L = "Equality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·NotEqual·Image·CL·Image·CL·Image·L = "Inequality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·Lesser·Image·CL·Image·CL·Image·L = "Inequality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·Greater·Image·CL·Image·CL·Image·L = "Inequality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·NotGreater·Image·CL·Image·CL·Image·L = "Inequality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·NotLesser·Image·CL·Image·CL·Image·L = "Inequality comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·InRange·Image·CL·Image·CL·Image·CL·Image·L = "In-range ternary comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·OutOfRange·Image·CL·Image·CL·Image·CL·Image·L = "Out-of-range ternary comparison, sample-wise, with singleton expansion.";
constexpr char const* dip·operatoreqeq·T·Image·CL·T·CL = "Comparison operator, calls `dip::Equal`.";
constexpr char const* dip·operatornoteq·T·Image·CL·T·CL = "Comparison operator, calls `dip::NotEqual`.";
constexpr char const* dip·operatorlt·T·Image·CL·T·CL = "Comparison operator, calls `dip::Lesser`.";
constexpr char const* dip·operatorgt·T·Image·CL·T·CL = "Comparison operator, calls `dip::Greater`.";
constexpr char const* dip·operatorlteq·T·Image·CL·T·CL = "Comparison operator, calls `dip::NotGreater`.";
constexpr char const* dip·operatorgteq·T·Image·CL·T·CL = "Comparison operator, calls `dip::NotLesser`.";
constexpr char const* dip·Units = "Encapsulates the concepts of physical units, using SI units.";
constexpr char const* dip·Units·BaseUnits = "These are the base units for the SI system.";
constexpr char const* dip·Units·BaseUnits·THOUSANDS = "prefix";
constexpr char const* dip·Units·BaseUnits·LENGTH = "m";
constexpr char const* dip·Units·BaseUnits·MASS = "g (should be Kg, but this is easier when working with prefixes)";
constexpr char const* dip·Units·BaseUnits·TIME = "s";
constexpr char const* dip·Units·BaseUnits·CURRENT = "A";
constexpr char const* dip·Units·BaseUnits·TEMPERATURE = "K";
constexpr char const* dip·Units·BaseUnits·LUMINOUSINTENSITY = "cd";
constexpr char const* dip·Units·BaseUnits·ANGLE = "rad (though really dimensionless)";
constexpr char const* dip·Units·BaseUnits·PIXEL = "px (units to use when the image has no dimension information)";
constexpr char const* dip·Units·Units = "A default-constructed `Units` is dimensionless.";
constexpr char const* dip·Units·Units·BaseUnits··dip·sint8· = "Construct a `Units` for a specific unit.";
constexpr char const* dip·Units·Units·dip·String·CL = "Construct a `Units` from a string representation of units. The string\nrepresentation should be as produced by `dip::Units::String`, except that 'u'\nand '&mu;' are synonyms.";
constexpr char const* dip·Units·Power·dip·sint8· = "Elevates `this` to the power `p`.";
constexpr char const* dip·Units·operatortimeseq·Units·CL = "Multiplies two units objects.";
constexpr char const* dip·Units·operatordiveq·Units·CL = "Divides two units objects.";
constexpr char const* dip·Units·operatoreqeq·Units·CL·C = "Compares two units objects.";
constexpr char const* dip·Units·operatornoteq·Units·CL·C = "Compares two units objects.";
constexpr char const* dip·Units·HasSameDimensions·Units·CL·C = "Compares two units objects. This differs from the `==` operator in that `km`\nand `&mu;m` test equal. That is, the SI prefix is ignored.";
constexpr char const* dip·Units·IsDimensionless·C = "Test to see if the units are dimensionless (has no units).";
constexpr char const* dip·Units·IsPhysical·C = "Test to see if the units are physical. Units that involve pixels are not\nphysical, and neither are dimensionless units.";
constexpr char const* dip·Units·AdjustThousands·dip·sint· = "Adjusts the power of the thousands, so that we can use an SI prefix with the\nfirst unit to be written out.";
constexpr char const* dip·Units·Thousands·C = "Returns the power associated with `dip::Units::BaseUnits::THOUSANDS`,\ncorresponding to a given SI prefix.";
constexpr char const* dip·Units·String·C = "Cast physical units to a string representation, using only ASCII characters.";
constexpr char const* dip·Units·StringUnicode·C = "Cast physical units to a string representation, using Unicode characters\n(UTF-8 encoded).";
constexpr char const* dip·Units·FromString·dip·String·CL = "Sets `this` to the units represented by the string. This function recognizes\nmore strings than what the constructor recognizes.";
constexpr char const* dip·Units·operator_bool·C = "Units tests false if they're dimensionless.";
constexpr char const* dip·Units·swap·Units·L = "Swaps the values of `this` and `other`.";
constexpr char const* dip·Units·Nano = "Dimensionless nano magnitude (n)";
constexpr char const* dip·Units·Micro = "Dimensionless micro magnitude (&mu;)";
constexpr char const* dip·Units·Milli = "Dimensionless milli magnitude (m)";
constexpr char const* dip·Units·Kilo = "Dimensionless kilo magnitude (k)";
constexpr char const* dip·Units·Mega = "Dimensionless mega magnitude (M)";
constexpr char const* dip·Units·Giga = "Dimensionless giga magnitude (G)";
constexpr char const* dip·Units·Meter = "Meter units (m)";
constexpr char const* dip·Units·SquareMeter = "Square meter units (m^2^)";
constexpr char const* dip·Units·CubicMeter = "Cubic meter units (m^3^)";
constexpr char const* dip·Units·Nanometer = "Nanometer units (nm)";
constexpr char const* dip·Units·Micrometer = "Micrometer units (&mu;m)";
constexpr char const* dip·Units·Millimeter = "Millimeter units (mm)";
constexpr char const* dip·Units·Kilometer = "Kilometer units (km)";
constexpr char const* dip·Units·SquareMicrometer = "Square micrometer units (&mu;m^2^)";
constexpr char const* dip·Units·SquareMillimeter = "Square millimeter units (mm^2^)";
constexpr char const* dip·Units·CubicMillimeter = "Cubic millimeter units (mm^3^)";
constexpr char const* dip·Units·Second = "Second units (s)";
constexpr char const* dip·Units·Millisecond = "Millisecond units (ms)";
constexpr char const* dip·Units·Hertz = "Hertz units (s^-1^)";
constexpr char const* dip·Units·Kilohertz = "Kilohertz units (ms^-1^)";
constexpr char const* dip·Units·Megahertz = "Megahertz units (&mu;s^-1^)";
constexpr char const* dip·Units·Gigahertz = "Gigahertz units (ns^-1^)";
constexpr char const* dip·Units·Radian = "Radian units (rad)";
constexpr char const* dip·Units·Pixel = "Pixel units (px)";
constexpr char const* dip·Units·SquarePixel = "Square pixel units (px^2^)";
constexpr char const* dip·Units·CubicPixel = "Cubic pixel units (px^3^)";
constexpr char const* dip·operatortimes·Units··Units·CL = "Multiplies two units objects.";
constexpr char const* dip·operatordiv·Units··Units·CL = "Divides two units objects.";
constexpr char const* dip·operatorltlt·std·ostream·L·Units·CL = "Insert physical quantity to an output stream as a string of base units. See\n`dip::Units::String`.";
constexpr char const* dip·PhysicalQuantity = "Encapsulates a quantity with physical units.";
constexpr char const* dip·PhysicalQuantity·PhysicalQuantity = "A default-constructed `PhysicalQuantity` has magnitude 0 and is unitless.";
constexpr char const* dip·PhysicalQuantity·PhysicalQuantity·dip·dfloat··Units·CL = "Create an arbitrary physical quantity.";
constexpr char const* dip·PhysicalQuantity·PhysicalQuantity·Units·CL = "Create a unit-valued physical quantity.";
constexpr char const* dip·PhysicalQuantity·Nanometer = "One nanometer.";
constexpr char const* dip·PhysicalQuantity·Micrometer = "One micrometer.";
constexpr char const* dip·PhysicalQuantity·Millimeter = "One millimeter.";
constexpr char const* dip·PhysicalQuantity·Centimeter = "One centimeter.";
constexpr char const* dip·PhysicalQuantity·Meter = "One meter.";
constexpr char const* dip·PhysicalQuantity·Kilometer = "One kilometer.";
constexpr char const* dip·PhysicalQuantity·Inch = "One inch.";
constexpr char const* dip·PhysicalQuantity·Mile = "One mile.";
constexpr char const* dip·PhysicalQuantity·Millisecond = "One millisecond";
constexpr char const* dip·PhysicalQuantity·Second = "One second";
constexpr char const* dip·PhysicalQuantity·Minute = "One minute";
constexpr char const* dip·PhysicalQuantity·Hour = "One hour";
constexpr char const* dip·PhysicalQuantity·Day = "One day";
constexpr char const* dip·PhysicalQuantity·Radian = "One radian";
constexpr char const* dip·PhysicalQuantity·Degree = "One degree";
constexpr char const* dip·PhysicalQuantity·Pixel = "One pixel";
constexpr char const* dip·PhysicalQuantity·SquarePixel = "One square pixel";
constexpr char const* dip·PhysicalQuantity·CubicPixel = "One cubic pixel";
constexpr char const* dip·PhysicalQuantity·operatortimeseq·PhysicalQuantity·CL = "Multiplies two physical quantities.";
constexpr char const* dip·PhysicalQuantity·operatortimeseq·dip·dfloat· = "Scaling of a physical quantity.";
constexpr char const* dip·PhysicalQuantity·operatordiveq·PhysicalQuantity·CL = "Divides two physical quantities.";
constexpr char const* dip·PhysicalQuantity·operatordiveq·dip·dfloat· = "Scaling of a physical quantity.";
constexpr char const* dip·PhysicalQuantity·Power·dip·sint8··C = "Computes a physical quantity to the power of `p`.";
constexpr char const* dip·PhysicalQuantity·Invert·C = "Computes a physical quantity to the power of -1.";
constexpr char const* dip·PhysicalQuantity·operatorminus·C = "Unary negation.";
constexpr char const* dip·PhysicalQuantity·operatorpluseq·PhysicalQuantity·CL = "Addition of two physical quantities.";
constexpr char const* dip·PhysicalQuantity·operatorminuseq·PhysicalQuantity· = "Subtraction of two physical quantities.";
constexpr char const* dip·PhysicalQuantity·operatoreqeq·PhysicalQuantity·CL·C = "Exact equality comparison of two physical quantities.";
constexpr char const* dip·PhysicalQuantity·operatornoteq·PhysicalQuantity·CL·C = "Exact inequality comparison of two physical quantities";
constexpr char const* dip·PhysicalQuantity·ApproximatelyEquals·PhysicalQuantity·CL·dfloat··C = "Approximate equality comparison of two physical quantities.";
constexpr char const* dip·PhysicalQuantity·NotApproximatelyEquals·PhysicalQuantity·CL·dfloat··C = "Exact inequality comparison of two physical quantities";
constexpr char const* dip·PhysicalQuantity·HasSameDimensions·PhysicalQuantity·CL·C = "Test to see if the physical quantities can be added together.";
constexpr char const* dip·PhysicalQuantity·IsDimensionless·C = "Test to see if the physical quantity is dimensionless (has no units).";
constexpr char const* dip·PhysicalQuantity·IsPhysical·C = "Test to see if the physical quantity is actually physical. If pixels are used\nas units, it's not a physical quantity, and dimensionless quantities are not\nphysical either.";
constexpr char const* dip·PhysicalQuantity·Normalize = "Adjusts the SI prefix such that the magnitude of the quantity is readable.";
constexpr char const* dip·PhysicalQuantity·RemovePrefix = "Removes the SI prefix, such that the quantity is in base units (i.e. m rather\nthan nm).";
constexpr char const* dip·PhysicalQuantity·operator_dipcoloncolondfloat·C = "Retrieve the magnitude, discarding units.";
constexpr char const* dip·PhysicalQuantity·operator_bool·C = "A physical quantity tests true if it is different from 0.";
constexpr char const* dip·PhysicalQuantity·swap·PhysicalQuantity·L = "Swaps the values of `this` and `other`.";
constexpr char const* dip·PhysicalQuantity·magnitude = "The magnitude";
constexpr char const* dip·PhysicalQuantity·units = "The units";
constexpr char const* dip·operatortimes·PhysicalQuantity··PhysicalQuantity·CL = "Multiplies two physical quantities.";
constexpr char const* dip·operatortimes·PhysicalQuantity··dip·dfloat· = "Scaling of a physical quantity.";
constexpr char const* dip·operatortimes·dip·dfloat··PhysicalQuantity· = "Scaling of a physical quantity.";
constexpr char const* dip·operatordiv·PhysicalQuantity··PhysicalQuantity·CL = "Divides two physical quantities.";
constexpr char const* dip·operatordiv·PhysicalQuantity··dip·dfloat· = "Scaling of a physical quantity.";
constexpr char const* dip·operatordiv·dip·dfloat··PhysicalQuantity· = "Scaling of a physical quantity.";
constexpr char const* dip·operatorplus·PhysicalQuantity··PhysicalQuantity·CL = "Addition of two physical quantities.";
constexpr char const* dip·operatorminus·PhysicalQuantity··PhysicalQuantity·CL = "Subtraction of two physical quantities.";
constexpr char const* dip·operatorltlt·std·ostream·L·PhysicalQuantity·CL = "Insert physical quantity to an output stream.";
constexpr char const* dip·PhysicalQuantityArray = "An array to hold physical quantities, such as a pixel's size.";
constexpr char const* dip·operatortimes·dip·dfloat··Units·CL = "Create an arbitrary physical quantity by multiplying a magnitude with units.";
constexpr char const* dip·operatortimes·Units·CL·dip·dfloat· = "Create an arbitrary physical quantity by multiplying a magnitude with units.";
constexpr char const* dip·PixelSize = "Specifies an image's pixel size as physical quantities.";
constexpr char const* dip·PixelSize·PixelSize = "By default, an image has no physical dimensions. The pixel size is given as\n\"1 pixel\".";
constexpr char const* dip·PixelSize·PixelSize·PhysicalQuantity·CL = "Create an isotropic pixel size based on a physical quantity.";
constexpr char const* dip·PixelSize·PixelSize·PhysicalQuantityArray·CL = "Create a pixel size based on an array of physical quantities.";
constexpr char const* dip·PixelSize·Get·dip·uint··C = "Returns the pixel size for the given dimension.";
constexpr char const* dip·PixelSize·operatorsqbra·dip·uint··C = "Returns the pixel size for the given dimension. Cannot be used to write to the\narray, see `Set`.";
constexpr char const* dip·PixelSize·Set·dip·uint··PhysicalQuantity· = "Sets the pixel size in the given dimension. Note that any subsequent\ndimension, if not explicitly set, will have the same size.";
constexpr char const* dip·PixelSize·Set·PhysicalQuantity·CL = "Sets the isotropic pixel size in all dimensions.";
constexpr char const* dip·PixelSize·Set·PhysicalQuantityArray·CL = "Sets a non-isotropic pixel size.";
constexpr char const* dip·PixelSize·SetNanometers·dip·uint··dip·dfloat· = "Sets the pixel size in the given dimension, in nanometers.";
constexpr char const* dip·PixelSize·SetNanometers·dip·dfloat· = "Sets the isotropic pixel size, in nanometers.";
constexpr char const* dip·PixelSize·SetMicrometers·dip·uint··dip·dfloat· = "Sets the pixel size in the given dimension, in micrometers.";
constexpr char const* dip·PixelSize·SetMicrometers·dip·dfloat· = "Sets the isotropic pixel size, in micrometers.";
constexpr char const* dip·PixelSize·SetMillimeters·dip·uint··dip·dfloat· = "Sets the pixel size in the given dimension, in millimeters.";
constexpr char const* dip·PixelSize·SetMillimeters·dip·dfloat· = "Sets the isotropic pixel size, in millimeters.";
constexpr char const* dip·PixelSize·SetMeters·dip·uint··dip·dfloat· = "Sets the pixel size in the given dimension, in meters.";
constexpr char const* dip·PixelSize·SetMeters·dip·dfloat· = "Sets the isotropic pixel size, in meters.";
constexpr char const* dip·PixelSize·SetKilometers·dip·uint··dip·dfloat· = "Sets the pixel size in the given dimension, in kilometers.";
constexpr char const* dip·PixelSize·SetKilometers·dip·dfloat· = "Sets the isotropic pixel size, in kilometers.";
constexpr char const* dip·PixelSize·Scale·dip·uint··dip·dfloat· = "Scales the pixel size in the given dimension, if it is defined.";
constexpr char const* dip·PixelSize·Scale·dip·dfloat· = "Scales the pixel size isotropically.";
constexpr char const* dip·PixelSize·Scale·FloatArray·CL = "Scales the pixel size non-isotropically in all dimensions, where defined.";
constexpr char const* dip·PixelSize·Invert·dip·uint· = "Inverts the pixel size in the given dimension, if it is defined.";
constexpr char const* dip·PixelSize·Invert = "Inverts the pixel size in all dimensions, where defined.";
constexpr char const* dip·PixelSize·SwapDimensions·dip·uint··dip·uint· = "Swaps two dimensions.";
constexpr char const* dip·PixelSize·Reverse·dip·uint· = "Reverses the dimensions, assuming that there are `d` dimensions.";
constexpr char const* dip·PixelSize·Permute·UnsignedArray·CL = "Permutes dimensions according to `order`, such that, after the call, `Get(ii)`\nreturns the value that `Get(order[ii])` returned before the call.";
constexpr char const* dip·PixelSize·InsertDimension·dip·uint··PhysicalQuantity· = "Inserts a dimension, undefined by default.";
constexpr char const* dip·PixelSize·EraseDimension·dip·uint· = "Erases a dimension";
constexpr char const* dip·PixelSize·Clear = "Clears the pixel sizes, reverting to the default undefined state.";
constexpr char const* dip·PixelSize·Size·C = "Returns the number of dimensions stored.";
constexpr char const* dip·PixelSize·Resize·dip·uint· = "Removes stored dimensions, keeping the first `d` dimensions only.";
constexpr char const* dip·PixelSize·IsIsotropic·C = "Tests the pixel size for isotropy (the pixel has the same size in all\ndimensions).";
constexpr char const* dip·PixelSize·AspectRatio·dip·uint··C = "Returns the aspect ratio of the first `d` dimensions, with respect to the\nfirst dimension. That is, the output array has `d` elements, where the first\none is 1.0. If units differ, the aspect ratio is 0 for that dimension.";
constexpr char const* dip·PixelSize·IsDefined·C = "Tests to see if the pixel size is defined.";
constexpr char const* dip·PixelSize·IsPhysical·C = "Tests to see if the pixel size is physical (i.e. has known physical units).";
constexpr char const* dip·PixelSize·SameUnits·C = "Tests to see if the units are the same (and physical) for all dimensions. Note\nthat the prefix";
constexpr char const* dip·PixelSize·Product·dip·uint··C = "Multiplies together the sizes for the first `d` dimensions.";
constexpr char const* dip·PixelSize·UnitLength·C = "Returns the scale and units to use for length measurements. Equal to the size\nof a pixel if it is isotropic, or 1 px otherwise.";
constexpr char const* dip·PixelSize·UnitSize·dip·uint··C = "Returns the scale and units to use for size (area/volume) measurements. Equal\nto the product of the pixel sizes if that product is physical, or 1 px^d^\notherwise.";
constexpr char const* dip·PixelSize·ForcePhysical = "Any dimension that is not a physical dimension will be set to 1 px.";
constexpr char const* dip·PixelSize·operatoreqeq·PixelSize·CL·C = "Compares two pixel sizes, magnitudes are compared with a 10^-6^ relative\ntolerance";
constexpr char const* dip·PixelSize·operatornoteq·PixelSize·CL·C = "Compares two pixel sizes, magnitudes are compared with a 10^-6^ relative\ntolerance";
constexpr char const* dip·PixelSize·ApproximatelyEquals·PixelSize·CL·dip·uint··double··C = "Compares two pixels for the first `nDims` dimensions, magnitudes are compared\nwith a relative tolerance of `tolerance`";
constexpr char const* dip·PixelSize·ToPixels·PhysicalQuantityArray·CL·C = "Converts physical units to pixels.";
constexpr char const* dip·PixelSize·ToPhysical·FloatArray·CL·C = "Converts pixels to meters.";
constexpr char const* dip·PixelSize·swap·PixelSize·L = "Swaps the values of `this` and `other`.";
constexpr char const* dip·operatorltlt·std·ostream·L·PixelSize·CL = "Writes the pixel sizes array to a stream";
constexpr char const* dip·SampleIterator·T = "An iterator to iterate over samples in a tensor, or pixels on an image line.";
constexpr char const* dip·SampleIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·SampleIterator·T·value_type = "The data type of the sample, obtained when dereferencing the iterator";
constexpr char const* dip·SampleIterator·T·difference_type = "The type of difference between iterators";
constexpr char const* dip·SampleIterator·T·reference = "The type of a reference to a sample";
constexpr char const* dip·SampleIterator·T·pointer = "The type of a pointer to a sample";
constexpr char const* dip·SampleIterator·T·SampleIterator = "Default constructor yields an invalid iterator that cannot be dereferenced";
constexpr char const* dip·SampleIterator·T·SampleIterator·pointer··dip·sint· = "To construct a useful iterator, provide a pointer and a stride";
constexpr char const* dip·SampleIterator·T·swap·SampleIteratorgtTlt·L = "Swap";
constexpr char const* dip·SampleIterator·T·operator_SampleIteratorltvalue_type_constgt·C = "Convert from non-const iterator to const iterator";
constexpr char const* dip·SampleIterator·T·operatortimes·C = "Dereference";
constexpr char const* dip·SampleIterator·T·operatorminusgt·C = "Dereference";
constexpr char const* dip·SampleIterator·T·operatorsqbra·T·I··C = "Index";
constexpr char const* dip·SampleIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·SampleIterator·T·operatorminus· = "Pre-decrement";
constexpr char const* dip·SampleIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·SampleIterator·T·operatorminus··int· = "Post-decrement";
constexpr char const* dip·SampleIterator·T·operatorpluseq·T·I· = "Add integer";
constexpr char const* dip·SampleIterator·T·operatorminuseq·T·I· = "Subtract integer";
constexpr char const* dip·SampleIterator·T·operatorminus·SampleIteratorgtTlt·CL·C = "Difference between iterators";
constexpr char const* dip·SampleIterator·T·operator_bool·C = "Test returns false if the iterator cannot be dereferenced (is a null pointer)";
constexpr char const* dip·SampleIterator·T·Stride·C = "Returns the stride";
constexpr char const* dip·SampleIterator·T·Pointer·C = "Returns the pointer";
constexpr char const* dip·SampleIterator·T·operatoreqeq·SampleIteratorgtTlt·CL·C = "Equality comparison";
constexpr char const* dip·SampleIterator·T·operatornoteq·SampleIteratorgtTlt·CL·C = "Inequality comparison";
constexpr char const* dip·SampleIterator·T·operatorgt·SampleIteratorgtTlt·CL·C = "Larger than comparison";
constexpr char const* dip·SampleIterator·T·operatorlt·SampleIteratorgtTlt·CL·C = "Smaller than comparison";
constexpr char const* dip·SampleIterator·T·operatorgteq·SampleIteratorgtTlt·CL·C = "Not smaller than comparison";
constexpr char const* dip·SampleIterator·T·operatorlteq·SampleIteratorgtTlt·CL·C = "Not larger than comparison";
constexpr char const* dip·operatorplus·T·SampleIteratorgtTlt··I· = "Add integer to a sample iterator";
constexpr char const* dip·operatorminus·T·SampleIteratorgtTlt··I· = "Subtract integer from a sample iterator";
constexpr char const* dip·ConstSampleIterator·T = "A const iterator to iterate over samples in a tensor, or pixels on an image\nline.";
constexpr char const* dip·Tensor = "Describes the shape of a tensor, but doesn't actually contain tensor data.";
constexpr char const* dip·Tensor·Shape = "Possible shapes the tensor can have.";
constexpr char const* dip·Tensor·Shape·COL_VECTOR = "a vector (stores n elements), default vector shape";
constexpr char const* dip·Tensor·Shape·ROW_VECTOR = "a row vector (stores n elements)";
constexpr char const* dip·Tensor·Shape·COL_MAJOR_MATRIX = "a matrix (stores n x m elements), default matrix shape";
constexpr char const* dip·Tensor·Shape·ROW_MAJOR_MATRIX = "a row-major matrix (stores n x m elements)";
constexpr char const* dip·Tensor·Shape·DIAGONAL_MATRIX = "a diagonal matrix (stores n elements)";
constexpr char const* dip·Tensor·Shape·SYMMETRIC_MATRIX = "a symmetric matrix (stores n(n+1)/2 elements)";
constexpr char const* dip·Tensor·Shape·UPPTRIANG_MATRIX = "an upper-triangular matrix (stores n(n+1)/2 elements)";
constexpr char const* dip·Tensor·Shape·LOWTRIANG_MATRIX = "a lower-triangular matrix (stores n(n+1)/2 elements)";
constexpr char const* dip·Tensor·Tensor = "Creates a `dip::Tensor::Shape::COL_VECTOR` with one element (scalar).";
constexpr char const* dip·Tensor·Tensor·dip·uint· = "Creates a `dip::Tensor::Shape::COL_VECTOR`.";
constexpr char const* dip·Tensor·Tensor·dip·uint··dip·uint· = "Creates a `dip::Tensor::Shape::COL_MAJOR_MATRIX`.";
constexpr char const* dip·Tensor·Tensor·Shape··dip·uint··dip·uint· = "Constructor for arbitrary shape.";
constexpr char const* dip·Tensor·Tensor·String·CL·dip·uint··dip·uint· = "Constructor for arbitrary shape.";
constexpr char const* dip·Tensor·IsScalar·C = "Tests the tensor shape.";
constexpr char const* dip·Tensor·IsVector·C = "Tests the tensor shape.";
constexpr char const* dip·Tensor·IsDiagonal·C = "Tests the tensor shape.";
constexpr char const* dip·Tensor·IsSymmetric·C = "Tests the tensor shape.";
constexpr char const* dip·Tensor·IsTriangular·C = "Tests the tensor shape.";
constexpr char const* dip·Tensor·IsSquare·C = "True if the matrix is square, independently from how it is stored.";
constexpr char const* dip·Tensor·TensorShape·C = "Returns tensor shape.";
constexpr char const* dip·Tensor·TensorShapeAsString·C = "Return a string representation of the tensor shape.";
constexpr char const* dip·Tensor·Elements·C = "Gets number of tensor elements.";
constexpr char const* dip·Tensor·Rows·C = "Gets number of tensor rows.";
constexpr char const* dip·Tensor·Columns·C = "Gets number of tensor columns.";
constexpr char const* dip·Tensor·Sizes·C = "Gets the tensor size.";
constexpr char const* dip·Tensor·operatoreqeq·Tensor·CL·C = "Compares tensor size and shape.";
constexpr char const* dip·Tensor·operatornoteq·Tensor·CL·C = "Compares tensor size and shape.";
constexpr char const* dip·Tensor·SetShape·Shape··dip·uint··dip·uint· = "Sets the tensor shape.";
constexpr char const* dip·Tensor·SetScalar = "Sets the tensor shape, results in a `dip::Tensor::Shape::COL_VECTOR` with one\nelement (scalar).";
constexpr char const* dip·Tensor·SetVector·dip·uint· = "Sets the tensor shape, results in a `dip::Tensor::Shape::COL_VECTOR`.";
constexpr char const* dip·Tensor·SetMatrix·dip·uint··dip·uint· = "Sets the tensor shape, results in a `dip::Tensor::Shape::COL_MAJOR_MATRIX`.";
constexpr char const* dip·Tensor·SetSizes·UnsignedArray·CL = "Sets the tensor size, always results in a `dip::Tensor::Shape::COL_VECTOR` or\n`dip::Tensor::Shape::COL_MAJOR_MATRIX`.";
constexpr char const* dip·Tensor·ChangeShape·dip·uint· = "Changes the tensor shape without changing the number of elements, results in a\n`dip::Tensor::Shape::COL_MAJOR_MATRIX`.";
constexpr char const* dip·Tensor·ChangeShape = "Changes the tensor shape without changing the number of elements, results in a\n`dip::Tensor::Shape::COL_VECTOR`.";
constexpr char const* dip·Tensor·ChangeShape·Tensor·CL = "Changes the tensor shape without changing the number of elements, resulting in\nthe shape described by `example`.";
constexpr char const* dip·Tensor·Transpose = "Transposes the tensor, causing a change of shape without a change of number of\nelements.";
constexpr char const* dip·Tensor·ExtractDiagonal·dip·sint·L = "Transforms the tensor such that it becomes a vector referencing the elements\nalong the diagonal. The value of `stride` is adjusted.";
constexpr char const* dip·Tensor·ExtractRow·dip·uint··dip·sint·L = "Transforms the tensor such that it becomes a vector referencing the elements\nalong the given row. The value of `stride` is adjusted. The tensor\nrepresentation must be full (i.e. no symmetric or triangular matrices).";
constexpr char const* dip·Tensor·ExtractColumn·dip·uint··dip·sint·L = "Transforms the tensor such that it becomes a vector referencing the elements\nalong the given column. The value of `stride` is adjusted. The tensor\nrepresentation must be full (i.e. no symmetric or triangular matrices).";
constexpr char const* dip·Tensor·HasNormalOrder·C = "Returns true for tensors that are stored in column-major order (all vectors\nand non-transposed full tensors).";
constexpr char const* dip·Tensor·Index·UnsignedArray·CL·C = "Returns the linear index corresponding to the given tensor indices.";
constexpr char const* dip·Tensor·LookUpTable·C = "Returns a look-up table that you can use to find specific tensor elements.";
constexpr char const* dip·Tensor·swap·Tensor·L = "Swaps the contents of `this` and `other`.";
constexpr char const* dip·Tensor·ShapeToString·Shape· = "Return a string representation of a tensor shape";
constexpr char const* dip·Tensor·ShapeFromString·String·CL = "Retrieve a tensor shape from a string representation of the tensor shape";
constexpr char const* dip·operatorltlt·std·ostream·L·Tensor·CL = "Prints information about the tensor.";
constexpr char const* dip·sint = "An integer type to be used for strides and similar measures.";
constexpr char const* dip·uint = "An integer type to be used for sizes and the like.";
constexpr char const* dip·uint8 = "Type for samples in an 8-bit unsigned integer image; also to be used as single\nbyte for pointer arithmetic";
constexpr char const* dip·uint16 = "Type for samples in a 16-bit unsigned integer image";
constexpr char const* dip·uint32 = "Type for samples in a 32-bit unsigned integer image";
constexpr char const* dip·uint64 = "Type for samples in a 64-bit unsigned integer image";
constexpr char const* dip·sint8 = "Type for samples in an 8-bit signed integer image";
constexpr char const* dip·sint16 = "Type for samples in a 16-bit signed integer image";
constexpr char const* dip·sint32 = "Type for samples in a 32-bit signed integer image";
constexpr char const* dip·sint64 = "Type for samples in a 64-bit signed integer image";
constexpr char const* dip·sfloat = "Type for samples in a 32-bit floating point (single-precision) image";
constexpr char const* dip·dfloat = "Type for samples in a 64-bit floating point (double-precision) image";
constexpr char const* dip·scomplex = "Type for samples in a 64-bit complex-valued (single-precision) image";
constexpr char const* dip·dcomplex = "Type for samples in a 128-bit complex-valued (double-precision) image";
constexpr char const* dip·LabelType = "Type currently used for all labeled images, see `dip::DT_LABEL`.";
constexpr char const* dip·CastLabelType·T·TPI· = "Casting any unsigned integer type to `dip::LabelType`. Throws if `value` is\ntoo large.";
constexpr char const* dip·IsSampleType·T = "For use with `std::enable_if` to enable templates only for types that are\nvalid for image samples.";
constexpr char const* dip·IsNumericType·T = "For use with `std::enable_if` to enable templates only for types that are\nnumeric types, similar to `std::is_arithmetic` but also true for complex\ntypes. See `dip::IsSampleType` for usage details.";
constexpr char const* dip·IsIndexingType·T = "For use with `std::enable_if` to enable templates only for types that are\nindexing types, true for signed and unsigned integers. See `dip::IsSampleType`\nfor usage details.";
constexpr char const* dip·PixelIsInfinity·T·TPI· = "A templated function to check for positive infinity, which works also for\ninteger types (always returning false)";
constexpr char const* dip·PixelIsMinusInfinity·T·TPI· = "A templated function to check for negative infinity, which works also for\ninteger types (always returning false)";
constexpr char const* dip·bin = "Type for samples in a binary image. Can store 0 or 1. Occupies 1 byte.";
constexpr char const* dip·bin·bin = "The default value is 0 (false)";
constexpr char const* dip·bin·bin·bool· = "A bool implicitly converts to bin";
constexpr char const* dip·bin·bin·T·T· = "Any arithmetic type converts to bin by comparing to zero";
constexpr char const* dip·bin·operator_bool·C = "A bin implicitly converts to bool";
constexpr char const* dip·bin·operatornot·C = "Negation operator";
constexpr char const* dip·bin·operatorneg·C = "Bit-wise negation is the same as regular negation";
constexpr char const* dip·bin·operatorand·bin··C = "And operator, prefer to use this over `std::min`";
constexpr char const* dip·bin·operatoror·bin··C = "Or operator, prefer to use this over `std::max`";
constexpr char const* dip·bin·operatorxor·bin··C = "Exclusive-or operator";
constexpr char const* dip·bin·operatorandeq·bin· = "And compound operator";
constexpr char const* dip·bin·operatororeq·bin· = "Or compound operator";
constexpr char const* dip·bin·operatorxoreq·bin· = "Exclusive-or compound operator";
constexpr char const* dip·bin·operatoreqeq·T·T··C = "Equality operator";
constexpr char const* dip·bin·operatornoteq·T·T··C = "Inequality operator";
constexpr char const* dip·bin·operator_uint8and = "Allow explicit casting to a reference to the underlying type (uint8&) for\nbinary image operations";
constexpr char const* dip·operatorltlt·std·ostream·L·bin·CL = "Writes the value as a `bool` to a stream.";
constexpr char const* dip·FloatType·T = "The type to use in calculations when a floating-point type is needed. Matches\n`dip::DataType::SuggestFloat`.";
constexpr char const* dip·DoubleType·T = "The double precision floating point type (real or complex) to use when\ncomputing large sums of any input type. Matches\n`dip::DataType::SuggestDouble`.";
constexpr char const* dip·ComplexType·T = "The type to use in calculations when a complex type is needed. Matches\n`dip::DataType::SuggestComplex`.";
constexpr char const* dip·FlexType·T = "The type to use in calculations. Matches `dip::DataType::SuggestFlex`.";
constexpr char const* dip·FlexBinType·T = "The type to use in calculations. Matches `dip::DataType::SuggestFlexBin`.";
constexpr char const* dip·AbsType·T = "The type to use for the output of abs operations. Matches\n`dip::DataType::SuggestAbs`.";
constexpr char const* dip·RealType·T = "The type to use in calculations when a real-valued type is needed. Matches\n`dip::DataType::SuggestReal`.";
constexpr char const* dip·IntegerArray = "An array to hold strides, filter sizes, etc.";
constexpr char const* dip·UnsignedArray = "An array to hold dimensions, dimension lists, etc.";
constexpr char const* dip·FloatArray = "An array to hold filter parameters.";
constexpr char const* dip·BooleanArray = "An array used as a dimension selector.";
constexpr char const* dip·CoordinateArray = "An array of pixel coordinates.";
constexpr char const* dip·FloatCoordinateArray = "An array of subpixel coordinates.";
constexpr char const* dip·ArrayUseParameter·T·DimensionArraygtTlt·L·dip·uint··T· = "Check the length of an array, and extend it if necessary and possible.";
constexpr char const* dip·String = "A string, used to specify an option";
constexpr char const* dip·StringArray = "An array of strings, used to specify an option per dimension";
constexpr char const* dip·StringSet = "A collection of strings, used to specify multiple independent options";
constexpr char const* dip·BooleanFromString·String·CL·String·CL·String·CL = "Translates a string input parameter that is meant as a boolean value.";
constexpr char const* dip·StringCompareCaseInsensitive·String·CL·String·CL = "A case-insensitive string comparison, use only with ASCII characters!";
constexpr char const* dip·ToLowerCase·String·L = "Convert a string to lower case, use only with ASCII characters!";
constexpr char const* dip·ToUpperCase·String·L = "Convert a string to upper case, use only with ASCII characters!";
constexpr char const* dip·Range = "Used in indexing to indicate a regular subset of pixels along one image\ndimension.";
constexpr char const* dip·Range·start = "First index included in range";
constexpr char const* dip·Range·stop = "Last index included in range";
constexpr char const* dip·Range·step = "Step size when going from start to stop";
constexpr char const* dip·Range·Range = "Create a range that indicates all pixels";
constexpr char const* dip·Range·Range·dip·sint· = "Create a range that indicates a single pixel";
constexpr char const* dip·Range·Range·dip·sint··dip·sint··dip·uint· = "Create a range using two or three values; it indicates all pixels between `i`\nand `j`, both inclusive. The step size defaults to 1.";
constexpr char const* dip·Range·Fix·dip·uint· = "Modify a range so that negative values are assigned correct values according\nto the given size. Throws if the range falls out of bounds.";
constexpr char const* dip·Range·Size·C = "Get the number of pixels addressed by the range (must be fixed first!).";
constexpr char const* dip·Range·Offset·C = "Get the offset for the range (must be fixed first!).";
constexpr char const* dip·Range·Last·C = "Get the last index in the range (must be fixed first!).";
constexpr char const* dip·Range·Step·C = "Get the signed step size for the range (must be fixed first!).";
constexpr char const* dip·Range·Iterator = "An iterator for the range";
constexpr char const* dip·Range·Iterator·iterator_category = "Iterator category";
constexpr char const* dip·Range·Iterator·value_type = "Type of value iterator references";
constexpr char const* dip·Range·Iterator·reference = "Type of reference to value";
constexpr char const* dip·Range·Iterator·pointer = "Type of pointer to value";
constexpr char const* dip·Range·Iterator·Iterator = "Default constructor";
constexpr char const* dip·Range·Iterator·Iterator·dip·uint··dip·sint· = "Constructor";
constexpr char const* dip·Range·Iterator·operatortimes·C = "Dereference";
constexpr char const* dip·Range·Iterator·operatorminusgt·C = "Dereference";
constexpr char const* dip·Range·Iterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·Range·Iterator·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·Range·Iterator·operatoreqeq·Iterator·CL·C = "Equality comparison";
constexpr char const* dip·Range·Iterator·operatornoteq·Iterator·CL·C = "Inequality comparison";
constexpr char const* dip·Range·begin·C = "Get an iterator to the beginning of the range (must be fixed first!).";
constexpr char const* dip·Range·end·C = "Get an iterator to the end of the range (must be fixed first!). This iterator\npoints one past the `stop` value, as is usual for the end iterator.";
constexpr char const* dip·operatorltlt·std·ostream·L·Range·CL = "Display a range as \"{start, stop, step}\".";
constexpr char const* dip·RangeArray = "An array of ranges";
constexpr char const* dip·RegressionParameters = "Represents the result of a 2D regression analysis: $y = a + bx$.";
constexpr char const* dip·RegressionParameters·intercept = "intercept, $a$.";
constexpr char const* dip·RegressionParameters·slope = "slope, $b$.";
constexpr char const* dip·QuartilesResult = "Represents the quartiles, see `dip::Quartiles`.";
constexpr char const* dip·QuartilesResult·minimum = "Minimum (0^th^ percentile).";
constexpr char const* dip·QuartilesResult·lowerQuartile = "Lower or first quartile (25^th^ percentile).";
constexpr char const* dip·QuartilesResult·median = "Median or second quartile (50^th^ percentile).";
constexpr char const* dip·QuartilesResult·upperQuartile = "Upper or third quartile (75^th^ percentile).";
constexpr char const* dip·QuartilesResult·maximum = "Maximum (100^th^ percentile).";
constexpr char const* dip·AlignedBuffer = "A container used to allocate 32-byte aligned buffers.";
constexpr char const* dip·AlignedBuffer·AlignedBuffer = "A default-initialized buffer is empty.";
constexpr char const* dip·AlignedBuffer·AlignedBuffer·dip·uint· = "A buffer of size `size`, uninitialized.";
constexpr char const* dip·AlignedBuffer·resize·dip·uint· = "Change the size of the buffer to `size`. Data is not preserved.";
constexpr char const* dip·AlignedBuffer·clear = "Free the buffer's memory.";
constexpr char const* dip·AlignedBuffer·empty·C = "True if the buffer is empty (its size is zero).";
constexpr char const* dip·AlignedBuffer·size·C = "Returns  the size of the buffer.";
constexpr char const* dip·AlignedBuffer·data = "Returns a pointer to the first byte of the buffer.";
constexpr char const* dip·AlignedBuffer·data·C = "Returns a pointer to the first byte of the buffer.";
constexpr char const* dip·StatisticsAccumulator = "`StatisticsAccumulator` computes population statistics by accumulating the\nfirst four central moments.";
constexpr char const* dip·StatisticsAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·StatisticsAccumulator·Push·dfloat· = "Add a sample to the accumulator";
constexpr char const* dip·StatisticsAccumulator·operatorpluseq·StatisticsAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·StatisticsAccumulator·Number·C = "Number of samples";
constexpr char const* dip·StatisticsAccumulator·Mean·C = "Unbiased estimator of population mean";
constexpr char const* dip·StatisticsAccumulator·Variance·C = "Unbiased estimator of population variance";
constexpr char const* dip·StatisticsAccumulator·StandardDeviation·C = "Estimator of population standard deviation (it is not possible to derive an\nunbiased estimator)";
constexpr char const* dip·StatisticsAccumulator·Skewness·C = "Estimator of population skewness. This estimator is unbiased only for\nsymmetric distributions (it is not possible to derive an unbiased estimator).";
constexpr char const* dip·StatisticsAccumulator·ExcessKurtosis·C = "Estimator of population excess kurtosis. This estimator is only unbiased for\nnormally distributed data (it is not possible to derive an unbiased\nestimator).";
constexpr char const* dip·operatorplus·StatisticsAccumulator··StatisticsAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·VarianceAccumulator = "`VarianceAccumulator` computes mean and standard deviation by accumulating the\nfirst two central moments.";
constexpr char const* dip·VarianceAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·VarianceAccumulator·Push·dfloat· = "Add a sample to the accumulator";
constexpr char const* dip·VarianceAccumulator·Pop·dfloat· = "Remove a sample from the accumulator";
constexpr char const* dip·VarianceAccumulator·operatorpluseq·VarianceAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·VarianceAccumulator·Number·C = "Number of samples";
constexpr char const* dip·VarianceAccumulator·Mean·C = "Unbiased estimator of population mean";
constexpr char const* dip·VarianceAccumulator·Variance·C = "Unbiased estimator of population variance";
constexpr char const* dip·VarianceAccumulator·StandardDeviation·C = "Estimator of population standard deviation (it is not possible to derive an\nunbiased estimator)";
constexpr char const* dip·operatorplus·VarianceAccumulator··VarianceAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·FastVarianceAccumulator = "`FastVarianceAccumulator` computes mean and standard deviation by accumulating\nthe sum of sample values and the sum of the square of sample values.";
constexpr char const* dip·FastVarianceAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·FastVarianceAccumulator·Push·dfloat· = "Add a sample to the accumulator";
constexpr char const* dip·FastVarianceAccumulator·Pop·dfloat· = "Remove a sample from the accumulator";
constexpr char const* dip·FastVarianceAccumulator·operatorpluseq·FastVarianceAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·FastVarianceAccumulator·Number·C = "Number of samples";
constexpr char const* dip·FastVarianceAccumulator·Mean·C = "Unbiased estimator of population mean";
constexpr char const* dip·FastVarianceAccumulator·Variance·C = "Unbiased estimator of population variance";
constexpr char const* dip·FastVarianceAccumulator·StandardDeviation·C = "Estimator of population standard deviation (it is not possible to derive an\nunbiased estimator)";
constexpr char const* dip·operatorplus·FastVarianceAccumulator··FastVarianceAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·CovarianceAccumulator = "`CovarianceAccumulator` computes covariance and correlation of pairs of\nsamples by accumulating the first two central moments and cross-moments.";
constexpr char const* dip·CovarianceAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·CovarianceAccumulator·Push·dfloat··dfloat· = "Add a pair of samples to the accumulator";
constexpr char const* dip·CovarianceAccumulator·operatorpluseq·CovarianceAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·CovarianceAccumulator·Number·C = "Number of samples";
constexpr char const* dip·CovarianceAccumulator·MeanX·C = "Unbiased estimator of population mean for first variable";
constexpr char const* dip·CovarianceAccumulator·MeanY·C = "Unbiased estimator of population mean for second variable";
constexpr char const* dip·CovarianceAccumulator·VarianceX·C = "Unbiased estimator of population variance for first variable";
constexpr char const* dip·CovarianceAccumulator·VarianceY·C = "Unbiased estimator of population variance for second variable";
constexpr char const* dip·CovarianceAccumulator·StandardDeviationX·C = "Estimator of population standard deviation for first variable (it is not\npossible to derive an unbiased estimator)";
constexpr char const* dip·CovarianceAccumulator·StandardDeviationY·C = "Estimator of population standard deviation for second variable (it is not\npossible to derive an unbiased estimator)";
constexpr char const* dip·CovarianceAccumulator·Covariance·C = "Unbiased estimator of population covariance";
constexpr char const* dip·CovarianceAccumulator·Correlation·C = "Estimator of correlation between the two variables";
constexpr char const* dip·CovarianceAccumulator·Slope·C = "Computes the slope of the regression line";
constexpr char const* dip·CovarianceAccumulator·RegressionResult = "Copying type for backward compatibility.";
constexpr char const* dip·CovarianceAccumulator·Regression·C = "Computes the slope and intercept of the regression line";
constexpr char const* dip·DirectionalStatisticsAccumulator = "`DirectionalStatisticsAccumulator` computes directional mean and standard\ndeviation by accumulating a unit vector with the input value as angle.";
constexpr char const* dip·DirectionalStatisticsAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·DirectionalStatisticsAccumulator·Push·dfloat· = "Add a sample to the accumulator";
constexpr char const* dip·DirectionalStatisticsAccumulator·operatorpluseq·DirectionalStatisticsAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·DirectionalStatisticsAccumulator·Number·C = "Number of samples";
constexpr char const* dip·DirectionalStatisticsAccumulator·Mean·C = "Unbiased estimator of population mean";
constexpr char const* dip·DirectionalStatisticsAccumulator·Variance·C = "Unbiased estimator of population variance";
constexpr char const* dip·DirectionalStatisticsAccumulator·StandardDeviation·C = "Estimator of population standard deviation (it is not possible to derive an\nunbiased estimator)";
constexpr char const* dip·operatorplus·DirectionalStatisticsAccumulator··DirectionalStatisticsAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·MinMaxAccumulator = "`MinMaxAccumulator` computes minimum and maximum values of a sequence of\nvalues.";
constexpr char const* dip·MinMaxAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·MinMaxAccumulator·Push·dfloat· = "Add a sample to the accumulator";
constexpr char const* dip·MinMaxAccumulator·Push·dfloat··dfloat· = "Add two samples to the accumulator. Prefer this over adding one value at the\ntime.";
constexpr char const* dip·MinMaxAccumulator·operatorpluseq·MinMaxAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·MinMaxAccumulator·Minimum·C = "Minimum value seen so far";
constexpr char const* dip·MinMaxAccumulator·Maximum·C = "Maximum value seen so far";
constexpr char const* dip·operatorplus·MinMaxAccumulator··MinMaxAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·MomentAccumulator = "`MomentAccumulator` accumulates the zeroth order moment, the first order\nnormalized moments, and the second order normalized central moments, in `N`\ndimensions.";
constexpr char const* dip·MomentAccumulator·MomentAccumulator·dip·uint· = "The constructor determines the dimensionality for the object.";
constexpr char const* dip·MomentAccumulator·Reset = "Reset the accumulator, leaving it as if newly allocated.";
constexpr char const* dip·MomentAccumulator·Push·FloatArray·CL·dfloat· = "Add a sample to the accumulator. `pos` must have `N` dimensions.";
constexpr char const* dip·MomentAccumulator·operatorpluseq·MomentAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·MomentAccumulator·Sum·C = "Sum of weights (zeroth order moment)";
constexpr char const* dip·MomentAccumulator·FirstOrder·C = "First order moments, normalized";
constexpr char const* dip·MomentAccumulator·SecondOrder·C = "Second order central moment tensor, normalized";
constexpr char const* dip·MomentAccumulator·PlainSecondOrder·C = "Plain second order central moments, normalized";
constexpr char const* dip·operatorplus·MomentAccumulator··MomentAccumulator·CL = "Combine two accumulators";
constexpr char const* dip·Find·Image·CL·Image·CL = "Finds the coordinates for all non-zero pixels in the scalar image `in`,\noptionally constrained to the pixels selected by `mask`.";
constexpr char const* dip·SubpixelLocationResult = "Contains the result of the function `dip::SubpixelLocation`.";
constexpr char const* dip·SubpixelLocationResult·coordinates = "Coordinates of local extremum";
constexpr char const* dip·SubpixelLocationResult·value = "Interpolated value at local extremum";
constexpr char const* dip·SubpixelLocationArray = "Contains the result of the functions `dip::SubpixelMaxima` and\n`dip::SubpixelMinima`.";
constexpr char const* dip·SubpixelLocation·Image·CL·UnsignedArray·CL·String·CL·String·CL = "Gets coordinates of a local extremum with sub-pixel precision";
constexpr char const* dip·SubpixelMaxima·Image·CL·Image·CL·String·CL = "Gets coordinates of local maxima with sub-pixel precision";
constexpr char const* dip·SubpixelMinima·Image·CL·Image·CL·String·CL = "Gets coordinates of local minima with sub-pixel precision";
constexpr char const* dip·MeanShift·Image·CL·FloatArray·CL·dfloat· = "Finds the coordinates of a local maximum close to `start`";
constexpr char const* dip·MeanShift·Image·CL·FloatCoordinateArray·CL·dfloat· = "Finds the coordinates of local a maximum close to each point in `startArray`.";
constexpr char const* dip·GaussianMixtureModel·Image·CL·Image·L·dip·uint··dip·uint··dip·uint··StringSet·CL = "Determines the parameters for a Gaussian Mixture Model for every line in the\nimage.";
constexpr char const* dip·CrossCorrelationFT·Image·CL·Image·CL·Image·L·String·CL·String·CL·String·CL·String·CL = "Calculates the cross-correlation between two images of equal size.";
constexpr char const* dip·AutoCorrelationFT·Image·CL·Image·L·String·CL·String·CL = "Computes the auto-correlation function.";
constexpr char const* dip·FindShift·Image·CL·Image·CL·String·CL·dfloat··UnsignedArray· = "Estimates the (sub-pixel) global shift between `in1` and `in2`.";
constexpr char const* dip·FourierMellinMatch2D·Image·CL·Image·CL·Image·L·String·CL·String·CL = "Finds the scaling, translation and rotation between two 2D images using the\nFourier Mellin transform";
constexpr char const* dip·StructureTensor·Image·CL·Image·CL·Image·L·FloatArray·CL·FloatArray·CL·String·CL·StringArray·CL·dfloat· = "Computes the structure tensor.";
constexpr char const* dip·StructureTensorAnalysis2D·Image·CL·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P = "Computes useful image parameters from the 2D structure tensor.";
constexpr char const* dip·StructureTensorAnalysis3D·Image·CL·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P·Image·P = "Computes useful image parameters from the 3D structure tensor.";
constexpr char const* dip·StructureTensorAnalysis·Image·CL·ImageRefArray·L·StringArray·CL = "Interface to `dip::StructureTensorAnalysis2D` and\n`dip::StructureTensorAnalysis3D`.";
constexpr char const* dip·StructureAnalysis·Image·CL·Image·CL·std·vectorgtdfloatlt·CL·String·CL·FloatArray·CL·String·CL·StringArray·CL·dfloat· = "Analyzes the local structure of the image at multiple scales.";
constexpr char const* dip·MonogenicSignal·Image·CL·Image·L·FloatArray·CL·dfloat··String·CL·String·CL = "Computes the monogenic signal, a multi-dimensional generalization of the\nanalytic signal.";
constexpr char const* dip·MonogenicSignalAnalysis·Image·CL·ImageRefArray·L·StringArray·CL·dfloat··dfloat··dfloat··dfloat··String·CL = "Computes useful image parameters from the monogenic signal.";
constexpr char const* dip·OrientationSpace·Image·CL·Image·L·dip·uint··dfloat··dfloat··dip·uint· = "Creates an orientation space for a 2D image";
constexpr char const* dip·PairCorrelation·Image·CL·Image·CL·Random·L·dip·uint··dip·uint··String·CL·StringSet·CL = "Estimates the pair correlation function of the different phases in `object`.";
constexpr char const* dip·PairCorrelation·Image·CL·Image·CL·dip·uint··dip·uint··String·CL·StringSet·CL = "like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·ProbabilisticPairCorrelation·Image·CL·Image·CL·Random·L·dip·uint··dip·uint··String·CL·StringSet·CL = "Estimates the probabilistic pair correlation function of the different phases\nin `phases`.";
constexpr char const* dip·ProbabilisticPairCorrelation·Image·CL·Image·CL·dip·uint··dip·uint··String·CL·StringSet·CL = "like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·Semivariogram·Image·CL·Image·CL·Random·L·dip·uint··dip·uint··String·CL = "Estimates the expected value of half the square difference between field\nvalues at a distance `d`.";
constexpr char const* dip·Semivariogram·Image·CL·Image·CL·dip·uint··dip·uint··String·CL = "like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·ChordLength·Image·CL·Image·CL·Random·L·dip·uint··dip·uint··String·CL = "Estimates the chord length distribution of the different phases in `object`.";
constexpr char const* dip·ChordLength·Image·CL·Image·CL·dip·uint··dip·uint··String·CL = "like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·DistanceDistribution·Image·CL·Image·CL·dip·uint· = "Computes the distribution of distances to the background of `region` for the\ndifferent phases in `object`.";
constexpr char const* dip·Granulometry·Image·CL·Image·CL·std·vectorgtdfloatlt·CL·String·CL·String·CL·StringSet·CL = "Computes the granulometric function for an image";
constexpr char const* dip·FractalDimension·Image·CL·dfloat· = "Estimates the fractal dimension of the binary image `in` the sliding box\nmethod.";
constexpr char const* dip·BinaryDilation·Image·CL·Image·L·dip·sint··dip·uint··String·CL = "Binary morphological dilation operation.";
constexpr char const* dip·BinaryErosion·Image·CL·Image·L·dip·sint··dip·uint··String·CL = "Binary morphological erosion operation.";
constexpr char const* dip·BinaryClosing·Image·CL·Image·L·dip·sint··dip·uint··String·CL = "Binary morphological closing operation.";
constexpr char const* dip·BinaryOpening·Image·CL·Image·L·dip·sint··dip·uint··String·CL = "Binary morphological opening operation.";
constexpr char const* dip·IsotropicDilation·Image·CL·Image·L·dfloat· = "Isotropic dilation of binary image.";
constexpr char const* dip·IsotropicErosion·Image·CL·Image·L·dfloat· = "Isotropic erosion of binary image.";
constexpr char const* dip·IsotropicClosing·Image·CL·Image·L·dfloat· = "Isotropic closing of binary image.";
constexpr char const* dip·IsotropicOpening·Image·CL·Image·L·dfloat· = "Isotropic opening of binary image.";
constexpr char const* dip·BinaryPropagation·Image·CL·Image·CL·Image·L·dip·sint··dip·uint··String·CL = "Morphological propagation of binary objects.";
constexpr char const* dip·EdgeObjectsRemove·Image·CL·Image·L·dip·uint· = "Remove edge objects from a binary or labeled image.";
constexpr char const* dip·FillHoles·Image·CL·Image·L·dip·uint· = "Fill holes in binary image.";
constexpr char const* dip·ConditionalThickening2D·Image·CL·Image·CL·Image·L·dip·uint··String·CL·String·CL = "Thickens the image `in` conditioned on the mask (2D only).";
constexpr char const* dip·ConditionalThinning2D·Image·CL·Image·CL·Image·L·dip·uint··String·CL·String·CL = "Thins the image `in` conditioned on the mask (2D only).";
constexpr char const* dip·BinaryAreaOpening·Image·CL·Image·L·dip·uint··dip·uint··String·CL = "Computes the area opening of a binary image";
constexpr char const* dip·BinaryAreaClosing·Image·CL·Image·L·dip·uint··dip·uint··String·CL = "Computes the area closing of a binary image, by calling\n`dip::BinaryAreaOpening` on the inverse of the input image.";
constexpr char const* dip·EuclideanSkeleton·Image·CL·Image·L·String·CL·String·CL = "Accurate binary skeleton (2D and 3D only).";
constexpr char const* dip·CountNeighbors·Image·CL·Image·L·dip·uint··dip·String·CL·dip·String·CL = "Counts the number of set neighbors for each pixel in the binary image `in`.";
constexpr char const* dip·MajorityVote·Image·CL·Image·L·dip·uint··dip·String·CL = "Filters the binary image by setting each pixel to the phase with more pixels\nin the neighborhood.";
constexpr char const* dip·GetSinglePixels·Image·CL·Image·L·dip·uint··dip·String·CL = "Returns the isolated pixels in the binary image `in`. That is, the set pixels\nwith zero neighbors. See `dip::CountNeighbors`.";
constexpr char const* dip·GetEndPixels·Image·CL·Image·L·dip·uint··dip·String·CL = "Returns the end pixels in the skeleton image `in`. That is, the set pixels\nwith one neighbor. See `dip::CountNeighbors`.";
constexpr char const* dip·GetLinkPixels·Image·CL·Image·L·dip·uint··dip·String·CL = "Returns the link pixels in the skeleton image `in`. That is, the set pixels\nwith two neighbors. See `dip::CountNeighbors`.";
constexpr char const* dip·GetBranchPixels·Image·CL·Image·L·dip·uint··dip·String·CL = "Returns the branch pixels in the skeleton image `in`. That is, the set pixels\nwith more than two neighbors. See `dip::CountNeighbors`.";
constexpr char const* dip·IntervalArray = "An array of intervals.";
constexpr char const* dip·Interval = "Represents the shape of an interval for inf-generating and sup-generating\noperators.";
constexpr char const* dip·Interval·Interval·dip·Image· = "An interval can be constructed with a grey-value image, where `1` indicates\nforeground, `0` indicates background, and any other value indicates \"don't\ncare\" pixels.";
constexpr char const* dip·Interval·Interval·dip·Image··dip·Image· = "An interval can be constructed with two binary images, one for the foreground\nmask and one for the background mask.";
constexpr char const* dip·Interval·Invert = "Inverts the interval, swapping foreground and background pixels. Caution using\nthis function, as the `Interval` can potentially share data with other\nintervals.";
constexpr char const* dip·Interval·Image·C = "Returns the interval image, a `dip::DT_SFLOAT` image with values 0, 1 and NaN\n(for don't care).";
constexpr char const* dip·Interval·HitImage·C = "Returns the foreground mask image, a binary image.";
constexpr char const* dip·Interval·MissImage·C = "Returns the background mask image, a binary image.";
constexpr char const* dip·Interval·Sizes·C = "Returns the sizes of the interval. The output array always has two elements.";
constexpr char const* dip·Interval·GenerateRotatedVersions·dip·uint··String·CL·C = "Returns rotated versions of the interval, applicable to 2D intervals only.";
constexpr char const* dip·Invert·IntervalArray·L = "Inverts the intervals in the array, swapping foreground and background pixels.\nWorks correctly if intervals in the array share data. However, this function\ncould also affect other intervals not in the array, if data is shared.";
constexpr char const* dip·SupGenerating·Image·CL·Image·L·Interval·CL·String·CL = "Sup-generating operator, also known as hit-miss operator.";
constexpr char const* dip·InfGenerating·Image·CL·Image·L·Interval·CL·String·CL = "Inf-generating operator, the dual of the hit-miss operator.";
constexpr char const* dip·UnionSupGenerating·Image·CL·Image·L·IntervalArray·CL·String·CL = "Union of sup-generating operators.";
constexpr char const* dip·UnionSupGenerating2D·Image·CL·Image·L·Interval·CL·dip·uint··String·CL·String·CL = "Union of sup-generating operators.";
constexpr char const* dip·IntersectionInfGenerating·Image·CL·Image·L·IntervalArray·CL·String·CL = "Intersection of inf-generating operators.";
constexpr char const* dip·IntersectionInfGenerating2D·Image·CL·Image·L·Interval·CL·dip·uint··String·CL·String·CL = "Intersection of inf-generating operators.";
constexpr char const* dip·Thickening·Image·CL·Image·CL·Image·L·IntervalArray·CL·dip·uint··String·CL = "Applies the thickening operator, optionally constrained by a mask, to an\nimage.";
constexpr char const* dip·Thickening2D·Image·CL·Image·CL·Image·L·Interval·CL·dip·uint··dip·uint··String·CL·String·CL = "Applies the thickening operator, optionally constrained by a mask, to an\nimage.";
constexpr char const* dip·Thinning·Image·CL·Image·CL·Image·L·IntervalArray·CL·dip·uint··String·CL = "Applies the thinning operator, optionally constrained by a mask, to an image.";
constexpr char const* dip·Thinning2D·Image·CL·Image·CL·Image·L·Interval·CL·dip·uint··dip·uint··String·CL·String·CL = "Applies the thinning operator, optionally constrained by a mask, to an image.";
constexpr char const* dip·HomotopicThinningInterval2D·dip·uint· = "Returns a 2D interval array for homotopic thinning.";
constexpr char const* dip·HomotopicThickeningInterval2D·dip·uint· = "Returns a 2D interval array for homotopic thickening.";
constexpr char const* dip·EndPixelInterval2D·dip·uint· = "Returns an interval array for detecting end pixels. Includes isolated pixels.";
constexpr char const* dip·HomotopicEndPixelInterval2D·dip·uint· = "Returns an interval array for detecting end pixels. Excludes isolated pixels";
constexpr char const* dip·HomotopicInverseEndPixelInterval2D·dip·uint· = "Returns an interval array for detecting end background pixels. Excludes\nisolated pixels.";
constexpr char const* dip·SinglePixelInterval·dip·uint· = "Returns an interval for detecting single pixels. Use with `dip::SupGenerating`\nto detect isolated pixels. Note that `dip::GetSinglePixels` is more efficient.";
constexpr char const* dip·BranchPixelInterval2D = "Returns a 2D interval array for detecting branch pixels.";
constexpr char const* dip·BoundaryPixelInterval2D = "Returns a 2D interval for detecting boundary pixels.";
constexpr char const* dip·ConvexHullInterval2D = "Returns a 2D interval array to thicken to a convex hull.";
constexpr char const* dip·BoundaryConditionArray = "An array to hold boundary conditions.";
constexpr char const* dip·StringToBoundaryCondition·String·CL = "Convert a string to a boundary condition.";
constexpr char const* dip·StringArrayToBoundaryConditionArray·StringArray·CL = "Convert an array of strings to an array of boundary conditions.";
constexpr char const* dip·BoundaryArrayUseParameter·BoundaryConditionArray·L·dip·uint· = "Check the length of a `BoundaryConditionArray`, and extend it if necessary and\npossible.";
constexpr char const* dip·ReadPixelWithBoundaryCondition·Image·CL·IntegerArray··BoundaryConditionArray·CL = "Returns a pixel with a copy of the sample values at `coords`.";
constexpr char const* dip·ExtendImage·Image·CL·Image·L·UnsignedArray··BoundaryConditionArray··Option·ExtendImageFlags· = "Extends the image `in` by `borderSizes` along each dimension.";
constexpr char const* dip·ExtendImage·Image·CL·Image·L·UnsignedArray··StringArray·CL·StringSet·CL = "Extends the image `in` by `borderSizes` along each dimension.";
constexpr char const* dip·ExtendImageToSize·Image·CL·Image·L·UnsignedArray·CL·Option·CropLocation··BoundaryConditionArray··Option·ExtendImageFlags· = "Extends the image `in` to `sizes`.";
constexpr char const* dip·ExtendImageToSize·Image·CL·Image·L·UnsignedArray·CL·String·CL·StringArray·CL·StringSet·CL = "Extends the image `in` to `sizes`.";
constexpr char const* dip·ExtendRegion·Image·L·RangeArray··BoundaryConditionArray· = "Fills the pixels outside a region in the image using a boundary condition.";
constexpr char const* dip·ExtendRegion·Image·L·RangeArray·CL·StringArray·CL = "Fills the pixels outside a region in the image using a boundary condition.";
constexpr char const* dip·ExtendRegion·Image·L·UnsignedArray··UnsignedArray··StringArray·CL = "Fills the pixels outside a region in the image using a boundary condition.";
constexpr char const* dip·Vertex·T = "Encodes a location in a 2D image.";
constexpr char const* dip·Vertex·T·x = "The x-coordinate";
constexpr char const* dip·Vertex·T·y = "The y-coordinate";
constexpr char const* dip·Vertex·T·Vertex = "Default constructor.";
constexpr char const* dip·Vertex·T·Vertex·T··T· = "Constructor.";
constexpr char const* dip·Vertex·T·VertexltTgt·T·VertexgtVlt· = "Constructor.";
constexpr char const* dip·Vertex·T·operatorpluseq·T·VertexgtVlt· = "Add a vertex.";
constexpr char const* dip·Vertex·T·operatorminuseq·T·VertexgtVlt· = "Subtract a vertex.";
constexpr char const* dip·Vertex·T·operatorpluseq·T· = "Add a constant to both coordinate components.";
constexpr char const* dip·Vertex·T·operatorminuseq·T· = "Subtract a constant from both coordinate components.";
constexpr char const* dip·Vertex·T·operatortimeseq·dfloat· = "Scale by a constant, isotropically.";
constexpr char const* dip·Vertex·T·operatortimeseq·T·VertexgtVlt· = "Scale by a constant, anisotropically.";
constexpr char const* dip·Vertex·T·operatordiveq·dfloat· = "Scale by the inverse of a constant, isotropically.";
constexpr char const* dip·Vertex·T·operatordiveq·T·VertexgtVlt· = "Scale by the inverse of a constant, anisotropically.";
constexpr char const* dip·Vertex·T·Round·C = "Round coordinates to nearest integer.";
constexpr char const* dip·Vertex·T·Permute·C = "Permute dimensions, swapping x and y values.";
constexpr char const* dip·VertexFloat = "A vertex with floating-point coordinates.";
constexpr char const* dip·VertexInteger = "A vertex with integer coordinates";
constexpr char const* dip·operatoreqeq·T·VertexgtTlt··VertexgtTlt· = "Compare two vertices.";
constexpr char const* dip·Norm·T·VertexgtTlt·CL = "The norm of the vector `v`.";
constexpr char const* dip·NormSquare·T·VertexgtTlt·CL = "The square of the norm of the vector `v`.";
constexpr char const* dip·Distance·T·VertexgtTlt·CL·VertexgtTlt·CL = "The norm of the vector `v2-v1`.";
constexpr char const* dip·DistanceSquare·T·VertexgtTlt·CL·VertexgtTlt·CL = "The square norm of the vector `v2-v1`.";
constexpr char const* dip·Angle·T·VertexgtTlt·CL·VertexgtTlt·CL = "The angle of the vector `v2-v1`.";
constexpr char const* dip·CrossProduct·T·VertexgtTlt·CL·VertexgtTlt·CL = "Compute the z component of the cross product of vectors `v1` and `v2`.";
constexpr char const* dip·ParallelogramSignedArea·T·VertexgtTlt·CL·VertexgtTlt·CL·VertexgtTlt·CL = "Compute the z component of the cross product of vectors `v2-v1` and `v3-v1`.";
constexpr char const* dip·TriangleArea·T·VertexgtTlt·CL·VertexgtTlt·CL·VertexgtTlt·CL = "Compute the area of the triangle formed by vertices `v1`, `v2` and `v3`.";
constexpr char const* dip·TriangleHeight·T·VertexgtTlt·CL·VertexgtTlt·CL·VertexgtTlt·CL = "Compute the height of the triangle formed by vertices `v1`, `v2` and `v3`,\nwith `v3` the tip.";
constexpr char const* dip·operatorplus·T·VertexgtTlt··VertexgtTlt·CL = "Add two vertices together, with identical types.";
constexpr char const* dip·operatorplus·VertexFloat··VertexInteger·CL = "Add two vertices together, where the LHS is floating-point and the RHS is\ninteger.";
constexpr char const* dip·operatorplus·VertexInteger·CL·VertexFloat· = "Add two vertices together, where the LHS is integer and the RHS is floating-\npoint.";
constexpr char const* dip·operatorminus·T·VertexgtTlt··VertexgtTlt·CL = "Subtract two vertices from each other.";
constexpr char const* dip·operatorminus·VertexFloat··VertexInteger·CL = "Subtract two vertices from each other, where the LHS is floating-point and the\nRHS is integer.";
constexpr char const* dip·operatorminus·VertexInteger·CL·VertexFloat·CL = "Subtract two vertices from each other, where the LHS is integer and the RHS is\nfloating-point.";
constexpr char const* dip·operatorplus·T·VertexgtTlt··S· = "Add a vertex and a constant.";
constexpr char const* dip·operatorminus·T·VertexgtTlt··S· = "Subtract a vertex and a constant.";
constexpr char const* dip·operatortimes·T·VertexgtTlt··dfloat· = "Multiply a vertex and a constant, scaling isotropically.";
constexpr char const* dip·operatortimes·T·VertexgtTlt··VertexgtTlt·CL = "Multiply a vertex by another vertex, scaling anisotropically.";
constexpr char const* dip·operatortimes·VertexFloat··VertexInteger·CL = "Multiply a vertex by another vertex, scaling anisotropically, where the LHS is\nfloating-point and the RHS is integer.";
constexpr char const* dip·operatortimes·VertexInteger·CL·VertexFloat·CL = "Multiply a vertex by another vertex, scaling anisotropically, where the LHS is\ninteger and the RHS is floating-point.";
constexpr char const* dip·operatordiv·T·VertexgtTlt··dfloat· = "Divide a vertex by a constant, scaling isotropically.";
constexpr char const* dip·operatordiv·T·VertexgtTlt··VertexgtTlt·CL = "Divide a vertex by another vertex, scaling anisotropically.";
constexpr char const* dip·operatordiv·VertexFloat··VertexInteger·CL = "Divide a vertex by another vertex, scaling anisotropically, where the LHS is\nfloating-point and the RHS is integer.";
constexpr char const* dip·operatordiv·VertexInteger·CL·VertexFloat·CL = "Divide a vertex by another vertex, scaling anisotropically, where the LHS is\ninteger and the RHS is floating-point.";
constexpr char const* dip·BoundingBox·T = "Encodes a bounding box in a 2D image by the top left and bottom right corners\n(both coordinates included in the box).";
constexpr char const* dip·BoundingBox·T·VertexType = "The bounding box is defined in terms of two vertices.";
constexpr char const* dip·BoundingBox·T·topLeft = "Top-left corner of the box";
constexpr char const* dip·BoundingBox·T·bottomRight = "Bottom-right corner of the box";
constexpr char const* dip·BoundingBox·T·BoundingBox = "Default constructor, yields a bounding box of a single pixel at `{0,0}`.";
constexpr char const* dip·BoundingBox·T·BoundingBox·VertexType· = "Constructor, yields a bounding box of a single pixel at `pt`.";
constexpr char const* dip·BoundingBox·T·BoundingBox·VertexType··VertexType· = "Constructor, yields a bounding box with the two points as two of its vertices.";
constexpr char const* dip·BoundingBox·T·Expand·VertexType· = "Expand bounding box to include given point.";
constexpr char const* dip·BoundingBox·T·Contains·VertexInteger· = "Tests to see if the given point is inside the bounding box.";
constexpr char const* dip·BoundingBox·T·Contains·VertexFloat· = "Tests to see if the given point is inside the bounding box.";
constexpr char const* dip·BoundingBox·T·Size·C = "Returns the size of the bounding box.";
constexpr char const* dip·BoundingBoxFloat = "A bounding box with floating-point coordinates.";
constexpr char const* dip·BoundingBoxInteger = "A bounding box with integer coordinates.";
constexpr char const* dip·FeretValues = "Contains the various Feret diameters as returned by `dip::ConvexHull::Feret`\nand `dip::ChainCode::Feret`.";
constexpr char const* dip·FeretValues·maxDiameter = "The maximum Feret diameter";
constexpr char const* dip·FeretValues·minDiameter = "The minimum Feret diameter";
constexpr char const* dip·FeretValues·maxPerpendicular = "The Feret diameter perpendicular to `minDiameter`";
constexpr char const* dip·FeretValues·maxAngle = "The angle at which `maxDiameter` was measured";
constexpr char const* dip·FeretValues·minAngle = "The angle at which `minDiameter` was measured";
constexpr char const* dip·RadiusValues = "Holds the various output values of the `dip::Polygon::RadiusStatistics`\nfunction.";
constexpr char const* dip·RadiusValues·Mean·C = "Returns the mean radius.";
constexpr char const* dip·RadiusValues·StandardDeviation·C = "Returns the standard deviation of radii.";
constexpr char const* dip·RadiusValues·Variance·C = "Returns the variance of radii.";
constexpr char const* dip·RadiusValues·Maximum·C = "Returns the maximum radius.";
constexpr char const* dip·RadiusValues·Minimum·C = "Returns the minimum radius.";
constexpr char const* dip·RadiusValues·Circularity·C = "Computes a circularity measure given by the coefficient of variation of the\nradii of the object.";
constexpr char const* dip·RadiusValues·operatorpluseq·RadiusValues·CL = "Multiple `RadiusValues` objects can be added together.";
constexpr char const* dip·CircleParameters = "Represents a circle, returned by `dip::Polygon::FitCircle`.";
constexpr char const* dip·CircleParameters·center = "The center coordinates";
constexpr char const* dip·CircleParameters·diameter = "The diameter";
constexpr char const* dip·EllipseParameters = "Represents an ellipse, returned by `dip::CovarianceMatrix::Ellipse` and\n`dip::Polygon::FitEllipse`.";
constexpr char const* dip·EllipseParameters·center = "The center coordinates";
constexpr char const* dip·EllipseParameters·majorAxis = "Length of the major axis (longest diameter)";
constexpr char const* dip·EllipseParameters·minorAxis = "Length of the minor axis (shortest diameter)";
constexpr char const* dip·EllipseParameters·orientation = "Orientation of the major axis (in radian)";
constexpr char const* dip·EllipseParameters·eccentricity = "Ellipse eccentricity, defined as $sqrt{1 - b^2 / a^2}$, with $a$ equal to\n`majorAxis` and $b$ equal to `minorAxis`.";
constexpr char const* dip·CovarianceMatrix = "A 2D covariance matrix for computation with 2D vertices.";
constexpr char const* dip·CovarianceMatrix·CovarianceMatrix = "Default-initialized covariance matrix is all zeros.";
constexpr char const* dip·CovarianceMatrix·CovarianceMatrix·VertexFloat· = "Construct a covariance matrix as the outer product of a vector and itself.";
constexpr char const* dip·CovarianceMatrix·CovarianceMatrix·dfloat··dfloat··dfloat· = "Construct a covariance matrix with the three components.";
constexpr char const* dip·CovarianceMatrix·xx·C = "Read matrix element.";
constexpr char const* dip·CovarianceMatrix·xy·C = "Read matrix element.";
constexpr char const* dip·CovarianceMatrix·yy·C = "Read matrix element.";
constexpr char const* dip·CovarianceMatrix·Det·C = "Compute determinant of matrix.";
constexpr char const* dip·CovarianceMatrix·Inv·C = "Compute inverse of matrix.";
constexpr char const* dip·CovarianceMatrix·operatorpluseq·CovarianceMatrix·CL = "Add other matrix to this matrix.";
constexpr char const* dip·CovarianceMatrix·operatortimeseq·dfloat· = "Scale matrix.";
constexpr char const* dip·CovarianceMatrix·operatordiveq·dfloat· = "Scale matrix.";
constexpr char const* dip·CovarianceMatrix·Project·VertexFloat·CL·C = "Computes v' * C * v, with v' the transpose of v. This is a positive scalar if\nv is non-zero, because C (this matrix) is positive semidefinite.";
constexpr char const* dip·CovarianceMatrix·Eigenvalues = "Container for matrix eigenvalues.";
constexpr char const* dip·CovarianceMatrix·Eigenvalues·largest = "Largest eigenvalue";
constexpr char const* dip·CovarianceMatrix·Eigenvalues·smallest = "Smallest eigenvalue";
constexpr char const* dip·CovarianceMatrix·Eigenvalues·Eccentricity·C = "Computes eccentricity using the two eigenvalues of the covariance matrix.";
constexpr char const* dip·CovarianceMatrix·Eig·C = "Compute eigenvalues of matrix.";
constexpr char const* dip·CovarianceMatrix·Ellipse·bool··C = "Compute parameters of ellipse with same covariance matrix.";
constexpr char const* dip·Polygon = "A polygon with floating-point vertices.";
constexpr char const* dip·Polygon·Vertices = "Type used to store the vertices.";
constexpr char const* dip·Polygon·vertices = "The vertices.";
constexpr char const* dip·Polygon·BoundingBox·C = "Returns the bounding box of the polygon.";
constexpr char const* dip·Polygon·IsClockWise·C = "Determine the orientation of the polygon.";
constexpr char const* dip·Polygon·Area·C = "Computes the (signed) area of the polygon. The default, clockwise polygons\nhave a positive area.";
constexpr char const* dip·Polygon·Centroid·C = "Computes the centroid of the polygon.";
constexpr char const* dip·Polygon·CovarianceMatrixVertices·VertexFloat·CL·C = "Returns the covariance matrix for the vertices of the polygon, using centroid\n`g`.";
constexpr char const* dip·Polygon·CovarianceMatrixVertices·C = "Returns the covariance matrix for the vertices of the polygon.";
constexpr char const* dip·Polygon·CovarianceMatrixSolid·VertexFloat·CL·C = "Returns the covariance matrix for the solid object represented by the polygon,\nusing centroid `g`.";
constexpr char const* dip·Polygon·CovarianceMatrixSolid·C = "Returns the covariance matrix for the solid object represented by the polygon.";
constexpr char const* dip·Polygon·Length·C = "Computes the length of the polygon (i.e. perimeter). If the polygon represents\na pixelated object, this function will overestimate the object's perimeter. In\nthis case, use `dip::ChainCode::Length` instead.";
constexpr char const* dip·Polygon·Perimeter·C = "An alias for `dip::Polygon::Length`.";
constexpr char const* dip·Polygon·RadiusStatistics·C = "Returns statistics on the radii of the polygon. The radii are the distances\nbetween the centroid and each of the vertices.";
constexpr char const* dip·Polygon·RadiusStatistics·VertexFloat·CL·C = "Returns statistics on the radii of the polygon. The radii are the distances\nbetween the given centroid and each of the vertices.";
constexpr char const* dip·Polygon·EllipseVariance·C = "Compares a polygon to the ellipse with the same covariance matrix, returning\nthe coefficient of variation of the distance of vertices to the ellipse.";
constexpr char const* dip·Polygon·EllipseVariance·VertexFloat·CL·dip·CovarianceMatrix·CL·C = "Compares a polygon to the ellipse described by the given centroid and\ncovariance matrix, returning the coefficient of variation of the distance of\nvertices to the ellipse.";
constexpr char const* dip·Polygon·FractalDimension·dfloat··C = "Computes the fractal dimension of a polygon.";
constexpr char const* dip·Polygon·BendingEnergy·C = "Computes the bending energy of a polygon.";
constexpr char const* dip·Polygon·FitCircle·C = "Fits a circle to the polygon vertices.";
constexpr char const* dip·Polygon·FitEllipse·C = "Fits an ellipse to the polygon vertices.";
constexpr char const* dip·Polygon·Simplify·dfloat· = "Simplifies the polygon using the Douglas-Peucker algorithm.";
constexpr char const* dip·Polygon·Augment·dfloat· = "Adds vertices along each edge of the polygon such that the distance between\ntwo consecutive vertices is never more than `distance`.";
constexpr char const* dip·Polygon·Smooth·dfloat· = "Locally averages the location of vertices of a polygon so it becomes smoother.";
constexpr char const* dip·Polygon·Reverse = "Reverses the orientation of the polygon, converting a clockwise polygon into a\ncounter-clockwise one and vice versa.";
constexpr char const* dip·Polygon·Rotate·dfloat· = "Rotates the polygon around the origin by `angle`, which is positive for\nclockwise rotation.";
constexpr char const* dip·Polygon·Scale·dfloat· = "Scales the polygon isotropically by multiplying each vertex coordinate by\n`scale`.";
constexpr char const* dip·Polygon·Scale·dfloat··dfloat· = "Scales the polygon anisotropically by multiplying each vertex coordinate by\n`scaleX` and `scaleY`.";
constexpr char const* dip·Polygon·Translate·VertexFloat· = "Translates the polygon by `shift`.";
constexpr char const* dip·Polygon·ConvexHull·C = "Returns the convex hull of the polygon. The polygon must be simple.";
constexpr char const* dip·ConvexHull = "A convex hull is a convex polygon. It can be constructed from a simple\n`dip::Polygon`, and is guaranteed clockwise.";
constexpr char const* dip·ConvexHull·ConvexHull = "Default-constructed ConvexHull (without vertices).";
constexpr char const* dip·ConvexHull·ConvexHull·dip·Polygon·CL = "Constructs a convex hull of a polygon. The polygon must be simple (not self\nintersect).";
constexpr char const* dip·ConvexHull·Polygon·C = "Returns the polygon representing the convex hull.";
constexpr char const* dip·ConvexHull·Polygon = "Returns the polygon representing the convex hull.";
constexpr char const* dip·ConvexHull·Feret·C = "Returns the Feret diameters of the convex hull.";
constexpr char const* dip·ChainCode = "The contour of an object as a chain code sequence.";
constexpr char const* dip·ChainCode·CodeTable = "Provides data that are helpful when processing chain codes.";
constexpr char const* dip·ChainCode·CodeTable·pos = "Array with position offsets for each chain code.";
constexpr char const* dip·ChainCode·CodeTable·offset = "Array with pointer offsets for each chain code.";
constexpr char const* dip·ChainCode·Code = "Encodes a single chain code, as used by `dip::ChainCode`.";
constexpr char const* dip·ChainCode·Code·Code = "Default constructor";
constexpr char const* dip·ChainCode·Code·Code·unsigned_int··bool· = "Constructor";
constexpr char const* dip·ChainCode·Code·IsBorder·C = "Returns whether the border flag is set";
constexpr char const* dip·ChainCode·Code·operator_unsigned·C = "Returns the chain code";
constexpr char const* dip·ChainCode·Code·IsEven·C = "Is it an even code?";
constexpr char const* dip·ChainCode·Code·IsOdd·C = "Is it an off code?";
constexpr char const* dip·ChainCode·Code·Delta8·C = "The change in coordinates for an 8-connected chain code";
constexpr char const* dip·ChainCode·Code·Delta4·C = "The change in coordinates for a 4-connected chain code";
constexpr char const* dip·ChainCode·Code·operatoreqeq·Code·CL·C = "Compare codes";
constexpr char const* dip·ChainCode·Code·operatornoteq·Code·CL·C = "Compare codes";
constexpr char const* dip·ChainCode·codes = "The chain codes";
constexpr char const* dip·ChainCode·start = "The coordinates of the start pixel, the default value is outside the image to\nindicate there's no chain code here";
constexpr char const* dip·ChainCode·objectID = "The label of the object from which this chain code is taken";
constexpr char const* dip·ChainCode·is8connected = "Is false when connectivity = 1, true when connectivity = 2";
constexpr char const* dip·ChainCode·Push·Code·CL = "Adds a code to the end of the chain.";
constexpr char const* dip·ChainCode·PrepareCodeTable·IntegerArray·CL·C = "Returns a table that is useful when processing the chain code";
constexpr char const* dip·ChainCode·PrepareCodeTable·dip·uint··IntegerArray·CL = "Returns a table that is useful when processing the chain code";
constexpr char const* dip·ChainCode·ConvertTo8Connected·C = "Creates a new chain code object that is 8-connected and represents the same\nshape.";
constexpr char const* dip·ChainCode·Empty·C = "A chain code whose `start` value hasn't been set is considered empty.";
constexpr char const* dip·ChainCode·Length·String·CL·C = "Returns the length of the chain code using the method by Vossepoel and\nSmeulders.";
constexpr char const* dip·ChainCode·Feret·dfloat··C = "Returns the Feret diameters, using an angular step size in radian of\n`angleStep`. It is better to use `dip::ConvexHull::Feret`.";
constexpr char const* dip·ChainCode·BendingEnergy·C = "Computes the bending energy.";
constexpr char const* dip·ChainCode·Area·C = "Computes the area of the solid object described by the chain code. Uses the\nresult of `dip::ChainCode::Polygon`, so if you plan to do multiple similar\nmeasures, extract the polygon and compute the measures on that.";
constexpr char const* dip·ChainCode·Centroid·C = "Computes the centroid of the solid object described by the chain code. Uses\nthe result of `dip::ChainCode::Polygon`, so if you plan to do multiple similar\nmeasures, extract the polygon and compute the measures on that.";
constexpr char const* dip·ChainCode·BoundingBox·C = "Finds the bounding box for the object described by the chain code.";
constexpr char const* dip·ChainCode·LongestRun·C = "Returns the length of the longest run of identical chain codes.";
constexpr char const* dip·ChainCode·Polygon·String·CL·C = "Returns a polygon representation of the object.";
constexpr char const* dip·ChainCode·ConvexHull·C = "Returns the convex hull of the object, see `dip::ChainCode::Polygon`.";
constexpr char const* dip·ChainCode·Image·dip·Image·L·C = "Paints the pixels traced by the chain code in a binary image. The image has\nthe size of the `dip::ChainCode::BoundingBox`.";
constexpr char const* dip·ChainCode·Coordinates·C = "Returns the pixel coordinates for each of the pixels represented in the chain\ncode.";
constexpr char const* dip·ChainCode·Offset·C = "Create a new chain code that goes around the object in the same direction, but\ntraces the background pixels that are 4-connected to the object. That is, it\ngrows the object by one pixel. Only defined for 8-connected chain codes.";
constexpr char const* dip·ChainCodeArray = "A collection of object contours.";
constexpr char const* dip·GetImageChainCodes·Image·CL·std·vectorgtLabelTypelt·CL·dip·uint· = "Returns the set of chain codes sequences that encode the contours of the given\nobjects in a labeled image.";
constexpr char const* dip·GetSingleChainCode·Image·CL·UnsignedArray·CL·dip·uint· = "Returns the chain codes sequence that encodes the contour of one object in a\nbinary or labeled image.";
constexpr char const* dip·XYZ = "An XYZ triplet, used to specify a white point for color spaces.";
constexpr char const* dip·xy = "A color, as (x,y) chromaticity coordinates, used to specify a white point for\ncolor spaces.";
constexpr char const* dip·XYZMatrix = "XYZ matrix (3x3 matrix, column-major order) for conversion between RGB and\nXYZ. Computed from a `dip::XYZ` triplet.";
constexpr char const* dip·ColorSpaceConverter = "Abstract base class for conversion between two color spaces.";
constexpr char const* dip·ColorSpaceConverter·InputColorSpace·C = "Returns the source color space name.";
constexpr char const* dip·ColorSpaceConverter·OutputColorSpace·C = "Returns the destination color space name.";
constexpr char const* dip·ColorSpaceConverter·Cost·C = "Returns the cost of the conversion. This cost includes computational cost as\nwell as precision loss.";
constexpr char const* dip·ColorSpaceConverter·Convert·ConstLineIteratorgtdfloatlt·L·LineIteratorgtdfloatlt·L·C = "This is the method that performs the conversion for one image line.";
constexpr char const* dip·ColorSpaceConverter·SetWhitePoint·XYZ·CL·XYZMatrix·CL·XYZMatrix·CL = "This method is called to set the white point used by the converter. Does\nnothing by default.";
constexpr char const* dip·ColorSpaceManager = "An object of this class is used to convert images between color spaces.";
constexpr char const* dip·ColorSpaceManager·ColorSpaceConverterPointer = "A shared pointer to a `dip::ColorSpaceConverter` object.";
constexpr char const* dip·ColorSpaceManager·ColorSpaceManager = "Constructor, registers the default color spaces.";
constexpr char const* dip·ColorSpaceManager·Define·String··dip·uint· = "Defines a new color space, that requires `nChannels` channels.";
constexpr char const* dip·ColorSpaceManager·DefineAlias·String·CL·String·CL = "Defines an alias for a defined color space name.";
constexpr char const* dip·ColorSpaceManager·Register·ColorSpaceConverterPointer· = "Registers a function object to translate from one color space to another. The\n`dip::ColorSpaceManager` object takes ownership of the converter.";
constexpr char const* dip·ColorSpaceManager·Register·ColorSpaceConverter·P = "Overload for the previous function, for backwards compatibility. Not\nrecommended.";
constexpr char const* dip·ColorSpaceManager·IsDefined·String·CL·C = "Check to see if a color space name is defined.";
constexpr char const* dip·ColorSpaceManager·GetColorSpaceConverter·String·CL·String·CL·C = "Gets a pointer to a color space converter object registered with this\n`ColorSpaceManager`. Use this to access the object to modify it, for example\nconfigure a parameter.";
constexpr char const* dip·ColorSpaceManager·NumberOfChannels·String·CL·C = "Returns the number of channels used by the given color space.";
constexpr char const* dip·ColorSpaceManager·CanonicalName·String·CL·C = "Returns the canonical name for the given color space (i.e. looks up name\naliases).";
constexpr char const* dip·ColorSpaceManager·Convert·Image·CL·Image·L·String·CL·C = "Converts an image to a different color space.";
constexpr char const* dip·ColorSpaceManager·IlluminantA = "The CIE Standard Illuminant A (typical, domestic, tungsten-filament lighting).";
constexpr char const* dip·ColorSpaceManager·IlluminantD50 = "The CIE Standard Illuminant D50 (mid-morning or mid-afternoon daylight, color\ntemperature is about 5000 K).";
constexpr char const* dip·ColorSpaceManager·IlluminantD55 = "The CIE Standard Illuminant D55 (morning or evening daylight, color\ntemperature is about 5500 K).";
constexpr char const* dip·ColorSpaceManager·IlluminantD65 = "The CIE Standard Illuminant D65 (noon daylight, color temperature is about\n6500 K). This is also used in the sRGB standard.";
constexpr char const* dip·ColorSpaceManager·IlluminantE = "The CIE Standard Illuminant E (synthetic, equal energy illuminant).";
constexpr char const* dip·ColorSpaceManager·SetWhitePoint·dip·XYZ· = "Configure the conversion functions to use the given white point.";
constexpr char const* dip·ColorSpaceManager·SetWhitePoint·xy·CL = "Overload of the function above that takes a (x,y) chromaticity coordinate.";
constexpr char const* dip·WienerDeconvolution·Image·CL·Image·CL·Image·CL·Image·CL·Image·L·StringSet·CL = "Wiener deconvolution using estimates of signal and noise power spectra.";
constexpr char const* dip·WienerDeconvolution·Image·CL·Image·CL·Image·L·dfloat··StringSet·CL = "Wiener deconvolution using an estimate of noise-to-signal ratio.";
constexpr char const* dip·TikhonovMiller·Image·CL·Image·CL·Image·L·dfloat··StringSet·CL = "Tikhonov-Miller deconvolution.";
constexpr char const* dip·IterativeConstrainedTikhonovMiller·Image·CL·Image·CL·Image·L·dfloat··dfloat··dip·uint··dfloat··StringSet·CL = "Iterative Constrained Tikhonov-Miller (ICTM) deconvolution.";
constexpr char const* dip·RichardsonLucy·Image·CL·Image·CL·Image·L·dfloat··dip·uint··StringSet·CL = "Richardson-Lucy (RL) deconvolution, also sometimes called the expectation\nmaximization (EM) method.";
constexpr char const* dip·FastIterativeShrinkageThresholding·Image·CL·Image·CL·Image·L·dfloat··dfloat··dip·uint··dip·uint··StringSet·CL = "Fast Iterative Shrinkage-Thresholding (FISTA) deconvolution.";
constexpr char const* dip·HoughTransformCircleCenters·Image·CL·Image·CL·Image·L·UnsignedArray·CL = "Hough transform for circles in 2D binary images.";
constexpr char const* dip·FindHoughMaxima·Image·CL·dfloat··dfloat· = "Find local maxima in Hough parameter space.";
constexpr char const* dip·PointDistanceDistribution·Image·CL·CoordinateArray·CL·UnsignedArray· = "Compute distance distribution for a set of points.";
constexpr char const* dip·FindHoughCircles·Image·CL·Image·CL·UnsignedArray·CL·dfloat··dfloat· = "Find circles in 2D binary images.";
constexpr char const* dip·RadonCircleParameters = "Stores the parameters for one hypersphere (circle, sphere).";
constexpr char const* dip·RadonCircleParameters·origin = "Coordinates of the origin of the hypersphere";
constexpr char const* dip·RadonCircleParameters·radius = "Radius of the hypersphere";
constexpr char const* dip·RadonCircleParametersArray = "An array of `dip::RadonCircleParameters`, storing parameters for all\nhyperspheres detected by `dip::RadonTransformCircles`.";
constexpr char const* dip·RadonTransformCircles·Image·CL·Image·L·Range··dfloat··dfloat··String·CL·StringSet·CL = "Detects hyperspheres (circles, spheres) using the generalized Radon transform.";
constexpr char const* dip·HarrisCornerDetector·Image·CL·Image·L·dfloat··FloatArray·CL·StringArray·CL = "Harris corner detector";
constexpr char const* dip·ShiTomasiCornerDetector·Image·CL·Image·L·FloatArray·CL·StringArray·CL = "Shi-Tomasi corner detector";
constexpr char const* dip·NobleCornerDetector·Image·CL·Image·L·FloatArray·CL·StringArray·CL = "Noble's corner detector (also known as the Plessey detector)";
constexpr char const* dip·WangBradyCornerDetector·Image·CL·Image·L·dfloat··FloatArray·CL·StringArray·CL = "Wang-Brady corner detector";
constexpr char const* dip·FrangiVesselness·Image·CL·Image·L·FloatArray·CL·FloatArray··String·CL·StringArray·CL = "Frangi vessel detector, single scale (Hessian based)";
constexpr char const* dip·MatchedFiltersLineDetector2D·Image·CL·Image·L·dip·dfloat··dip·dfloat··String·CL·StringArray·CL = "Matched filters for line detection in 2D";
constexpr char const* dip·DanielssonLineDetector·Image·CL·Image·L·dip·FloatArray·CL·String·CL·StringArray·CL = "Danielsson's Hessian-based line detector";
constexpr char const* dip·RORPOLineDetector·Image·CL·Image·L·dip·uint··String·CL = "Line detector based on robust path openings";
constexpr char const* dip·DFT·T = "An object that encapsulates the Discrete Fourier Transform (DFT).";
constexpr char const* dip·DFT·T·DFT = "A default-initialized `DFT` object is useless. Call `Initialize` to make it\nuseful.";
constexpr char const* dip·DFT·T·DFT·dip·uint··bool··Option·DFTOptions· = "Construct a `DFT` object, see `dip::DFT::Initialize` for the meaning of the\nparameters. Note that this is not a trivial operation. Not thread safe.";
constexpr char const* dip·DFT·T·Initialize·dip·uint··bool··Option·DFTOptions· = "Re-configure a `DFT` object to the given transform size and direction.";
constexpr char const* dip·DFT·T·Apply·std·complexgtTlt·P·std·complexgtTlt·P·T··C = "Apply the transform that the `DFT` object is configured for.";
constexpr char const* dip·DFT·T·IsInverse·C = "Returns `true` if this represents an inverse transform, `false` for a forward\ntransform.";
constexpr char const* dip·DFT·T·IsInplace·C = "Returns whether the transform is configured to work in place or not. Not\nmeaningful when using PocketFFT.";
constexpr char const* dip·DFT·T·IsAligned·C = "Returns whether the transform is configured to work on aligned buffers or not.\nNot meaningful when using PocketFFT.";
constexpr char const* dip·DFT·T·TransformSize·C = "Returns the size that the transform is configured for.";
constexpr char const* dip·DFT·T·BufferSize·C = "Returns the size of the buffer expected by `Apply`.";
constexpr char const* dip·DFT·T·Destroy = "Frees memory";
constexpr char const* dip·RDFT·T = "An object that encapsulates the real-valued Discrete Fourier Transform (DFT).";
constexpr char const* dip·RDFT·T·RDFT = "A default-initialized `DFT` object is useless. Call `Initialize` to make it\nuseful.";
constexpr char const* dip·RDFT·T·RDFT·dip·uint··bool··Option·DFTOptions· = "Construct a `DFT` object, see `dip::RDFT::Initialize` for the meaning of the\nparameters. Note that this is not a trivial operation. Not thread safe.";
constexpr char const* dip·RDFT·T·Initialize·dip·uint··bool··Option·DFTOptions· = "Re-configure a `RDFT` object to the given transform size and direction.";
constexpr char const* dip·RDFT·T·Apply·T·P·T·P·T··C = "Apply the transform that the `RDFT` object is configured for.";
constexpr char const* dip·RDFT·T·IsInverse·C = "Returns `true` if this represents an inverse transform, `false` for a forward\ntransform.";
constexpr char const* dip·RDFT·T·IsInplace·C = "Returns whether the transform is configured to work in place or not. Not\nmeaningful when using PocketFFT.";
constexpr char const* dip·RDFT·T·IsAligned·C = "Returns whether the transform is configured to work on aligned buffers or not.\nNot meaningful when using PocketFFT.";
constexpr char const* dip·RDFT·T·TransformSize·C = "Returns the size that the transform is configured for.";
constexpr char const* dip·RDFT·T·Destroy = "Frees memory";
constexpr char const* dip·GetOptimalDFTSize·dip·uint··bool··dip·uint· = "Returns a size equal or larger to `size0` that is efficient for the DFT\nimplementation. The value returned is a product of small primes.";
constexpr char const* dip·maximumDFTSize = "The largest size supported by `dip::DFT` and `dip::FourierTransform`. Is equal\nto 2^31^-1 when using FFTW, 2^64^-1 when using PocketFFT on a 64-bit system,\nor 2^32^-1 when using PocketFFT on a 32-bit system.";
constexpr char const* dip·usingFFTW = "Is `true` if `dip::DFT` and `dip::RDFT` use the FFTW library, or false if they\nuse PocketFFT.";
constexpr char const* dip·MaxFactor·bool· = "The `maxFactor` parameter for `dip::GetOptimalDFTSize`. `complex` determines\nwhether the transform to be computed is complex-to-complex or not.";
constexpr char const* dip·ImageDisplay = "Encapsulates state of an image in a display window, and provides the\nfunctionality for converting the image to a form suitable for display.";
constexpr char const* dip·ImageDisplay·ProjectionMode = "Enumerator for the projection mode";
constexpr char const* dip·ImageDisplay·ProjectionMode·SLICE = "A slice is prepared for display";
constexpr char const* dip·ImageDisplay·ProjectionMode·MAX = "The max projection is prepared for display";
constexpr char const* dip·ImageDisplay·ProjectionMode·MEAN = "The mean projection is prepared for display";
constexpr char const* dip·ImageDisplay·ComplexMode = "Enumerator for the complex mapping mode";
constexpr char const* dip·ImageDisplay·ComplexMode·MAGNITUDE = "The magnitude is prepared for display";
constexpr char const* dip·ImageDisplay·ComplexMode·PHASE = "The complex phase is prepared for display";
constexpr char const* dip·ImageDisplay·ComplexMode·REAL = "The real component is prepared for display";
constexpr char const* dip·ImageDisplay·ComplexMode·IMAG = "The imaginary component is prepared for display";
constexpr char const* dip·ImageDisplay·MappingMode = "Enumerator for the intensity mapping mode";
constexpr char const* dip·ImageDisplay·MappingMode·MANUAL = "`dip::ImageDisplay::Limits` are used as-is";
constexpr char const* dip·ImageDisplay·MappingMode·MAXMIN = "The max and min values are taken as the display limits";
constexpr char const* dip·ImageDisplay·MappingMode·PERCENTILE = "The 5% and 95% values are taken as the display limits";
constexpr char const* dip·ImageDisplay·MappingMode·BASED = "0 should remain at the middle of the output range";
constexpr char const* dip·ImageDisplay·MappingMode·LOGARITHMIC = "A logarithmic mapping is applied";
constexpr char const* dip·ImageDisplay·MappingMode·MODULO = "The integer input values are mapped modulo the output range";
constexpr char const* dip·ImageDisplay·Limits = "Intensity mapping limits";
constexpr char const* dip·ImageDisplay·Limits·lower = "This value is mapped to 0.";
constexpr char const* dip·ImageDisplay·Limits·upper = "This value is mapped to 255.";
constexpr char const* dip·ImageDisplay·ImageDisplay·Image·CL·ColorSpaceManager·P·ExternalInterface·P = "The constructor takes an image with at least 1 dimension.";
constexpr char const* dip·ImageDisplay·Input·C = "Retrieves a reference to the input image.";
constexpr char const* dip·ImageDisplay·Slice = "Retrieves a reference to the raw slice image.";
constexpr char const* dip·ImageDisplay·Output = "Retrieves a reference to the output image.";
constexpr char const* dip·ImageDisplay·MapSinglePixel·Image·Pixel·CL = "Puts a single pixel through the same mapping the image will go through to\nbecome `dip::ImageDisplay::Output`.";
constexpr char const* dip·ImageDisplay·OutIsDirty·C = "Returns true if the next call to `dip::ImageDisplay::Output` will yield a\ndifferent result from the previous one. That is, the display needs to be\nredrawn.";
constexpr char const* dip·ImageDisplay·SliceIsDirty·C = "Returns true if the next call to `dip::ImageDisplay::Output` will yield a\ndifferent slice";
constexpr char const* dip·ImageDisplay·SizeIsDirty·C = "Returns true if the next call to `dip::ImageDisplay::Output` will yield an\noutput of a different size. That is, the slicing direction has changed, and\nthis yields a change in sizes.";
constexpr char const* dip·ImageDisplay·Pixel·dip·uint··dip·uint· = "Gets input image intensities at a given 2D point (automatically finds\ncorresponding nD location). In case of a 1D `dip::ImageDisplay::Output`, `y`\nis ignored.";
constexpr char const* dip·ImageDisplay·SetDirection·dip·uint··dip·uint· = "Sets the projection/slicing direction, as the two image dimensions to show\nalong the x and y axis of the 2D display. If `dim1==dim2`, a 1D output is\nproduced.";
constexpr char const* dip·ImageDisplay·SetCoordinates·UnsignedArray· = "Sets the current coordinates. This affects the slice displayed.";
constexpr char const* dip·ImageDisplay·SetTensorElements·dip·sint··dip·sint··dip·sint· = "Sets the tensor element to be shown in each of the three output channels.";
constexpr char const* dip·ImageDisplay·SetProjectionMode·ProjectionMode· = "Sets the projection mode. Has no effect if image dimensionality is equal to\nprojection dimensionality.";
constexpr char const* dip·ImageDisplay·SetProjectionMode·String·CL = "Sets the projection mode. Has no effect if image dimensionality is equal to\nprojection dimensionality.";
constexpr char const* dip·ImageDisplay·SetComplexMode·ComplexMode· = "Sets the complex to real mapping mode. Has no effect when projection mode is\nset to `\"max\"`, or for non-complex images.";
constexpr char const* dip·ImageDisplay·SetComplexMode·String·CL = "Sets the complex to real mapping mode. Has no effect when projection mode is\nset to `\"max\"`, or for non-complex images.";
constexpr char const* dip·ImageDisplay·SetMappingMode·MappingMode· = "Sets the intensity mapping mode. Has no effect for binary images.";
constexpr char const* dip·ImageDisplay·SetRange·Limits· = "Sets the range of intensities to be mapped to the output range. Forces\nintensity mapping mode to linear. Has no effect for binary images.";
constexpr char const* dip·ImageDisplay·SetRange·String·CL = "Sets the mapping mode and the range of intensities to be mapped to the output\nrange. Has no effect for binary images.";
constexpr char const* dip·ImageDisplay·SetGlobalStretch·bool· = "Sets the global stretch mode. Has no effect on 2D images or when the\nprojection mode is not `\"slice\"`";
constexpr char const* dip·ImageDisplay·SetGlobalStretch·String·CL = "Sets the global stretch mode. Has no effect on 2D images or when the\nprojection mode is not `\"slice\"`";
constexpr char const* dip·ImageDisplay·GetDirection·C = "Get the projection/slicing direction. The two values returned are identical\nwhen output is 1D.";
constexpr char const* dip·ImageDisplay·GetOrthogonal·C = "Returns the array of dimensions orthogonal to those returned by\n`dip::ImageDisplay::GetDirection`. These are the dimensions not displayed.";
constexpr char const* dip·ImageDisplay·GetCoordinates·C = "Get the current coordinates.";
constexpr char const* dip·ImageDisplay·GetSizes·C = "Get the image sizes.";
constexpr char const* dip·ImageDisplay·Dimensionality·C = "Get the image dimensionality.";
constexpr char const* dip·ImageDisplay·GetRedTensorElement·C = "Get the tensor element to be shown in the red channel.";
constexpr char const* dip·ImageDisplay·GetGreenTensorElement·C = "Get the tensor element to be shown in the green channel.";
constexpr char const* dip·ImageDisplay·GetBlueTensorElement·C = "Get the tensor element to be shown in the blue channel.";
constexpr char const* dip·ImageDisplay·GetProjectionMode·C = "Get the current projection mode.";
constexpr char const* dip·ImageDisplay·GetComplexMode·C = "Get the current complex to real mapping mode.";
constexpr char const* dip·ImageDisplay·GetMappingMode·C = "Get the current intensity mapping mode.";
constexpr char const* dip·ImageDisplay·GetRange·C = "Get the current intensity range.";
constexpr char const* dip·ImageDisplay·GetLimits·bool· = "Gets the image intensity range (that selected with `\"lin\"`) for the current\nslicing and complex mapping modes. If `compute` is true, it computes them if\nthey're not yet computed.";
constexpr char const* dip·ImageDisplay·GetGlobalStretch·C = "Get the current global stretch mode.";
constexpr char const* dip·ApplyColorMap·Image·CL·Image·L·String·CL = "Applies a color map to an image prepared for display using\n`dip::ImageDisplay`.";
constexpr char const* dip·Overlay·Image·CL·Image·CL·Image·L·Image·Pixel·CL = "Adds a colored overlay to the image `in`, yielding an RGB image.";
constexpr char const* dip·MarkLabelEdges·Image·CL·Image·L·dip·uint· = "Upscales a labeled image and outlines each region with the background label.";
constexpr char const* dip·EuclideanDistanceTransform·Image·CL·Image·L·String·CL·String·CL = "Euclidean distance transform";
constexpr char const* dip·VectorDistanceTransform·Image·CL·Image·L·String·CL·String·CL = "Euclidean vector distance transform";
constexpr char const* dip·GreyWeightedDistanceTransform·Image·CL·Image·CL·Image·CL·Image·L·Metric··String·CL = "Grey-weighted distance transform";
constexpr char const* dip·GeodesicDistanceTransform·Image·CL·Image·CL·Image·L = "Geodesic distance transform";
constexpr char const* dip·Distribution = "Holds probability density functions and other types of distribution";
constexpr char const* dip·Distribution·ValueType = "Data type of values stored in container";
constexpr char const* dip·Distribution·Container = "Container used internally to store the data";
constexpr char const* dip·Distribution·Sample = "One sample of a distribution.";
constexpr char const* dip·Distribution·Sample·Sample = "Not default constructable";
constexpr char const* dip·Distribution·Sample·Sample·Sample·R = "Move constructor";
constexpr char const* dip·Distribution·Sample·Sample·Sample·CL = "Copy constructor, references the same data. Careful!";
constexpr char const* dip·Distribution·Sample·operatoreq·Sample·R = "Move assignment actually copies value over to sample referenced";
constexpr char const* dip·Distribution·Sample·operatoreq·Sample·CL = "Copy assignment, data is copied to sample referenced";
constexpr char const* dip·Distribution·Sample·X = "Returns reference to sample's *x* value.";
constexpr char const* dip·Distribution·Sample·Y·dip·uint· = "Returns reference to sample's `(index+1)`-th *y* value.";
constexpr char const* dip·Distribution·Sample·Y·dip·uint··dip·uint· = "Returns reference to sample's *y* value at (`row`,`col`).";
constexpr char const* dip·Distribution·Sample·operator_dfloat·C = "Implicitly casts to sample's first *y* value.";
constexpr char const* dip·Distribution·Sample·swap·Sample·L = "Swaps two samples, copying the data from `other` to `*this`, and that from\n`*this` to `other`. Both must have the same number of values.";
constexpr char const* dip·Distribution·ConstSample = "One unmutable sample of a distribution, see `dip::Distribution::Sample` for\ndetails.";
constexpr char const* dip·Distribution·ConstSample·ConstSample = "Not default constructable";
constexpr char const* dip·Distribution·ConstSample·ConstSample·ConstSample·R = "Move constructor";
constexpr char const* dip·Distribution·ConstSample·ConstSample·ConstSample·CL = "Copy constructor, references the same data. Careful!";
constexpr char const* dip·Distribution·ConstSample·operatoreq·ConstSample·R = "Not assignable";
constexpr char const* dip·Distribution·ConstSample·operatoreq·ConstSample·CL = "Not assignable";
constexpr char const* dip·Distribution·ConstSample·X·C = "Returns sample's *x* value.";
constexpr char const* dip·Distribution·ConstSample·Y·dip·uint··C = "Returns sample's `(index+1)`-th *y* value.";
constexpr char const* dip·Distribution·ConstSample·Y·dip·uint··dip·uint··C = "Returns sample's *y* value at (`row`,`col`).";
constexpr char const* dip·Distribution·ConstSample·operator_dfloat·C = "Implicitly casts to sample's first *y* value.";
constexpr char const* dip·Distribution·IteratorTemplate·T = "An iterator for `dip::Distribution`. Dereferences into a `Sample` or a\n`ConstSample` (the value of `T`).";
constexpr char const* dip·Distribution·IteratorTemplate·T·iterator_category = "Iterator category";
constexpr char const* dip·Distribution·IteratorTemplate·T·value_type = "The data type obtained when dereferencing the iterator";
constexpr char const* dip·Distribution·IteratorTemplate·T·difference_type = "The type of difference between iterators";
constexpr char const* dip·Distribution·IteratorTemplate·T·reference = "The type of a reference to a sample";
constexpr char const* dip·Distribution·IteratorTemplate·T·pointer = "The type of a pointer to a sample";
constexpr char const* dip·Distribution·IteratorTemplate·T·IteratorTemplate = "Not default constructable";
constexpr char const* dip·Distribution·IteratorTemplate·T·IteratorTemplate·IteratorTemplategtTlt·R = "Move constructor";
constexpr char const* dip·Distribution·IteratorTemplate·T·IteratorTemplate·IteratorTemplategtTlt·CL = "Copy constructor";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatoreq·IteratorTemplategtTlt·R = "Move assignment, identical to copy assignment";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatoreq·IteratorTemplategtTlt·CL = "Copy assignment";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatortimes = "Dereference";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminusgt = "Dereference";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorsqbra·T·I··C = "Return sample `index` values away from the current location";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminus· = "Pre-decrement";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminus··int· = "Post-decrement";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorpluseq·T·I· = "Move iterator forward by `index` elements";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminuseq·T·I· = "Move iterator backward by `index` elements";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorplus·T·I· = "Returns new iterator moved forward by `n` elements";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminus·T·I· = "Returns new iterator moved backward by `n` elements";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatorminus·IteratorTemplategtTlt·CL·C = "Returns distance between two iterators";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatoreqeq·IteratorTemplategtTlt·CL·C = "Equality comparison";
constexpr char const* dip·Distribution·IteratorTemplate·T·operatornoteq·IteratorTemplategtTlt·CL·C = "Inequality comparison";
constexpr char const* dip·Distribution·Iterator = "An iterator for `dip::Distribution`. Dereferences into a `Sample`.";
constexpr char const* dip·Distribution·ConstIterator = "An iterator for `const dip::Distribution`. Dereferences into a `ConstSample`.";
constexpr char const* dip·Distribution·Distribution·dip·uint··dip·uint··dip·uint· = "A zero-initialized distribution can be created by giving a size, and number of\nvalues (or rows and columns) per sample";
constexpr char const* dip·Distribution·Distribution·std·vectorgtdfloatlt·CL·dip·uint··dip·uint· = "A zero-initialized distribution can be created by giving an array of the *x*\nvalues, and number of values (or rows and columns) per sample";
constexpr char const* dip·Distribution·Distribution·std·vectorgtdfloatlt·CL·std·vectorgtdfloatlt·CL = "A distribution can be created by giving an array of the *x* values and an\narray of the *y* values";
constexpr char const* dip·Distribution·Distribution·Histogram·CL = "A 1D `dip::Histogram` can be cast to a `dip::Distribution`";
constexpr char const* dip·Distribution·Empty·C = "Checks whether the distribution is empty (size is 0)";
constexpr char const* dip·Distribution·Size·C = "Returns the size of the distribution (number of data points)";
constexpr char const* dip·Distribution·ValuesPerSample·C = "Returns the number of *y* values per sample";
constexpr char const* dip·Distribution·Rows·C = "Returns the number of rows in the matrix of *y* values";
constexpr char const* dip·Distribution·Columns·C = "Returns the number of columns in the matrix of *y* values";
constexpr char const* dip·Distribution·XUnits·C = "Returns the units used along the *x* axis.";
constexpr char const* dip·Distribution·XUnits = "Returns a modifiable reference to the units used along the *x* axis.";
constexpr char const* dip·Distribution·operatorsqbra·dip·uint· = "Gets the *x* and *y* values at location `index`";
constexpr char const* dip·Distribution·operatorsqbra·dip·uint··C = "Gets the *x* and *y* values at location `index`";
constexpr char const* dip·Distribution·Back = "Gets the *x* and *y* values at the end";
constexpr char const* dip·Distribution·Back·C = "Gets the *x* and *y* values at the end";
constexpr char const* dip·Distribution·begin = "Returns an iterator to the beginning";
constexpr char const* dip·Distribution·begin·C = "Returns an iterator to the beginning";
constexpr char const* dip·Distribution·end = "Returns an iterator to the end";
constexpr char const* dip·Distribution·end·C = "Returns an iterator to the end";
constexpr char const* dip·Distribution·Xbegin = "Returns an *x*-value iterator to the beginning";
constexpr char const* dip·Distribution·Xbegin·C = "Returns an *x*-value iterator to the beginning";
constexpr char const* dip·Distribution·Xend = "Returns an *x*-value iterator to the end";
constexpr char const* dip·Distribution·Xend·C = "Returns an *x*-value iterator to the end";
constexpr char const* dip·Distribution·Ybegin·dip·uint· = "Returns an *y*-value iterator to the beginning";
constexpr char const* dip·Distribution·Ybegin·dip·uint··C = "Returns an *y*-value iterator to the beginning";
constexpr char const* dip·Distribution·Yend·dip·uint· = "Returns an *y*-value iterator to the end";
constexpr char const* dip·Distribution·Yend·dip·uint··C = "Returns an *y*-value iterator to the end";
constexpr char const* dip·Distribution·X·C = "Copies the *x* values to a new array";
constexpr char const* dip·Distribution·Y·dip·uint··C = "Copies the *y* values to a new array";
constexpr char const* dip·Distribution·Sort = "Sorts the data in the distribution according to the *x* values.";
constexpr char const* dip·Distribution·Cumulative = "Converts the distribution to a cumulative distribution, where each element is\nthe sum of all elements up to that element in the original distribution (i.e.\n*x* spacing is ignored).";
constexpr char const* dip·Distribution·Sum·dip·uint··C = "Computes the sum of the *y* values.";
constexpr char const* dip·Distribution·NormalizeSum = "Normalizes the sum of the *y* values.";
constexpr char const* dip·Distribution·Integrate = "Converts the distribution to a cumulative distribution, where each element is\nthe integral of the original distribution up to that element. Make sure the\ndata are sorted (see `Sort`).";
constexpr char const* dip·Distribution·Integral·dip·uint··C = "Computes the integral of the distribution. Make sure the data are sorted (see\n`Sort`).";
constexpr char const* dip·Distribution·NormalizeIntegral = "Normalizes the integral of the distribution values. Make sure the data are\nsorted (see `Sort`).";
constexpr char const* dip·Distribution·Differentiate = "Converts the cumulative distribution to a distribution, where each element is\nthe derivative of the original distribution at that element. Make sure the\ndata are sorted (see `Sort`).";
constexpr char const* dip·Distribution·MaximumLikelihood = "Computes the most likely *x* values. In essence, returns the *x* values which\nmaximize the corresponding *y* value.";
constexpr char const* dip·Distribution·operatorpluseq·Distribution·CL = "Adds two distributions. Their *x* values must match exactly.";
constexpr char const* dip·Distribution·operatortimeseq·dfloat· = "Scales the distribution, multiplying each *y* value by `scale`.";
constexpr char const* dip·Distribution·operatordiveq·dfloat· = "Scales the distribution, dividing each *y* value by `scale`.";
constexpr char const* dip·Distribution·SetSampling·PixelSize·CL·dfloat··dfloat· = "Fills the values for the *x* axis, starting with `pixelSize[0].magnitude *\noffset`, and linear increments of `pixelSize[0].magnitude * scaling`, if the\n`pixelSize` is isotropic and has physical units. The `XUnits` are also set to\nthe units of the isotropic `pixelSize`, or otherwise to \"px\".";
constexpr char const* dip·swap·Sample·L·Sample·L = "Swaps two samples, copying the data from `other` to `*this`, and that from\n`*this` to `other`. Both must have the same number of values.";
constexpr char const* dip·operatorltlt·std·ostream·L·Distribution·CL = "Writes the distribution to a stream";
constexpr char const* dip·FileInformation = "A data structure with information about an image file.";
constexpr char const* dip·FileInformation·name = "File name";
constexpr char const* dip·FileInformation·fileType = "File type";
constexpr char const* dip·FileInformation·dataType = "Data type for all samples";
constexpr char const* dip·FileInformation·significantBits = "Number of bits used for each sample";
constexpr char const* dip·FileInformation·sizes = "Size of image in pixels";
constexpr char const* dip·FileInformation·tensorElements = "Size of pixel in samples";
constexpr char const* dip·FileInformation·colorSpace = "Color space";
constexpr char const* dip·FileInformation·pixelSize = "Pixel size";
constexpr char const* dip·FileInformation·origin = "Real-world location of origin pixel";
constexpr char const* dip·FileInformation·numberOfImages = "Number of images in the file, for file types that can store multiple images";
constexpr char const* dip·FileInformation·history = "Assorted metadata in the file, in the form of strings";
constexpr char const* dip·OutputBuffer = "An abstract base class for output buffers.";
constexpr char const* dip·OutputBuffer·size = "Returns the size of the data stored in the buffer.";
constexpr char const* dip·OutputBuffer·set_size·dip·uint· = "Sets the size of the data stored in the buffer. Must never be larger than\n`dip::OutputBuffer::capacity` or bad things will happen.";
constexpr char const* dip·OutputBuffer·capacity = "Returns the capacity of the buffer (i.e. the size of the memory allocated for\nthe buffer).";
constexpr char const* dip·OutputBuffer·assure_capacity·dip·uint· = "Increases the buffer's `dip::OutputBuffer::capacity` to be at least\n`capacity`. This is used by the writing functions when the buffer is full. Can\nthrow an exception if the buffer implementation doesn't support resizing.";
constexpr char const* dip·OutputBuffer·data = "Returns a pointer to the data.";
constexpr char const* dip·SimpleOutputBuffer = "A simple output buffer implementation.";
constexpr char const* dip·SimpleOutputBuffer·SimpleOutputBuffer·std·vectorgtdip·uint8lt·L = "Constructor.";
constexpr char const* dip·SimpleOutputBuffer·size = "Returns the size of the data stored in the buffer.";
constexpr char const* dip·SimpleOutputBuffer·set_size·dip·uint· = "Sets the size of the data stored in the buffer.";
constexpr char const* dip·SimpleOutputBuffer·capacity = "Returns the capacity of the buffer.";
constexpr char const* dip·SimpleOutputBuffer·assure_capacity·dip·uint· = "Increases the buffer's `dip::SimpleOutputBuffer::capacity` to be at least\n`capacity`. This call invalidates the pointer previously returned by\n`dip::SimpleOutputBuffer::data`.";
constexpr char const* dip·SimpleOutputBuffer·data = "Returns a pointer to the data.";
constexpr char const* dip·FixedOutputBuffer = "An output buffer implementation that cannot be resized.";
constexpr char const* dip·FixedOutputBuffer·FixedOutputBuffer·dip·uint8·P·dip·uint· = "Constructor.";
constexpr char const* dip·FixedOutputBuffer·size = "Returns the size of the data stored in the buffer.";
constexpr char const* dip·FixedOutputBuffer·set_size·dip·uint· = "Sets the size of the data stored in the buffer.";
constexpr char const* dip·FixedOutputBuffer·capacity = "Returns the capacity of the buffer.";
constexpr char const* dip·FixedOutputBuffer·assure_capacity·dip·uint· = "Throws an exception if the buffer doesn't have at least `capacity` bytes.";
constexpr char const* dip·FixedOutputBuffer·data = "Returns a pointer to the data.";
constexpr char const* dip·ImageReadICS·Image·L·String·CL·RangeArray·CL·Range·CL·String·CL = "Read the image in the ICS file `filename` and puts it in `out`.";
constexpr char const* dip·ImageReadICS·Image·L·String·CL·UnsignedArray·CL·UnsignedArray·CL·UnsignedArray·CL·Range·CL·String·CL = "This function is an overload of the previous function that defines the ROI\nusing different parameters.";
constexpr char const* dip·ImageReadICSInfo·String·CL = "Reads image information and metadata from the ICS file `filename`, without\nreading the actual pixel data. See `dip::ImageReadICS` for more details on the\nfile format and the handling of `filename`.";
constexpr char const* dip·ImageIsICS·String·CL = "Returns true if the file `filename` is an ICS file.";
constexpr char const* dip·ImageWriteICS·Image·CL·String·CL·StringArray·CL·dip·uint··StringSet·CL = "Writes `image` as an ICS file.";
constexpr char const* dip·ImageReadTIFF·Image·L·String·CL·Range··RangeArray·CL·Range·CL·String·CL = "Reads an image from the TIFF file `filename` and puts it in `out`.";
constexpr char const* dip·ImageReadTIFF·Image·L·String·CL·Range·CL·UnsignedArray·CL·UnsignedArray·CL·UnsignedArray·CL·Range·CL·String·CL = "This function is an overload of the previous function that defines the ROI\nusing different parameters.";
constexpr char const* dip·ImageReadTIFFSeries·Image·L·StringArray·CL·String·CL = "Reads a set of 2D TIFF images as a single 3D image.";
constexpr char const* dip·ImageReadTIFFInfo·String·CL·dip·uint· = "Reads image information and metadata from the TIFF file `filename`, without\nreading the actual pixel data. See `dip::ImageReadTIFF` for more details on\nthe handling of `filename` and `imageNumber`.";
constexpr char const* dip·ImageIsTIFF·String·CL = "Returns true if the file `filename` is a TIFF file.";
constexpr char const* dip·ImageWriteTIFF·Image·CL·String·CL·String·CL·dip·uint· = "Writes `image` as a TIFF file.";
constexpr char const* dip·ImageReadJPEG·Image·L·String·CL = "Reads an image from the JPEG file `filename` and puts it in `out`.";
constexpr char const* dip·ImageReadJPEGInfo·String·CL = "Reads image information and metadata from the JPEG file `filename`, without\nreading the actual pixel data. See `dip::ImageReadJPEG` for more details on\nthe handling of `filename`.";
constexpr char const* dip·ImageIsJPEG·String·CL = "Returns true if the file `filename` is a JPEG file.";
constexpr char const* dip·ImageReadJPEG·Image·L·void·CP·dip·uint· = "Reads an image from the JPEG-encoded buffer and puts it in `out`.";
constexpr char const* dip·ImageReadJPEGInfo·void·CP·dip·uint· = "Reads image information and metadata from the JPEG-encoded buffer, without\nreading the actual pixel data.";
constexpr char const* dip·ImageWriteJPEG·Image·CL·String·CL·dip·uint· = "Writes `image` as a JPEG file.";
constexpr char const* dip·ImageWriteJPEG·Image·CL·OutputBuffer·L·dip·uint· = "Encodes `image` as a JPEG file and writes it to a user-created buffer. See\n`dip::ImageWriteJPEG` for details.";
constexpr char const* dip·ImageWriteJPEG·Image·CL·dip·uint· = "Encodes `image` as a JPEG file and writes it to a buffer that is returned. See\n`dip::ImageWriteJPEG` for details.";
constexpr char const* dip·ImageReadPNG·Image·L·String·CL = "Reads an image from the PNG file `filename` and puts it in `out`.";
constexpr char const* dip·ImageReadPNGInfo·String·CL = "Reads image information and metadata from the PNG file `filename`, without\nreading the actual pixel data. See `dip::ImageReadPNG` for more details on the\nhandling of `filename`.";
constexpr char const* dip·ImageIsPNG·String·CL = "Returns true if the file `filename` is a PNG file.";
constexpr char const* dip·ImageReadPNG·Image·L·void·CP·dip·uint· = "Reads an image from the PNG-encoded buffer and puts it in `out`.";
constexpr char const* dip·ImageReadPNGInfo·void·CP·dip·uint· = "Reads image information and metadata from the PNG-encoded buffer, without\nreading the actual pixel data.";
constexpr char const* dip·ImageWritePNG·Image·CL·String·CL·dip·sint··StringSet·CL·dip·uint· = "Writes `image` as a PNG file.";
constexpr char const* dip·ImageWritePNG·Image·CL·OutputBuffer·L·dip·sint··StringSet·CL·dip·uint· = "Encodes `image` as a PNG file and writes it to a user-created buffer. See\n`dip::ImageWritePNG` for details.";
constexpr char const* dip·ImageWritePNG·Image·CL·dip·sint··StringSet·CL·dip·uint· = "Encodes `image` as a PNG file and writes it to a buffer that is returned. See\n`dip::ImageWritePNG` for details.";
constexpr char const* dip·ImageReadNPY·Image·L·String·CL = "Reads a numeric array from the NumPy NPY file `filename` and puts it in `out`.";
constexpr char const* dip·ImageReadNPYInfo·String·CL = "Reads array information (size and data type) from the NumPy NPY file\n`filename`, without reading the actual pixel data. See `dip::ImageReadNPY` for\nmore details on the handling of `filename`.";
constexpr char const* dip·ImageIsNPY·String·CL = "Returns true if the file `filename` is a NPY file.";
constexpr char const* dip·ImageWriteNPY·Image·CL·String·CL = "Writes `image` as a numeric array to a NumPy NPY file.";
constexpr char const* dip·FileGetExtensionPosition·String·CL = "Returns the location of the dot that separates the extension, or\n`dip::String::npos` if there is no dot.";
constexpr char const* dip·FileHasExtension·String·CL = "Returns true if the file name has an extension.";
constexpr char const* dip·FileGetExtension·String·CL = "Gets the extension for the given file name, or an empty string if there's no\nextension.";
constexpr char const* dip·FileCompareExtension·String·CL·String·CL = "Returns true if the file name has the given extension.";
constexpr char const* dip·FileAddExtension·String·CL·String·CL = "Adds the given extension to the file name, replacing any existing extension.";
constexpr char const* dip·FileAppendExtension·String·CL·String·CL = "Appends the given extension to the file name.";
constexpr char const* dip·Framework = "Frameworks are the basis of most pixel-based processing in *DIPlib*.";
constexpr char const* dip·Framework·SingletonExpandedSize·UnsignedArray·L·UnsignedArray·CL = "Determines the singleton-expanded size as a combination of the two sizes.";
constexpr char const* dip·Framework·SingletonExpandedSize·ImageConstRefArray·CL = "Determines if images can be singleton-expanded to the same size, and what that\nsize would be.";
constexpr char const* dip·Framework·SingletonExpandedSize·ImageArray·CL = "Determines if images can be singleton-expanded to the same size, and what that\nsize would be.";
constexpr char const* dip·Framework·SingletonExpendedTensorElements·ImageArray·CL = "Determines if tensors in images can be singleton-expanded to the same size,\nand what that size would be.";
constexpr char const* dip·Framework·OptimalProcessingDim·Image·CL = "Determines the best processing dimension, which is the one with the smallest\nstride, except if that dimension is very small and there's a longer dimension.";
constexpr char const* dip·Framework·OptimalProcessingDim·Image·CL·UnsignedArray·CL = "Determines the best processing dimension as above, but giving preference to a\ndimension where `kernelSizes` is large also.";
constexpr char const* dip·Framework·ScanOption = "Defines options to the `dip::Framework::Scan` function.";
constexpr char const* dip·Framework·ScanOption·NoMultiThreading = "Do not call the line filter simultaneously from multiple threads (it is not\nthread safe).";
constexpr char const* dip·Framework·ScanOption·NeedCoordinates = "The line filter needs the coordinates to the first pixel in the buffer.";
constexpr char const* dip·Framework·ScanOption·TensorAsSpatialDim = "Tensor dimensions are treated as a spatial dimension for scanning, ensuring\nthat the line scan filter always gets scalar pixels.";
constexpr char const* dip·Framework·ScanOption·ExpandTensorInBuffer = "The line filter always gets input tensor elements as a standard, column-major\nmatrix.";
constexpr char const* dip·Framework·ScanOption·NoSingletonExpansion = "Inhibits singleton expansion of input images.";
constexpr char const* dip·Framework·ScanOption·NotInPlace = "The line filter can write to the output buffers without affecting the input\nbuffers.";
constexpr char const* dip·Framework·ScanOptions = "Combines any number of `dip::Framework::ScanOption` constants together.";
constexpr char const* dip·Framework·ScanBuffer = "Structure that holds information about input or output pixel buffers for the\n`dip::Framework::Scan` callback function object.";
constexpr char const* dip·Framework·ScanBuffer·buffer = "Pointer to pixel data for image line, to be cast to expected data type.";
constexpr char const* dip·Framework·ScanBuffer·stride = "Stride to walk along pixels.";
constexpr char const* dip·Framework·ScanBuffer·tensorStride = "Stride to walk along tensor elements.";
constexpr char const* dip·Framework·ScanBuffer·tensorLength = "Number of tensor elements.";
constexpr char const* dip·Framework·ScanLineFilterParameters = "Parameters to the line filter for `dip::Framework::Scan`.";
constexpr char const* dip·Framework·ScanLineFilterParameters·inBuffer = "Input buffers (1D)";
constexpr char const* dip·Framework·ScanLineFilterParameters·outBuffer = "Output buffers (1D)";
constexpr char const* dip·Framework·ScanLineFilterParameters·bufferLength = "Number of pixels in each buffer";
constexpr char const* dip·Framework·ScanLineFilterParameters·dimension = "Dimension along which the line filter is applied";
constexpr char const* dip·Framework·ScanLineFilterParameters·position = "Coordinates of first pixel in line";
constexpr char const* dip·Framework·ScanLineFilterParameters·tensorToSpatial = "`true` if the tensor dimension was converted to spatial dimension";
constexpr char const* dip·Framework·ScanLineFilterParameters·thread = "Thread number";
constexpr char const* dip·Framework·ScanLineFilter = "Prototype line filter for `dip::Framework::Scan`.";
constexpr char const* dip·Framework·ScanLineFilter·Filter·ScanLineFilterParameters·CL = "The derived class must must define this method, this is the actual line\nfilter.";
constexpr char const* dip·Framework·ScanLineFilter·SetNumberOfThreads·dip·uint· = "The derived class can define this function for setting up the processing.";
constexpr char const* dip·Framework·ScanLineFilter·GetNumberOfOperations·dip·uint··dip·uint··dip·uint· = "The derived class can define this function for helping to determine whether to\ncompute in parallel or not. It must return the number of clock cycles per\ninput pixel. The default is valid for an arithmetic-like operation.";
constexpr char const* dip·Framework·ScanLineFilter·negScanLineFilter = "A virtual destructor guarantees that we can destroy a derived class by a\npointer to base";
constexpr char const* dip·Framework·Scan·ImageConstRefArray·CL·ImageRefArray·L·DataTypeArray·CL·DataTypeArray·CL·DataTypeArray·CL·UnsignedArray·CL·ScanLineFilter·L·ScanOptions· = "Framework for pixel-based processing of images.";
constexpr char const* dip·Framework·ScanSingleOutput·Image·L·DataType··ScanLineFilter·L·ScanOptions· = "Calls `dip::Framework::Scan` with one output image, which is already forged.\nThe `lineFilter` will be called with an output buffer of type `bufferType`.";
constexpr char const* dip·Framework·ScanSingleInput·Image·CL·Image·CL·DataType··ScanLineFilter·L·ScanOptions· = "Calls `dip::Framework::Scan` with one input image and a mask image, and no\noutput image.";
constexpr char const* dip·Framework·ScanMonadic·Image·CL·Image·L·DataType··DataType··dip·uint··ScanLineFilter·L·ScanOptions· = "Calls `dip::Framework::Scan` with one input image and one output image.";
constexpr char const* dip·Framework·ScanDyadic·Image·CL·Image·CL·Image·L·DataType··DataType··DataType··ScanLineFilter·L·ScanOptions· = "Calls `dip::Framework::Scan` with two input images and one output image.";
constexpr char const* dip·Framework·VariadicScanLineFilter·T = "An implementation of the ScanLinefilter for N input images and 1 output image.";
constexpr char const* dip·Framework·NewMonadicScanLineFilter·T·F·CL·dip·uint· = "Support for quickly defining monadic operators (1 input image, 1 output\nimage). See `dip::Framework::VariadicScanLineFilter`.";
constexpr char const* dip·Framework·NewDyadicScanLineFilter·T·F·CL·dip·uint· = "Support for quickly defining dyadic operators (2 input images, 1 output\nimage). See `dip::Framework::VariadicScanLineFilter`.";
constexpr char const* dip·Framework·NewTriadicScanLineFilter·T·F·CL·dip·uint· = "Support for quickly defining triadic operators (3 input images, 1 output\nimage). See `dip::Framework::VariadicScanLineFilter`.";
constexpr char const* dip·Framework·NewTetradicScanLineFilter·T·F·CL·dip·uint· = "Support for quickly defining tetradic operators (4 input images, 1 output\nimage). See `dip::Framework::VariadicScanLineFilter`.";
constexpr char const* dip·Framework·SeparableOption = "Defines options to the `dip::Framework::Separable` function.";
constexpr char const* dip·Framework·SeparableOption·NoMultiThreading = "Do not call the line filter simultaneously from multiple threads (it is not\nthread safe).";
constexpr char const* dip·Framework·SeparableOption·AsScalarImage = "The line filter is called for each tensor element separately, and thus always\nsees pixels as scalar values.";
constexpr char const* dip·Framework·SeparableOption·ExpandTensorInBuffer = "The line filter always gets input tensor elements as a standard, column-major\nmatrix.";
constexpr char const* dip·Framework·SeparableOption·UseOutputBorder = "The output line buffer also has space allocated for a border.";
constexpr char const* dip·Framework·SeparableOption·DontResizeOutput = "The output image has the right size; it can differ from the input size.";
constexpr char const* dip·Framework·SeparableOption·UseInputBuffer = "The line filter can modify the input data without affecting the input image;\nsamples are guaranteed to be contiguous.";
constexpr char const* dip·Framework·SeparableOption·UseOutputBuffer = "The output buffer is guaranteed to have contiguous samples.";
constexpr char const* dip·Framework·SeparableOption·CanWorkInPlace = "The input and output buffer are allowed to both point to the same memory.";
constexpr char const* dip·Framework·SeparableOption·UseRealComponentOfOutput = "If the buffer type is complex, and the output type is not, cast by taking the\nreal component of the complex data, rather than the modulus.";
constexpr char const* dip·Framework·SeparableOptions = "Combines any number of `dip::Framework::SeparableOption` constants together.";
constexpr char const* dip·Framework·SeparableBuffer = "Structure that holds information about input or output pixel buffers for the\n`dip::Framework::Separable` callback function object.";
constexpr char const* dip·Framework·SeparableBuffer·buffer = "Pointer to pixel data for image line, to be cast to expected data type.";
constexpr char const* dip·Framework·SeparableBuffer·length = "Length of the buffer, not counting the expanded boundary";
constexpr char const* dip·Framework·SeparableBuffer·border = "Length of the expanded boundary at each side of the buffer.";
constexpr char const* dip·Framework·SeparableBuffer·stride = "Stride to walk along pixels.";
constexpr char const* dip·Framework·SeparableBuffer·tensorStride = "Stride to walk along tensor elements.";
constexpr char const* dip·Framework·SeparableBuffer·tensorLength = "Number of tensor elements.";
constexpr char const* dip·Framework·SeparableLineFilterParameters = "Parameters to the line filter for `dip::Framework::Separable`.";
constexpr char const* dip·Framework·SeparableLineFilterParameters·inBuffer = "Input buffer (1D)";
constexpr char const* dip·Framework·SeparableLineFilterParameters·outBuffer = "Output buffer (1D)";
constexpr char const* dip·Framework·SeparableLineFilterParameters·dimension = "Dimension along which the line filter is applied";
constexpr char const* dip·Framework·SeparableLineFilterParameters·pass = "Pass number (0..nPasses-1)";
constexpr char const* dip·Framework·SeparableLineFilterParameters·nPasses = "Number of passes (typically nDims)";
constexpr char const* dip·Framework·SeparableLineFilterParameters·position = "Coordinates of first pixel in line";
constexpr char const* dip·Framework·SeparableLineFilterParameters·tensorToSpatial = "`true` if the tensor dimension was converted to spatial dimension";
constexpr char const* dip·Framework·SeparableLineFilterParameters·thread = "Thread number";
constexpr char const* dip·Framework·SeparableLineFilter = "Prototype line filter for `dip::Framework::Separable`.";
constexpr char const* dip·Framework·SeparableLineFilter·Filter·SeparableLineFilterParameters·CL = "The derived class must must define this method, this is the actual line\nfilter.";
constexpr char const* dip·Framework·SeparableLineFilter·SetNumberOfThreads·dip·uint· = "The derived class can define this function for setting up the processing.";
constexpr char const* dip·Framework·SeparableLineFilter·GetNumberOfOperations·dip·uint··dip·uint··dip·uint··dip·uint· = "The derived class can define this function for helping to determine whether to\nwhether to compute in parallel or not. It must return the number of clock\ncycles per image line. The default is valid for a convolution-like operation.";
constexpr char const* dip·Framework·SeparableLineFilter·negSeparableLineFilter = "A virtual destructor guarantees that we can destroy a derived class by a\npointer to base";
constexpr char const* dip·Framework·Separable·Image·CL·Image·L·DataType··DataType··BooleanArray··UnsignedArray··BoundaryConditionArray··SeparableLineFilter·L·SeparableOptions· = "Framework for separable filtering of images.";
constexpr char const* dip·Framework·OneDimensionalLineFilter·Image·CL·Image·L·DataType··DataType··DataType··dip·uint··dip·uint··BoundaryCondition··SeparableLineFilter·L·SeparableOptions· = "Framework for filtering of image lines. This is a version of\n`dip::Framework::Separable` that works along one dimension only.";
constexpr char const* dip·Framework·FullOption = "Defines options to the `dip::Framework::Full` function.";
constexpr char const* dip·Framework·FullOption·NoMultiThreading = "Do not call the line filter simultaneously from multiple threads (it is not\nthread safe).";
constexpr char const* dip·Framework·FullOption·AsScalarImage = "The line filter is called for each tensor element separately, and thus always\nsees pixels as scalar values.";
constexpr char const* dip·Framework·FullOption·ExpandTensorInBuffer = "The line filter always gets input tensor elements as a standard, column-major\nmatrix.";
constexpr char const* dip·Framework·FullOption·BorderAlreadyExpanded = "The input image already has expanded boundaries (see `dip::ExtendImage`, use\n`\"masked\"` option).";
constexpr char const* dip·Framework·FullOptions = "Combines any number of `dip::Framework::FullOption` constants together.";
constexpr char const* dip·Framework·FullBuffer = "Structure that holds information about input or output pixel buffers for the\n`dip::Framework::Full` callback function object.";
constexpr char const* dip·Framework·FullBuffer·buffer = "Pointer to pixel data for image line, to be cast to expected data type.";
constexpr char const* dip·Framework·FullBuffer·stride = "Stride to walk along pixels.";
constexpr char const* dip·Framework·FullBuffer·tensorStride = "Stride to walk along tensor elements.";
constexpr char const* dip·Framework·FullBuffer·tensorLength = "Number of tensor elements.";
constexpr char const* dip·Framework·FullLineFilterParameters = "Parameters to the line filter for `dip::Framework::Full`.";
constexpr char const* dip·Framework·FullLineFilterParameters·inBuffer = "Input buffer (1D)";
constexpr char const* dip·Framework·FullLineFilterParameters·outBuffer = "Output buffer (1D)";
constexpr char const* dip·Framework·FullLineFilterParameters·bufferLength = "Number of pixels in each buffer";
constexpr char const* dip·Framework·FullLineFilterParameters·dimension = "Dimension along which the line filter is applied";
constexpr char const* dip·Framework·FullLineFilterParameters·position = "Coordinates of first pixel in line";
constexpr char const* dip·Framework·FullLineFilterParameters·pixelTable = "The pixel table object describing the neighborhood";
constexpr char const* dip·Framework·FullLineFilterParameters·thread = "Thread number";
constexpr char const* dip·Framework·FullLineFilter = "Prototype line filter for `dip::Framework::Full`.";
constexpr char const* dip·Framework·FullLineFilter·Filter·FullLineFilterParameters·CL = "The derived class must must define this method, this is the actual line\nfilter.";
constexpr char const* dip·Framework·FullLineFilter·SetNumberOfThreads·dip·uint··PixelTableOffsets·CL = "The derived class can define this function for setting up the processing.";
constexpr char const* dip·Framework·FullLineFilter·GetNumberOfOperations·dip·uint··dip·uint··dip·uint··dip·uint· = "The derived class can define this function for helping to determine whether to\ncompute in parallel or not. It must return the number of clock cycles per\nimage line. The default is valid for a convolution-like operation.";
constexpr char const* dip·Framework·FullLineFilter·negFullLineFilter = "A virtual destructor guarantees that we can destroy a derived class by a\npointer to base";
constexpr char const* dip·Framework·Full·Image·CL·Image·L·DataType··DataType··DataType··dip·uint··BoundaryConditionArray·CL·Kernel·CL·FullLineFilter·L·FullOptions· = "Framework for filtering of images with an arbitrary shape neighborhood.";
constexpr char const* dip·Framework·ProjectionOption = "Defines options to the `dip::Framework::Projection` function.";
constexpr char const* dip·Framework·ProjectionOption·NoMultiThreading = "Do not call the projection function simultaneously from multiple threads (it\nis not thread safe).";
constexpr char const* dip·Framework·ProjectionOptions = "Combines any number of `dip::Framework::ProjectionOption` constants together.";
constexpr char const* dip·Framework·ProjectionFunction = "Prototype line filter for `dip::Framework::Projection`.";
constexpr char const* dip·Framework·ProjectionFunction·Project·Image·CL·Image·CL·Image·Sample·L·dip·uint· = "The filter to be applied to each sub-image, which fills out a single sample in\n`out`. The `out` sample is of the `outImageType` type requested in the call to\n`Projection`.";
constexpr char const* dip·Framework·ProjectionFunction·SetNumberOfThreads·dip·uint· = "The derived class can define this function if it needs this information ahead\nof time.";
constexpr char const* dip·Framework·ProjectionFunction·GetNumberOfOperations·dip·uint· = "The derived class can define this function for helping to determine whether to\ncompute in parallel or not. It must return the number of clock cycles per sub-\nimage. The default is valid for a trivial projection operation such as max or\nmean.";
constexpr char const* dip·Framework·ProjectionFunction·negProjectionFunction = "A virtual destructor guarantees that we can destroy a derived class by a\npointer to base";
constexpr char const* dip·Framework·Projection·Image·CL·Image·CL·Image·L·DataType··BooleanArray··ProjectionFunction·L·ProjectionOptions· = "Framework for projecting one or more dimensions of an image.";
constexpr char const* dip·SetBorder·Image·L·Image·Pixel·CL·UnsignedArray·CL = "Sets the pixels at the border of `out` to `value`.";
constexpr char const* dip·ApplyWindow·Image·CL·Image·L·String·CL·dfloat· = "Multiplies the image with a windowing function.";
constexpr char const* dip·DrawLine·Image·L·UnsignedArray·CL·UnsignedArray·CL·Image·Pixel·CL·String·CL = "Draws a Bresenham line in an image.";
constexpr char const* dip·DrawLines·Image·L·CoordinateArray·CL·Image·Pixel·CL·String·CL = "Draws a series of Bresenham lines in an image.";
constexpr char const* dip·DrawPolygon2D·Image·L·Polygon·CL·Image·Pixel·CL·String·CL = "Draws a polygon in a 2D image.";
constexpr char const* dip·DrawEllipsoid·Image·L·FloatArray·CL·FloatArray·CL·Image·Pixel·CL = "Draws a solid ellipsoid in an image.";
constexpr char const* dip·DrawDiamond·Image·L·FloatArray·CL·FloatArray·CL·Image·Pixel·CL = "Draws a solid diamond in an image.";
constexpr char const* dip·DrawBox·Image·L·FloatArray·CL·FloatArray·CL·Image·Pixel·CL = "Draws a solid box (rectangle) in an image.";
constexpr char const* dip·DrawBandlimitedPoint·Image·L·FloatArray··Image·Pixel·CL·FloatArray··dfloat· = "Draws an approximately bandlimited point in the image, in the form of a\nGaussian blob.";
constexpr char const* dip·DrawBandlimitedLine·Image·L·FloatArray··FloatArray··Image·Pixel·CL·dfloat··dfloat· = "Draws an approximately bandlimited line between two points in the image, using\nGaussian profiles.";
constexpr char const* dip·DrawBandlimitedBall·Image·L·dfloat··FloatArray··Image·Pixel·CL·String·CL·dfloat··dfloat· = "Draws an approximately bandlimited ball (disk) or an n-sphere (circle) in an\nimage, using Gaussian profiles.";
constexpr char const* dip·DrawBandlimitedBox·Image·L·FloatArray··FloatArray··Image·Pixel·CL·String·CL·dfloat··dfloat· = "Draws an approximately bandlimited box (rectangle) in an image, using Gaussian\nprofiles.";
constexpr char const* dip·BlendBandlimitedMask·Image·L·Image·CL·Image·CL·IntegerArray· = "Blends `value` into `out` at position `pos`, according to `mask`.";
constexpr char const* dip·FreeTypeTool = "Class used to draw text using a specified font file (TTF, OTF, etc).";
constexpr char const* dip·FreeTypeTool·FreeTypeTool = "A default-constructed object cannot be used until a font is set with\n`dip::FreeTypeTool::SetFont`.";
constexpr char const* dip·FreeTypeTool·FreeTypeTool·String·CL = "This constructor immediately sets a font, see `dip::FreeTypeTool::SetFont` for\ndetails.";
constexpr char const* dip·FreeTypeTool·SetFont·String·CL = "Set the font to be used to render text.";
constexpr char const* dip·FreeTypeTool·SetSize·dfloat· = "Set the font size to be used to render text.";
constexpr char const* dip·FreeTypeTool·DrawText·Image·L·String·CL·FloatArray··Image·Pixel·CL·dfloat··String·CL = "Render text in an existing image.";
constexpr char const* dip·FreeTypeTool·TextInfo = "Data structure returned by `dip::FreeTypeTool::DrawText`.";
constexpr char const* dip·FreeTypeTool·TextInfo·image = "The image with the rendered text.";
constexpr char const* dip·FreeTypeTool·TextInfo·left = "Coordinates within `image` of the point on the baseline at the left edge of\nthe text.";
constexpr char const* dip·FreeTypeTool·TextInfo·right = "Coordinates within `image` of the point on the baseline at the right edge of\nthe text.";
constexpr char const* dip·FreeTypeTool·DrawText·String·CL·dfloat· = "Alternate version of the function above that returns a new image tightly\ncropped around the rendered text.";
constexpr char const* dip·DrawText·Image·L·String·CL·FloatArray··Image·Pixel·CL·dfloat··String·CL = "Draws text with the built-in, fixed-sized glyphs.";
constexpr char const* dip·DrawText·String·CL·dfloat· = "Alternate version of the function above that returns a new image tightly\ncropped around the rendered text.";
constexpr char const* dip·GaussianEdgeClip·Image·CL·Image·L·Image·Pixel·CL·dfloat··dfloat· = "Maps input values through an error function, can be used to generate arbitrary\nband-limited objects.";
constexpr char const* dip·GaussianLineClip·Image·CL·Image·L·Image·Pixel·CL·dfloat··dfloat· = "Maps input values through a Gaussian function, can be used to generate\narbitrary band-limited lines.";
constexpr char const* dip·FillDelta·Image·L·String·CL = "Fills an image with a delta function.";
constexpr char const* dip·CreateDelta·Image·L·UnsignedArray·CL·String·CL = "Creates a delta function image.";
constexpr char const* dip·CreateDelta·UnsignedArray·CL·String·CL = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·CreateGauss·Image·L·FloatArray·CL·UnsignedArray··dfloat··UnsignedArray· = "Creates a Gaussian kernel.";
constexpr char const* dip·CreateGabor·Image·L·FloatArray·CL·FloatArray·CL·dfloat· = "Creates a Gabor kernel.";
constexpr char const* dip·FTEllipsoid·Image·L·FloatArray··dfloat· = "Generates the Fourier transform of an ellipsoid.";
constexpr char const* dip·FTEllipsoid·UnsignedArray·CL·FloatArray··dfloat· = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·FTBox·Image·L·FloatArray··dfloat· = "Generates the Fourier transform of a box.";
constexpr char const* dip·FTBox·UnsignedArray·CL·FloatArray··dfloat· = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·FTCross·Image·L·FloatArray··dfloat· = "Generates the Fourier transform of a cross.";
constexpr char const* dip·FTCross·UnsignedArray·CL·FloatArray··dfloat· = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·FTGaussian·Image·L·FloatArray··dfloat··dfloat· = "Generates the Fourier transform of a Gaussian.";
constexpr char const* dip·FTGaussian·UnsignedArray·CL·FloatArray··dfloat··dfloat· = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·TestObjectParams = "Describes the parameters for a test object, used by `dip::TestObject`.";
constexpr char const* dip·TestObjectParams·objectShape = "Can be `\"ellipsoid\"`, `\"ellipsoid shell\"`, `\"box\"`, `\"box shell\"`, or\n`\"custom\"`.";
constexpr char const* dip·TestObjectParams·objectSizes = "Sizes of the object along each dimension.";
constexpr char const* dip·TestObjectParams·objectAmplitude = "Brightness of object pixels.";
constexpr char const* dip·TestObjectParams·randomShift = "If true, add a random sub-pixel shift in the range [-0.5,0.5].";
constexpr char const* dip·TestObjectParams·generationMethod = "Can be `\"gaussian\"` (spatial domain method) or `\"fourier\"` (frequency\ndomain method).";
constexpr char const* dip·TestObjectParams·modulationDepth = "Strength of modulation, if 0 no modulation is applied.";
constexpr char const* dip·TestObjectParams·modulationFrequency = "Frequency of a sine modulation added to the object, units are periods/pixel.";
constexpr char const* dip·TestObjectParams·pointSpreadFunction = "PSF, can be `\"gaussian\"`, `\"incoherent\"`, or `\"none\"`.";
constexpr char const* dip·TestObjectParams·oversampling = "Determines size of PSF (Gaussian PSF has sigma = 0.9*oversampling).";
constexpr char const* dip·TestObjectParams·backgroundValue = "Background intensity, must be non-negative.";
constexpr char const* dip·TestObjectParams·signalNoiseRatio = "SNR = average object energy divided by average noise power. If SNR > 0, adds a\nmixture of Gaussian and Poisson noise.";
constexpr char const* dip·TestObjectParams·gaussianNoise = "Relative amount of Gaussian noise.";
constexpr char const* dip·TestObjectParams·poissonNoise = "Relative amount of Poisson noise.";
constexpr char const* dip·TestObject·Image·L·TestObjectParams·CL·Random·L = "Generates a test object according to `params`.";
constexpr char const* dip·TestObject·UnsignedArray·CL·TestObjectParams·CL·Random·L = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·TestObject·Image·L·TestObjectParams·CL = "Calls the main `dip::TestObject` function with a default-initialized\n`dip::Random` object.";
constexpr char const* dip·TestObject·UnsignedArray·CL·TestObjectParams·CL = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·FillPoissonPointProcess·Image·L·Random·L·dfloat· = "Fills the binary image `out` with a Poisson point process of `density`.";
constexpr char const* dip·CreatePoissonPointProcess·Image·L·UnsignedArray·CL·Random·L·dfloat· = "Creates a binary image with a Poisson point process of `density`.";
constexpr char const* dip·FillRandomGrid·Image·L·Random·L·dfloat··String·CL·String·CL = "Fills the binary image `out` with a grid that is randomly placed over the\nimage.";
constexpr char const* dip·CreateRandomGrid·Image·L·UnsignedArray·CL·Random·L·dfloat··String·CL·String·CL = "Creates a binary image with a random grid.";
constexpr char const* dip·FillRamp·Image·L·dip·uint··StringSet·CL = "Fills an image with a ramp function.";
constexpr char const* dip·CreateRamp·Image·L·UnsignedArray·CL·dip·uint··StringSet·CL = "Creates a ramp function image.";
constexpr char const* dip·FillXCoordinate·Image·L·StringSet·CL = "Fills an image with a ramp function that increases along the x-axis.";
constexpr char const* dip·CreateXCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates a ramp function image.";
constexpr char const* dip·FillYCoordinate·Image·L·StringSet·CL = "Fills an image with a ramp function that increases along the y-axis.";
constexpr char const* dip·CreateYCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates a ramp function image.";
constexpr char const* dip·FillZCoordinate·Image·L·StringSet·CL = "Fills an image with a ramp function that increases along the z-axis.";
constexpr char const* dip·CreateZCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates a ramp function image.";
constexpr char const* dip·FillRadiusCoordinate·Image·L·StringSet·CL = "Fills an image with the distance to the origin.";
constexpr char const* dip·CreateRadiusCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates an image filled with the distance to the origin.";
constexpr char const* dip·FillRadiusSquareCoordinate·Image·L·StringSet·CL = "Fills an image with the square distance to the origin.";
constexpr char const* dip·CreateRadiusSquareCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates an image filled with the square distance to the origin.";
constexpr char const* dip·FillPhiCoordinate·Image·L·StringSet·CL = "Fills an image with the angle to the x-axis within the x-y plane.";
constexpr char const* dip·CreatePhiCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates an image filled with the angle to the x-axis within the x-y plane.";
constexpr char const* dip·FillThetaCoordinate·Image·L·StringSet·CL = "Fills an image with the angle to the z-axis.";
constexpr char const* dip·CreateThetaCoordinate·Image·L·UnsignedArray·CL·StringSet·CL = "Creates an image filled with the angle to the z-axis.";
constexpr char const* dip·FillCoordinates·Image·L·StringSet·CL·String·CL = "Fills an image with the coordinates of each pixel.";
constexpr char const* dip·CreateCoordinates·Image·L·UnsignedArray·CL·StringSet·CL·String·CL = "Creates an image filled with the coordinates of each pixel.";
constexpr char const* dip·FillDistanceToPoint·Image·L·FloatArray·CL·String·CL·FloatArray· = "Fills an image with the distance to a given point.";
constexpr char const* dip·DistanceToPoint·Image·L·UnsignedArray·CL·FloatArray·CL·String·CL·FloatArray· = "Creates an image filled with the distance to a given point.";
constexpr char const* dip·EuclideanDistanceToPoint·Image·L·UnsignedArray·CL·FloatArray·CL·FloatArray· = "Creates an image filled with the Euclidean distance to a given point.";
constexpr char const* dip·CityBlockDistanceToPoint·Image·L·UnsignedArray·CL·FloatArray·CL·FloatArray· = "Creates an image filled with the city block distance to a given point.";
constexpr char const* dip·UniformNoise·Image·CL·Image·L·Random·L·dfloat··dfloat· = "Adds uniformly distributed white noise to the input image.";
constexpr char const* dip·GaussianNoise·Image·CL·Image·L·Random·L·dfloat· = "Adds normally distributed white noise to the input image.";
constexpr char const* dip·PoissonNoise·Image·CL·Image·L·Random·L·dfloat· = "Adds Poisson-distributed white noise to the input image.";
constexpr char const* dip·BinaryNoise·Image·CL·Image·L·Random·L·dfloat··dfloat· = "Adds noise to the binary input image.";
constexpr char const* dip·SaltPepperNoise·Image·CL·Image·L·Random·L·dfloat··dfloat··dfloat· = "Adds salt-and-pepper noise to the input image.";
constexpr char const* dip·FillColoredNoise·Image·L·Random·L·dfloat··dfloat· = "Fills `out` with colored (Brownian, pink, blue, violet) noise.";
constexpr char const* dip·ColoredNoise·Image·CL·Image·L·Random·L·dfloat··dfloat· = "Adds colored (Brownian, pink, blue, violet) noise to `in`.";
constexpr char const* dip·BresenhamLineIterator = "An iterator to iterate over pixels along a straight line.";
constexpr char const* dip·BresenhamLineIterator·iterator_category = "Iterator category";
constexpr char const* dip·BresenhamLineIterator·value_type = "The type of an offset";
constexpr char const* dip·BresenhamLineIterator·reference = "The type of a reference to an offset";
constexpr char const* dip·BresenhamLineIterator·pointer = "The type of a pointer an offset";
constexpr char const* dip·BresenhamLineIterator·epsilon = "Tolerance used to avoid errors caused by rounding.";
constexpr char const* dip·BresenhamLineIterator·delta = "A distance of almost one pixel.";
constexpr char const* dip·BresenhamLineIterator·BresenhamLineIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·BresenhamLineIterator·BresenhamLineIterator·IntegerArray··UnsignedArray··UnsignedArray·CL = "To construct a useful iterator, provide image strides, and coordinates of the\nstart and end pixels";
constexpr char const* dip·BresenhamLineIterator·BresenhamLineIterator·IntegerArray··FloatArray··UnsignedArray··dip·uint· = "To construct a useful iterator, provide image strides, a step size, a start\nposition, and a length";
constexpr char const* dip·BresenhamLineIterator·swap·BresenhamLineIterator·L = "Swap";
constexpr char const* dip·BresenhamLineIterator·operatortimes·C = "Dereference";
constexpr char const* dip·BresenhamLineIterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·BresenhamLineIterator·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·BresenhamLineIterator·operatoreqeq·BresenhamLineIterator·CL·C = "Equality comparison (is equal if coordinates are identical)";
constexpr char const* dip·BresenhamLineIterator·operatornoteq·BresenhamLineIterator·CL·C = "Inequality comparison (is unequal if coordinates are not identical)";
constexpr char const* dip·BresenhamLineIterator·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·BresenhamLineIterator·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·BresenhamLineIterator·Coordinates·C = "Return the current coordinates in the image";
constexpr char const* dip·BresenhamLineIterator·Offset·C = "Return the current offset";
constexpr char const* dip·BresenhamLineIterator·Length·C = "Return the number of pixels left on the line after the current one";
constexpr char const* dip·GenericImageIterator·T = "A data-type--agnostic version of `dip::ImageIterator`. Use this iterator only\nto write code that does not know at compile-time what the data type of the\nimage is.";
constexpr char const* dip·GenericImageIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·GenericImageIterator·T·value_type = "The type of the pixel, obtained when dereferencing the iterator";
constexpr char const* dip·GenericImageIterator·T·reference = "The type of a reference to a pixel (note dip::Image::CastPixel references a\nvalue in the image)";
constexpr char const* dip·GenericImageIterator·T·pointer = "The type of a pointer to a pixel";
constexpr char const* dip·GenericImageIterator·T·GenericImageIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·GenericImageIterator·T·GenericImageIterator·Image·CL·dip·uint· = "To construct a useful iterator, provide an image and optionally a processing\ndimension";
constexpr char const* dip·GenericImageIterator·T·swap·T·GenericImageIteratorgtSlt·L = "Swap";
constexpr char const* dip·GenericImageIterator·T·operatortimes·C = "Dereference";
constexpr char const* dip·GenericImageIterator·T·operatorsqbra·dip·uint··C = "Index into tensor, `it[index]` is equal to `(*it)[index]`.";
constexpr char const* dip·GenericImageIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·GenericImageIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·GenericImageIterator·T·begin·C = "Get an iterator over the tensor for the current pixel, `it.begin()` is equal\nto `(*it).begin()`.";
constexpr char const* dip·GenericImageIterator·T·end·C = "Get an end iterator over the tensor for the current pixel";
constexpr char const* dip·GenericImageIterator·T·GetLineIterator·T·C = "Get an iterator over the current line";
constexpr char const* dip·GenericImageIterator·T·GetConstLineIterator·T·C = "Get a const iterator over the current line";
constexpr char const* dip·GenericImageIterator·T·operatoreqeq·T·GenericImageIteratorgtSlt·CL·C = "Equality comparison, is equal if the two iterators have the same coordinates.\nIt is possible to compare GenericImageIterator with different images.";
constexpr char const* dip·GenericImageIterator·T·operatornoteq·T·GenericImageIteratorgtSlt·CL·C = "Inequality comparison";
constexpr char const* dip·GenericImageIterator·T·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·GenericImageIterator·T·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·GenericImageIterator·T·Coordinates·C = "Return the current coordinates";
constexpr char const* dip·GenericImageIterator·T·SetCoordinates·UnsignedArray· = "Set the iterator to point at a different location in the image";
constexpr char const* dip·GenericImageIterator·T·Sizes·C = "Return the sizes of the image we're iterating over.";
constexpr char const* dip·GenericImageIterator·T·ProcessingDimensionSize·C = "Return the size along the processing dimension";
constexpr char const* dip·GenericImageIterator·T·Strides·C = "Return the strides used to iterate over the image.";
constexpr char const* dip·GenericImageIterator·T·ProcessingDimensionStride·C = "Return the stride along the processing dimension";
constexpr char const* dip·GenericImageIterator·T·IsOnEdge·C = "Return true if the iterator points at a pixel on the edge of the image.";
constexpr char const* dip·GenericImageIterator·T·Pointer·C = "Return the current pointer";
constexpr char const* dip·GenericImageIterator·T·Pointer·dip·uint··C = "Return a pointer to the tensor element `index`";
constexpr char const* dip·GenericImageIterator·T·Offset·C = "Return the current offset";
constexpr char const* dip·GenericImageIterator·T·Index·C = "Return the current index, which is computed: this function is not trivial";
constexpr char const* dip·GenericImageIterator·T·HasProcessingDimension·C = "True if the processing dimension is set";
constexpr char const* dip·GenericImageIterator·T·ProcessingDimension·C = "Return the processing dimension, the direction of the lines over which the\niterator iterates";
constexpr char const* dip·GenericImageIterator·T·Reset = "Reset the iterator to the first pixel in the image (as it was when first\ncreated)";
constexpr char const* dip·GenericImageIterator·T·Optimize = "Optimizes the order in which the iterator visits the image pixels.";
constexpr char const* dip·GenericImageIterator·T·OptimizeAndFlatten = "Like `Optimize`, but additionally folds dimensions together where possible\n(flattens the image, so that the iterator has fewer dimensions to work with).\nThe processing dimension is not affected.";
constexpr char const* dip·GenericJointImageIterator·T = "A data-type--agnostic version of `dip::JointImageIterator`. Use this iterator\nonly to write code that does not know at compile-time what the data type of\nthe image is.";
constexpr char const* dip·GenericJointImageIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·GenericJointImageIterator·T·value_type = "The type of the pixel, obtained when dereferencing the iterator";
constexpr char const* dip·GenericJointImageIterator·T·reference = "The type of a reference to a pixel (note dip::Image::CastPixel references a\nvalue in the image)";
constexpr char const* dip·GenericJointImageIterator·T·pointer = "The type of a pointer to a pixel";
constexpr char const* dip·GenericJointImageIterator·T·GenericJointImageIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·GenericJointImageIterator·T·GenericJointImageIterator·ImageConstRefArray·CL·dip·uint· = "To construct a useful iterator, provide two images, and optionally a\nprocessing dimension";
constexpr char const* dip·GenericJointImageIterator·T·swap·T·GenericJointImageIteratorgtN__Slt·L = "Swap";
constexpr char const* dip·GenericJointImageIterator·T·Sample·T·dip·uint··C = "Index into image tensor for image `I`";
constexpr char const* dip·GenericJointImageIterator·T·InSample·dip·uint··C = "Index into image tensor for image 0.";
constexpr char const* dip·GenericJointImageIterator·T·OutSample·dip·uint··C = "Index into image tensor for image 1.";
constexpr char const* dip·GenericJointImageIterator·T·Sample·T·C = "Get first tensor element for image `I`.";
constexpr char const* dip·GenericJointImageIterator·T·In·C = "Get pixel for image 0.";
constexpr char const* dip·GenericJointImageIterator·T·Out·C = "Get pixel for image 1.";
constexpr char const* dip·GenericJointImageIterator·T·Pixel·T·C = "Get pixel for image `I`.";
constexpr char const* dip·GenericJointImageIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·GenericJointImageIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·GenericJointImageIterator·T·begin·T·C = "Get an iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·GenericJointImageIterator·T·end·T·C = "Get an end iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·GenericJointImageIterator·T·GetLineIterator·T·C = "Get an iterator over the current line of image `I`";
constexpr char const* dip·GenericJointImageIterator·T·GetConstLineIterator·T·C = "Get a const iterator over the current line of image `I`";
constexpr char const* dip·GenericJointImageIterator·T·operatoreqeq·T·GenericJointImageIteratorgtN__Slt·CL·C = "Equality comparison, is equal if the two iterators have the same coordinates.";
constexpr char const* dip·GenericJointImageIterator·T·operatornoteq·T·GenericJointImageIteratorgtN__Slt·CL·C = "Inequality comparison";
constexpr char const* dip·GenericJointImageIterator·T·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·GenericJointImageIterator·T·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·GenericJointImageIterator·T·Coordinates·C = "Return the current coordinates";
constexpr char const* dip·GenericJointImageIterator·T·SetCoordinates·UnsignedArray· = "Set the iterator to point at a different location in the image";
constexpr char const* dip·GenericJointImageIterator·T·Sizes·C = "Return the sizes of the images we're iterating over.";
constexpr char const* dip·GenericJointImageIterator·T·ProcessingDimensionSize·C = "Return the size along the processing dimension.";
constexpr char const* dip·GenericJointImageIterator·T·Strides·T·C = "Return the strides used to iterate over the image `I`.";
constexpr char const* dip·GenericJointImageIterator·T·ProcessingDimensionStride·T·C = "Return the stride along the processing dimension.";
constexpr char const* dip·GenericJointImageIterator·T·IsOnEdge·C = "Return true if the iterator points at a pixel on the edge of the image.";
constexpr char const* dip·GenericJointImageIterator·T·Pointer·T·dip·uint··C = "Index into image tensor for image `I`";
constexpr char const* dip·GenericJointImageIterator·T·InPointer·dip·uint··C = "Index into image tensor for image 0.";
constexpr char const* dip·GenericJointImageIterator·T·OutPointer·dip·uint··C = "Index into image tensor for image 1.";
constexpr char const* dip·GenericJointImageIterator·T·Pointer·T·C = "Return the current pointer for image `I`";
constexpr char const* dip·GenericJointImageIterator·T·InPointer·C = "Return the current pointer for image 0.";
constexpr char const* dip·GenericJointImageIterator·T·OutPointer·C = "Return the current pointer for image 1.";
constexpr char const* dip·GenericJointImageIterator·T·Offset·T·C = "Return the current offset for image `I`";
constexpr char const* dip·GenericJointImageIterator·T·InOffset·C = "Index into image tensor for image 0.";
constexpr char const* dip·GenericJointImageIterator·T·OutOffset·C = "Index into image tensor for image 1.";
constexpr char const* dip·GenericJointImageIterator·T·Index·C = "Return the current index, which is computed: this function is not trivial";
constexpr char const* dip·GenericJointImageIterator·T·HasProcessingDimension·C = "True if the processing dimension is set";
constexpr char const* dip·GenericJointImageIterator·T·ProcessingDimension·C = "Return the processing dimension, the direction of the lines over which the\niterator iterates.";
constexpr char const* dip·GenericJointImageIterator·T·Reset = "Reset the iterator to the first pixel in the image (as it was when first\ncreated)";
constexpr char const* dip·GenericJointImageIterator·T·Optimize·dip·uint· = "Optimizes the order in which the iterator visits the image pixels.";
constexpr char const* dip·GenericJointImageIterator·T·OptimizeAndFlatten·dip·uint· = "Like `Optimize`, but additionally folds dimensions together where possible\n(flattens the image, so that the iterator has fewer dimensions to work with).\nThe processing dimension is not affected.";
constexpr char const* dip·ImageSliceIterator = "An iterator for slice-by-slice processing of an image. Use it to process a\nmulti-dimensional image as a series of lower-dimensional images.";
constexpr char const* dip·ImageSliceIterator·iterator_category = "Iterator category";
constexpr char const* dip·ImageSliceIterator·value_type = "The type obtained when dereferencing the iterator";
constexpr char const* dip·ImageSliceIterator·difference_type = "The type of distances between iterators";
constexpr char const* dip·ImageSliceIterator·reference = "The type of a reference to `value_type`";
constexpr char const* dip·ImageSliceIterator·pointer = "The type of a pointer to `value_type`";
constexpr char const* dip·ImageSliceIterator·ImageSliceIterator = "Default constructor yields an invalid iterator that cannot be dereferenced or\nused in any way";
constexpr char const* dip·ImageSliceIterator·ImageSliceIterator·Image·CL·dip·uint· = "To construct a useful iterator, provide an image and a processing dimension";
constexpr char const* dip·ImageSliceIterator·swap·ImageSliceIterator·L = "Swap";
constexpr char const* dip·ImageSliceIterator·operatortimes = "Dereference";
constexpr char const* dip·ImageSliceIterator·operatorminusgt = "Dereference";
constexpr char const* dip·ImageSliceIterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·ImageSliceIterator·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·ImageSliceIterator·operatorminus· = "Pre-decrement, but never past the first slice";
constexpr char const* dip·ImageSliceIterator·operatorminus··int· = "Post-decrement, but never past the first slice";
constexpr char const* dip·ImageSliceIterator·operatorpluseq·difference_type· = "Increment by `n`";
constexpr char const* dip·ImageSliceIterator·operatorpluseq·dip·uint· = "Increment by `n`";
constexpr char const* dip·ImageSliceIterator·operatorminuseq·difference_type· = "Decrement by `n`, but never moves the iterator to before the first slice";
constexpr char const* dip·ImageSliceIterator·operatorminuseq·dip·uint· = "Decrement by `n`, but never moves the iterator to before the first slice";
constexpr char const* dip·ImageSliceIterator·operatorminus·ImageSliceIterator·CL·C = "Difference between iterators";
constexpr char const* dip·ImageSliceIterator·operatoreqeq·ImageSliceIterator·CL·C = "Equality comparison";
constexpr char const* dip·ImageSliceIterator·operatornoteq·ImageSliceIterator·CL·C = "Inequality comparison";
constexpr char const* dip·ImageSliceIterator·operatorgt·ImageSliceIterator·CL·C = "Larger than comparison";
constexpr char const* dip·ImageSliceIterator·operatorlt·ImageSliceIterator·CL·C = "Smaller than comparison";
constexpr char const* dip·ImageSliceIterator·operatorgteq·ImageSliceIterator·CL·C = "Not smaller than comparison";
constexpr char const* dip·ImageSliceIterator·operatorlteq·ImageSliceIterator·CL·C = "Not larger than comparison";
constexpr char const* dip·ImageSliceIterator·IsValid·C = "Test to see if the iterator is valid (i.e. not default-constructed); it can\nstill be at end, and thus not dereferenceable";
constexpr char const* dip·ImageSliceIterator·IsAtEnd·C = "Test to see if the iterator reached past the last plane";
constexpr char const* dip·ImageSliceIterator·operator_bool·C = "Test to see if the iterator is valid and can be dereferenced";
constexpr char const* dip·ImageSliceIterator·Coordinate·C = "Return the current position";
constexpr char const* dip·ImageSliceIterator·SetCoordinate·dip·uint· = "Set the iterator to point at a different location in the image";
constexpr char const* dip·ImageSliceIterator·ProcessingDimension·C = "Return the processing dimension, the direction over which the iterator\niterates";
constexpr char const* dip·ImageSliceIterator·Reset = "Reset the iterator to the first image plane (as it was when the iterator first\nwas created)";
constexpr char const* dip·ImageSliceIterator·Set·dip·uint· = "Set the iterator to index `plane`. If `plane` is outside the image domain, the\niterator is still valid, but should not be dereferenced.";
constexpr char const* dip·operatorplus·ImageSliceIterator··dip·sint· = "Increment an image slice iterator by `n`";
constexpr char const* dip·operatorplus·ImageSliceIterator··dip·uint· = "Increment an image slice iterator by `n`";
constexpr char const* dip·operatorminus·ImageSliceIterator··dip·sint· = "Decrement an image slice iterator by `n`, but never moves the iterator to\nbefore the first slide";
constexpr char const* dip·operatorminus·ImageSliceIterator··dip·uint· = "Decrement an image slice iterator by `n`, but never moves the iterator to\nbefore the first slide";
constexpr char const* dip·ImageSliceEndIterator·Image·CL·dip·uint· = "Constructs an end iterator corresponding to a `dip::ImageSliceIterator`";
constexpr char const* dip·ImageTensorIterator·Image·CL = "An iterator for element-by-element processing of a tensor image. Use it to\nprocess a tensor image as a series of scalar images.";
constexpr char const* dip·Wrap·Image·CL·Image·L·IntegerArray· = "Shifts the input image by an integer number of pixels, wrapping the pixels\naround.";
constexpr char const* dip·Subsampling·Image·CL·Image·L·UnsignedArray·CL = "Subsamples the input image.";
constexpr char const* dip·Resampling·Image·CL·Image·L·FloatArray··FloatArray··String·CL·StringArray·CL = "Resamples an image with the given zoom factor and sub-pixel shift.";
constexpr char const* dip·Shift·Image·CL·Image·L·FloatArray·CL·String·CL·StringArray·CL = "Shift an image. Calls `dip::Resampling` with `zoom` set to 1, and uses the\n\"ft\" method by default.";
constexpr char const* dip·ShiftFT·Image·CL·Image·L·FloatArray· = "Modulates the input Fourier spectrum to introduce a shift in the spatial\ndomain";
constexpr char const* dip·ResampleAt·Image·CL·Image·L·FloatCoordinateArray·CL·String·CL·Image·Pixel·CL = "Finds the values of the image at sub-pixel locations `coordinates` by\ninterpolation.";
constexpr char const* dip·ResampleAt·Image·CL·FloatArray·CL·String·CL·Image·Pixel·CL = "Identical to the previous function with the same name, but for a single point.";
constexpr char const* dip·InterpolationFunctionPointer = "Pointer to an interpolation function. Only use pointers returned by\n`dip::PrepareResampleAtUnchecked`.";
constexpr char const* dip·PrepareResampleAtUnchecked·Image·CL·String·CL = "Prepare for repeated calls to `dip::ResampleAtUnchecked`. See\n`dip::ResampleAt`.";
constexpr char const* dip·ResampleAtUnchecked·Image·CL·FloatArray·CL·InterpolationFunctionPointer· = "Similar to `dip::ResampleAt`, but optimized for repeated calls using the same\nparameters. `function` comes from `PrepareResampleAtUnchecked`. `fill` is\nalways 0.";
constexpr char const* dip·ResampleAt·Image·CL·Image·CL·Image·L·String·CL·Image·Pixel·CL = "Resamples an image with sub-pixel locations specified by a coordinate map.";
constexpr char const* dip·Skew·Image·CL·Image·L·FloatArray·CL·dip·uint··String·CL·StringArray·CL = "Skews (shears) an image";
constexpr char const* dip·Skew·Image·CL·Image·L·dfloat··dip·uint··dip·uint··String·CL·String·CL = "Skews (shears) an image";
constexpr char const* dip·Rotation·Image·CL·Image·L·dfloat··dip·uint··dip·uint··String·CL·String·CL = "Rotates an image in one orthogonal plane, over the center of the image.";
constexpr char const* dip·Rotation2D·Image·CL·Image·L·dfloat··String·CL·String·CL = "Rotates a 2D image";
constexpr char const* dip·Rotation3D·Image·CL·Image·L·dfloat··dip·uint··String·CL·String·CL = "Rotates a 3D image in one orthogonal plane";
constexpr char const* dip·Rotation3D·Image·CL·Image·L·dfloat··dfloat··dfloat··String·CL·String·CL = "Applies an arbitrary 3D rotation to a 3D image";
constexpr char const* dip·RotationMatrix2D·Image·L·dfloat· = "Creates a 0D (one pixel) 2x2 matrix image containing a 2D rotation matrix.";
constexpr char const* dip·RotationMatrix3D·Image·L·dfloat··dfloat··dfloat· = "Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix.";
constexpr char const* dip·RotationMatrix3D·Image·L·FloatArray·CL·dfloat· = "Creates a 0D (one pixel) 3x3 matrix image containing a 3D rotation matrix.";
constexpr char const* dip·AffineTransform·Image·CL·Image·L·FloatArray·CL·String·CL = "Applies an arbitrary affine transformation to the 2D or 3D image.";
constexpr char const* dip·WarpControlPoints·Image·CL·Image·L·FloatCoordinateArray·CL·FloatCoordinateArray·CL·dfloat··String·CL = "Warps an image based on a set of control points using thin plate spline\ninterpolation";
constexpr char const* dip·LogPolarTransform2D·Image·CL·Image·L·String·CL = "Computes the log-polar transform of the 2D image.";
constexpr char const* dip·Tile·ImageConstRefArray·CL·Image·L·UnsignedArray· = "Tiles a set of images to form a single image.";
constexpr char const* dip·TileTensorElements·Image·CL·Image·L = "Tiles the tensor elements of `in` to produce a scalar image";
constexpr char const* dip·Concatenate·ImageConstRefArray·CL·Image·L·dip·uint· = "Concatenates a set of images along one dimension.";
constexpr char const* dip·Concatenate·Image·CL·Image·CL·Image·L·dip·uint· = "Concatenates two images.";
constexpr char const* dip·JoinChannels·ImageConstRefArray·CL·Image·L = "Concatenates a set of scalar images along the tensor dimension.";
constexpr char const* dip·SplitChannels·Image·CL = "Splits the tensor elements of a tensor image into individual images.";
constexpr char const* dip·Graph = "A non-directed, edge-weighted graph.";
constexpr char const* dip·Graph·VertexIndex = "Type for indices to vertices";
constexpr char const* dip·Graph·EdgeIndex = "Type for indices to edges";
constexpr char const* dip·Graph·EdgeList = "Type for list of edge indices";
constexpr char const* dip·Graph·Vertex = "A vertex in the graph";
constexpr char const* dip·Graph·Vertex·edges = "The list of indices to edges";
constexpr char const* dip·Graph·Vertex·value = "The value associated to each vertex";
constexpr char const* dip·Graph·Vertex·Vertex·dip·uint··dfloat· = "Construct a vertex with reserved space for the given number of edges.";
constexpr char const* dip·Graph·Edge = "An edge in the graph";
constexpr char const* dip·Graph·Edge·vertices = "The two vertices joined by this edge";
constexpr char const* dip·Graph·Edge·weight = "The weight of this edge";
constexpr char const* dip·Graph·Graph·dip·uint··dip·uint· = "Construct a graph with `nVertices` vertices. Vertices are identified by their\nindex, which is in the range [0,`nVertices`]. `nEdges` is the expected number\nof edges for each vertex, and is used to reserve space for them.";
constexpr char const* dip·Graph·Graph·Image·CL·dip·uint··String·CL = "Construct a graph for the given image.";
constexpr char const* dip·Graph·NumberOfVertices·C = "Returns the number of vertices in the graph.";
constexpr char const* dip·Graph·NumberOfEdges·C = "Returns the number of edges in the graph, including invalid edges.";
constexpr char const* dip·Graph·CountEdges·C = "Counts the number of valid edges in the graph.";
constexpr char const* dip·Graph·Edges·C = "Gets the set of edges in the graph. The weights of the edges are mutable, they\ncan be directly modified. Not all edges connect vertices, use\n`dip::Graph::Edge::IsValid` to test.";
constexpr char const* dip·Graph·EdgeVertex·EdgeIndex··bool··C = "Gets the index to one of the two vertices that are joined by an edge. `which`\nis 0 or 1 to specify which of the two vertices to return.";
constexpr char const* dip·Graph·OtherVertex·EdgeIndex··VertexIndex··C = "Finds the index to the vertex that is joined to the vertex with index `vertex`\nthrough the edge with index `edge`.";
constexpr char const* dip·Graph·EdgeWeight·EdgeIndex··C = "Returns a reference to the weight of the edge with index `edge`. This value is\nmutable even if the graph is `const`.";
constexpr char const* dip·Graph·IsValidEdge·EdgeIndex··C = "Returns `true` if the edge is a valid edge.";
constexpr char const* dip·Graph·EdgeIndices·VertexIndex··C = "Get the indices to the edges that join vertex `vertex`.";
constexpr char const* dip·Graph·VertexValue·VertexIndex··C = "Returns a reference to the value of the vertex `vertex`. This value is mutable\neven if the graph is `const`.";
constexpr char const* dip·Graph·AddVertex·dip·uint··dfloat· = "Adds a vertex to the graph with the given weight and space reserved for the\ngiven number of edges. Returns the index to the new vertex.";
constexpr char const* dip·Graph·AddEdge·VertexIndex··VertexIndex··dfloat· = "Add an edge between vertices `vertex1` and `vertex2`, with weight `weight`. If\nthe edge already exists, update the weight of the edge to be `weight`.";
constexpr char const* dip·Graph·AddEdgeSumWeight·VertexIndex··VertexIndex··dfloat· = "Add an edge between vertices `vertex1` and `vertex2`, with weight `weight`. If\nthe edge already exists, update the weight of the edge by adding `weight` to\nthe existing weight.";
constexpr char const* dip·Graph·DeleteEdge·VertexIndex··VertexIndex· = "Delete the edge between vertices `vertex1` and `vertex2`.";
constexpr char const* dip·Graph·DeleteEdge·EdgeIndex· = "Delete the edge `edge`.";
constexpr char const* dip·Graph·Neighbors·VertexIndex· = "Returns a list of indices to neighboring vertices. The list is created.\n`EdgeIndices` is a more efficient, but less convenient, function.";
constexpr char const* dip·Graph·UpdateEdgeWeights·T·F··C = "Re-computes edge weights using the function `func`, called as `dfloat\nfunc(dfloat val1, dfloat val2)`, where the two inputs to `func` are the value\nof the two vertices.";
constexpr char const* dip·Graph·UpdateEdgeWeights·C = "Re-computes edge weights as the absolute difference between vertex values.";
constexpr char const* dip·Graph·MinimumSpanningForest·std·vectorgtVertexIndexlt·CL·C = "Computes the minimum spanning forest (MSF) using Prim's algorithm. See\n`dip::MinimumSpanningForest` for details. Does not modify `*this*.";
constexpr char const* dip·Graph·RemoveLargestEdges·dip·uint· = "Removes `number` edges with the largest weights from the graph.";
constexpr char const* dip·DirectedGraph = "A directed, edge-weighted graph.";
constexpr char const* dip·DirectedGraph·VertexIndex = "Type for indices to vertices";
constexpr char const* dip·DirectedGraph·EdgeIndex = "Type for indices to edges";
constexpr char const* dip·DirectedGraph·EdgeList = "Type for list of edge indices";
constexpr char const* dip·DirectedGraph·Vertex = "A vertex in the graph";
constexpr char const* dip·DirectedGraph·Vertex·edges = "The list of indices to outgoing edges";
constexpr char const* dip·DirectedGraph·Vertex·value = "The value associated to each vertex";
constexpr char const* dip·DirectedGraph·Vertex·Vertex·dip·uint··dfloat· = "Construct a vertex with reserved space for the given number of edges.";
constexpr char const* dip·DirectedGraph·Edge = "An edge in the graph";
constexpr char const* dip·DirectedGraph·Edge·source = "The vertex that the edge starts at";
constexpr char const* dip·DirectedGraph·Edge·target = "The vertex that the edge goes to";
constexpr char const* dip·DirectedGraph·Edge·weight = "The weight of this edge";
constexpr char const* dip·DirectedGraph·Edge·sibling = "The index to the sibling edge (the one that connects target to source)";
constexpr char const* dip·DirectedGraph·DirectedGraph·dip·uint··dip·uint· = "Construct a directed graph with `nVertices` vertices. Vertices are identified\nby their index, which is in the range [0,`nVertices`]. `nEdges` is the\nexpected number of edges for each vertex, and is used to reserve space for\nthem.";
constexpr char const* dip·DirectedGraph·DirectedGraph·Image·CL·dip·uint··String·CL·String·CL = "Construct a directed graph for the given image.";
constexpr char const* dip·DirectedGraph·DirectedGraph·Graph·CL = "Constructs a directed graph from an undirected graph.";
constexpr char const* dip·DirectedGraph·NumberOfVertices·C = "Returns the number of vertices in the graph.";
constexpr char const* dip·DirectedGraph·NumberOfEdges·C = "Returns the number of edges in the graph, including invalid edges.";
constexpr char const* dip·DirectedGraph·CountEdges·C = "Counts the number of valid edges in the graph.";
constexpr char const* dip·DirectedGraph·Edges·C = "Gets the set of edges in the graph. The weights of the edges are mutable, they\ncan be directly modified. Not all edges connect vertices, use\n`dip::DirectedGraph::Edge::IsValid` to test.";
constexpr char const* dip·DirectedGraph·SourceVertex·EdgeIndex··C = "Finds the index to the vertex that is the source (origin) of the given edge.";
constexpr char const* dip·DirectedGraph·TargetVertex·EdgeIndex··C = "Finds the index to the vertex that is the target (destination) of the given\nedge.";
constexpr char const* dip·DirectedGraph·SiblingEdge·EdgeIndex··C = "Finds the index to the edge that is the sibling (connects the same vertices in\nthe other direction) of the given edge. If it returns `edge`, there is no\nsibling.";
constexpr char const* dip·DirectedGraph·EdgeWeight·EdgeIndex··C = "Returns a reference to the weight of the edge with index `edge`. This value is\nmutable even if the graph is `const`.";
constexpr char const* dip·DirectedGraph·IsValidEdge·EdgeIndex··C = "Returns `true` if the edge is a valid edge.";
constexpr char const* dip·DirectedGraph·EdgeIndices·VertexIndex··C = "Get the indices to the edges that start at vertex `vertex`.";
constexpr char const* dip·DirectedGraph·VertexValue·VertexIndex··C = "Returns a reference to the value of the vertex `vertex`. This value is mutable\neven if the graph is `const`.";
constexpr char const* dip·DirectedGraph·AddVertex·dip·uint··dfloat· = "Adds a vertex to the graph with the given weight and space reserved for the\ngiven number of edges. Returns the index to the new vertex.";
constexpr char const* dip·DirectedGraph·AddEdge·VertexIndex··VertexIndex··dfloat· = "Add an edge from vertex `source` to `target`, with weight `weight`. If the\nedge already exists, update its weight to be `weight`.";
constexpr char const* dip·DirectedGraph·AddEdgeSumWeight·VertexIndex··VertexIndex··dfloat· = "Add an edge from vertex `source` to `target`, with weight `weight`. If the\nedge already exists, update its weight by adding `weight` to the existing\nweight.";
constexpr char const* dip·DirectedGraph·AddEdgePair·VertexIndex··VertexIndex··dfloat· = "Add an edge pair between vertices `vertex1` and `vertex2`, both with weight\n`weight`. If the edges already exist, update their weights to be `weight`.";
constexpr char const* dip·DirectedGraph·AddEdgePair·VertexIndex··VertexIndex··dfloat··dfloat· = "Add an edge pair between vertices `vertex1` and `vertex2`, with weight\n`weight1` and `weight2` respectively. If the edges already exist, update their\nweights to be `weight`.";
constexpr char const* dip·DirectedGraph·AddEdgePairSumWeight·VertexIndex··VertexIndex··dfloat· = "Add an edge pair between vertices `vertex1` and `vertex2`, both with weight\n`weight`. If the edges already exist, update their weight by adding the new\nweight to the existing weight.";
constexpr char const* dip·DirectedGraph·AddEdgePairSumWeight·VertexIndex··VertexIndex··dfloat··dfloat· = "Add an edge pair between vertices `vertex1` and `vertex2`, with weight\n`weight1` and `weight2` respectively. If the edges already exist, update their\nweight by adding the new weight to the existing weight.";
constexpr char const* dip·DirectedGraph·DeleteEdge·VertexIndex··VertexIndex· = "Delete the edge from vertex `source` to `target`.";
constexpr char const* dip·DirectedGraph·DeleteEdgePair·VertexIndex··VertexIndex· = "Delete both edges between vertex `vertex1` and `vertex2`.";
constexpr char const* dip·DirectedGraph·DeleteEdge·EdgeIndex· = "Delete the edge `edge`.";
constexpr char const* dip·DirectedGraph·DeleteEdgePair·EdgeIndex· = "Delete the edge `edge` and its sibling.";
constexpr char const* dip·DirectedGraph·Neighbors·VertexIndex· = "Returns a list of indices to neighboring vertices. The list is created.\n`EdgeIndices` is a more efficient, but less convenient, function.";
constexpr char const* dip·DirectedGraph·UpdateEdgeWeights·T·F··C = "Re-computes edge weights using the function `func`, called as `dfloat\nfunc(dfloat source, dfloat target)`, where the two inputs to `func` are the\nvalue of the two vertices. The sibling edge, if it exists, gets the same\nvalue, it is computed only once. So `func` has to be symmetric.";
constexpr char const* dip·DirectedGraph·UpdateEdgeWeights·C = "Re-computes edge weights as the absolute difference between vertex values.";
constexpr char const* dip·DirectedGraph·IsConnectedTo·VertexIndex· = "Sets the vertex weight to 1 if the vertex is connected to vertex `root`, to 0\notherwise.";
constexpr char const* dip·MinimumSpanningForest·Graph·CL·std·vectorgtGraph·VertexIndexlt·CL = "Computes the minimum spanning forest (MSF) of a graph using Prim's algorithm.";
constexpr char const* dip·GraphCut·DirectedGraph·L·DirectedGraph·VertexIndex··DirectedGraph·VertexIndex· = "Computes the minimum cut of the graph, separating the source node from the\nsink node.";
constexpr char const* dip·Label·Graph·CL = "Connected component analysis of a graph.";
constexpr char const* dip·Label·DirectedGraph·CL = "Connected component analysis of a graph.";
constexpr char const* dip·Histogram = "Computes and holds histograms.";
constexpr char const* dip·Histogram·CountType = "Type of histogram bins. See `dip::DT_COUNT`.";
constexpr char const* dip·Histogram·Configuration = "Configuration information for how the histogram is computed.";
constexpr char const* dip·Histogram·Configuration·lowerBound = "Lower bound for this dimension, corresponds to the lower bound of the first\nbin.";
constexpr char const* dip·Histogram·Configuration·upperBound = "Upper bound for this dimension, corresponds to the upper bound of the last\nbin.";
constexpr char const* dip·Histogram·Configuration·nBins = "Number of bins for this dimension.";
constexpr char const* dip·Histogram·Configuration·binSize = "Size of each bin for this dimension.";
constexpr char const* dip·Histogram·Configuration·Mode = "How to complete the configuration";
constexpr char const* dip·Histogram·Configuration·Mode·COMPUTE_BINSIZE = "Compute `binSize` from the other three values";
constexpr char const* dip·Histogram·Configuration·Mode·COMPUTE_BINS = "Compute `nBins` from the other three values";
constexpr char const* dip·Histogram·Configuration·Mode·COMPUTE_LOWER = "Compute `lowerBound` from the other three values";
constexpr char const* dip·Histogram·Configuration·Mode·COMPUTE_UPPER = "Compute `upperBound` from the other three values";
constexpr char const* dip·Histogram·Configuration·Mode·ESTIMATE_BINSIZE = "Choose `binSize` using the Freedman--Diaconis rule, then compute `nBins`.";
constexpr char const* dip·Histogram·Configuration·Mode·ESTIMATE_BINSIZE_AND_LIMITS = "Like `ESTIMATE_BINSIZE`, but also determines the lower and upper limits";
constexpr char const* dip·Histogram·Configuration·Mode·IS_COMPLETE = "The configuration values will be taken as-is. `lowerIsPercentile` and";
constexpr char const* dip·Histogram·Configuration·mode = "The given value is ignored and replaced by the computed value.";
constexpr char const* dip·Histogram·Configuration·lowerIsPercentile = "If set, `lowerBound` is replaced by the given percentile pixel value.";
constexpr char const* dip·Histogram·Configuration·upperIsPercentile = "If set, `upperBound` is replaced by the given percentile pixel value.";
constexpr char const* dip·Histogram·Configuration·excludeOutOfBoundValues = "If set, pixels outside of the histogram bounds are not counted.";
constexpr char const* dip·Histogram·Configuration·Configuration = "Default-constructed configuration defines 256 bins in the range [0,256].";
constexpr char const* dip·Histogram·Configuration·Configuration·dfloat··dfloat··dfloat· = "A constructor takes a lower and upper bounds, and the bin size. The number of\nbins are computed.";
constexpr char const* dip·Histogram·Configuration·Configuration·dfloat··dfloat··dip·uint· = "A constructor takes a lower and upper bounds, and the number of bins. The bin\nsize is computed.";
constexpr char const* dip·Histogram·Configuration·Configuration·dfloat··dfloat··int· = "A constructor takes a lower and upper bounds, and the number of bins. The bin\nsize is computed.";
constexpr char const* dip·Histogram·Configuration·Configuration·dfloat··dip·uint··dfloat· = "A constructor takes a lower bound, the number of bins and the bin size. The\nupper bound is computed.";
constexpr char const* dip·Histogram·Configuration·Configuration·dfloat··int··dfloat· = "A constructor takes a lower bound, the number of bins and the bin size. The\nupper bound is computed.";
constexpr char const* dip·Histogram·Configuration·Configuration·DataType· = "A constructor takes an image data type, yielding a default histogram\nconfiguration for that data type.";
constexpr char const* dip·Histogram·Configuration·IsOutOfRange·dfloat··C = "Returns true if the value should not be included in the histogram.";
constexpr char const* dip·Histogram·Configuration·FindBin·dfloat··C = "Returns the bin that the value belongs in, assuming `!IsOutOfRange(value)`.";
constexpr char const* dip·Histogram·OptimalConfiguration = "Creates a `dip::Histogram::Configuration` that uses the optimal bin size\naccording to the Freedman--Diaconis rule.";
constexpr char const* dip·Histogram·OptimalConfigurationWithFullRange = "Like `dip::Histogram::OptimalConfiguration`, but includes the full data range\n(min to max); note that this can potentially lead to extremely large\nhistograms.";
constexpr char const* dip·Histogram·ConfigurationArray = "An array of `dip::Histogram::Configuration` objects, one per histogram\ndimension.";
constexpr char const* dip·Histogram·Histogram·Image·CL·Image·CL·ConfigurationArray· = "The constructor takes an image, an optional mask, and configuration options\nfor each histogram dimension.";
constexpr char const* dip·Histogram·Histogram·Image·CL·Image·CL·Configuration· = "This version of the constructor is identical to the previous one, but with a\nsingle configuration parameter instead of an array.";
constexpr char const* dip·Histogram·Histogram·Image·CL·Image·CL·Image·CL·ConfigurationArray· = "A version of the constructor that takes two scalar input images, and\nconstructs their joint histogram (a 2D histogram, equal to the one obtained if\nthe two images were the two channels of a tensor image).";
constexpr char const* dip·Histogram·Histogram·Measurement·IteratorFeature·CL·ConfigurationArray· = "The constructor takes an `IteratorFeature` of a `dip::Measurement` object, and\nconfiguration options for each histogram dimension.";
constexpr char const* dip·Histogram·Histogram·ConfigurationArray· = "An empty histogram with the given configuration. Histogram bins are\ninitialized to 0.";
constexpr char const* dip·Histogram·Histogram·Configuration·CL = "An empty histogram with the given configuration. Histogram bins are\ninitialized to 0.";
constexpr char const* dip·Histogram·Histogram·CountType·CP·Configuration·CL = "Create a 1D histogram around existing data. No ownership is transferred.";
constexpr char const* dip·Histogram·Histogram = "The default-initialized histogram is empty and can only be assigned to.";
constexpr char const* dip·Histogram·swap·Histogram·L = "Swaps `this` and `other`.";
constexpr char const* dip·Histogram·IsInitialized·C = "Returns false for a default-initialized histogram.";
constexpr char const* dip·Histogram·Copy·C = "Deep copy, returns a copy of `this` with its own data segment.";
constexpr char const* dip·Histogram·ReverseLookup·Image·CL·Image·L·BooleanArray· = "Performs a reverse histogram lookup, yielding an image \"painted\" with the\nbin values.";
constexpr char const* dip·Histogram·operatorpluseq·Histogram·CL = "Adds a histogram to *this. `other` must have identical properties.";
constexpr char const* dip·Histogram·operatorminuseq·Histogram·CL = "Subtracts a histogram from *this, using saturated subtraction. `other` must\nhave identical properties.";
constexpr char const* dip·Histogram·Dimensionality·C = "Returns the histogram dimensionality.";
constexpr char const* dip·Histogram·Bins·dip·uint··C = "Returns the number of bins along dimension `dim`";
constexpr char const* dip·Histogram·BinSize·dip·uint··C = "Returns the size of the bins along dimension `dim`";
constexpr char const* dip·Histogram·LowerBound·dip·uint··C = "Returns the lower bound of the histogram for dimension `dim`";
constexpr char const* dip·Histogram·UpperBound·dip·uint··C = "Returns the upper bound of the histogram for dimension `dim`";
constexpr char const* dip·Histogram·BinBoundaries·dip·uint··C = "Returns the bin boundaries along dimension `dim` (`Bins(dim)+1` values).";
constexpr char const* dip·Histogram·BinCenters·dip·uint··C = "Returns the bin centers along dimension `dim`";
constexpr char const* dip·Histogram·BinCenter·dip·uint··dip·uint··C = "Returns the bin center for the given `bin` along dimension `dim`";
constexpr char const* dip·Histogram·Bin·dfloat··C = "Gets the bin for `value` in a 1D histogram";
constexpr char const* dip·Histogram·Bin·dfloat··dfloat··C = "Gets the bin for {`x_value`, `y_value`} in a 2D histogram";
constexpr char const* dip·Histogram·Bin·dfloat··dfloat··dfloat··C = "Gets the bin for {`x_value`, `y_value`, `z_value`} in a 3D histogram";
constexpr char const* dip·Histogram·Bin·FloatArray·CL·C = "Gets the bin for `value` in an nD histogram";
constexpr char const* dip·Histogram·At·dip·uint··C = "Get the value at the given bin in a 1D histogram";
constexpr char const* dip·Histogram·At·dip·uint··dip·uint··C = "Get the value at the given bin in a 2D histogram";
constexpr char const* dip·Histogram·At·dip·uint··dip·uint··dip·uint··C = "Get the value at the given bin in a 3D histogram";
constexpr char const* dip·Histogram·At·UnsignedArray·CL·C = "Get the value at the given bin";
constexpr char const* dip·Histogram·GetImage·C = "Get the image that holds the bin counts. The image is always scalar and of\ntype `dip::DT_COUNT`.";
constexpr char const* dip·Histogram·begin·C = "Returns an iterator to the first bin";
constexpr char const* dip·Histogram·end = "Returns an end iterator";
constexpr char const* dip·Histogram·Origin·C = "Returns a pointer to the first bin";
constexpr char const* dip·Histogram·Count·C = "Returns the total number of elements in the histogram (sum of bins)";
constexpr char const* dip·Histogram·Cumulative = "Converts the histogram to a cumulative histogram. For each bin, it will\ncontain the sum of that bin with all the previous ones.";
constexpr char const* dip·Histogram·GetMarginal·dip·uint··C = "Returns the marginal histogram for dimension `dim`.";
constexpr char const* dip·Histogram·Smooth·FloatArray· = "Smooths the histogram, using Gaussian smoothing with parameters `sigma`.";
constexpr char const* dip·DT_COUNT = "Data type of histogram bins. See `dip::Histogram::CountType`.";
constexpr char const* dip·operatorplus·Histogram·CL·Histogram·CL = "Adds two histograms.";
constexpr char const* dip·operatorminus·Histogram·CL·Histogram·CL = "Subtracts two histograms.";
constexpr char const* dip·operatorltlt·std·ostream·L·Histogram·CL = "You can output a `dip::Histogram` to `std::cout` or any other stream. Some\ninformation about the histogram is printed.";
constexpr char const* dip·CumulativeHistogram·Histogram·CL = "Computes a cumulative histogram from `in`. See `dip::Histogram::Cumulative`.";
constexpr char const* dip·Smooth·Histogram·CL·FloatArray·CL = "Returns a smoothed version of the histogram `in`. See\n`dip::Histogram::Smooth`.";
constexpr char const* dip·Smooth·Histogram·CL·dfloat· = "Returns a smoothed version of the histogram `in`. See\n`dip::Histogram::Smooth`.";
constexpr char const* dip·Mean·Histogram·CL = "Computes the mean value of the data represented by the histogram.";
constexpr char const* dip·Covariance·Histogram·CL = "Computes the covariance matrix of the data represented by the histogram.";
constexpr char const* dip·MarginalPercentile·Histogram·CL·dfloat· = "Computes the marginal percentile value of the data represented by the\nhistogram. The marginal percentile is a percentile computed independently on\neach dimension, and thus is not one of the input values.";
constexpr char const* dip·MarginalMedian·Histogram·CL = "Computes the marginal median value of the data represented by the histogram.\nThe median is the 50th percentile, see `dip::MarginalPercentile` for details.";
constexpr char const* dip·Mode·Histogram·CL = "Returns the mode, the bin with the largest count.";
constexpr char const* dip·PearsonCorrelation·Histogram·CL = "Computes the Pearson correlation coefficient between two images from their\njoint histogram `in`.";
constexpr char const* dip·Regression·Histogram·CL = "Fits a line through the histogram. Returns the slope and intercept of the\nregression line.";
constexpr char const* dip·MutualInformation·Histogram·CL = "Calculates the mutual information, in bits, between two images from their\njoint histogram `in`.";
constexpr char const* dip·Entropy·Histogram·CL = "Calculates the entropy, in bits, of an image from its histogram `in`.";
constexpr char const* dip·GaussianMixtureModel·Histogram·CL·dip·uint··dip·uint· = "Determines the parameters for a Gaussian Mixture Model fitted to the histogram\n`in`.";
constexpr char const* dip·IsodataThreshold·Histogram·CL·dip·uint· = "Determines a set of `nThresholds` thresholds using the Isodata algorithm\n(k-means clustering), and the image's histogram `in`.";
constexpr char const* dip·OtsuThreshold·Histogram·CL = "Determines a threshold using the maximal inter-class variance method by Otsu,\nand the image's histogram `in`.";
constexpr char const* dip·MinimumErrorThreshold·Histogram·CL = "Determines a threshold using the minimal error method method, and the image's\nhistogram `in`.";
constexpr char const* dip·GaussianMixtureModelThreshold·Histogram·CL·dip·uint· = "Determines a set of `nThresholds` thresholds by modeling the histogram with a\nGaussian Mixture Model, and choosing the optimal Bayes thresholds.";
constexpr char const* dip·TriangleThreshold·Histogram·CL·dfloat· = "Determines a threshold using the using the chord method (a.k.a. skewed bi-\nmodality, maximum distance to triangle), and the image's histogram `in`.";
constexpr char const* dip·BackgroundThreshold·Histogram·CL·dfloat··dfloat· = "Determines a threshold using the unimodal background-symmetry method, and the\nimage's histogram `in`.";
constexpr char const* dip·KMeansClustering·Histogram·CL·Histogram·L·Random·L·dip·uint· = "Partitions a (multi-dimensional) histogram into `nClusters` partitions using\nk-means clustering.";
constexpr char const* dip·KMeansClustering·Histogram·CL·Histogram·L·dip·uint· = "Like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·MinimumVariancePartitioning·Histogram·CL·Histogram·L·dip·uint· = "Partitions a (multi-dimensional) histogram into `nClusters` partitions\niteratively using Otsu thresholding along individual dimensions.";
constexpr char const* dip·EqualizationLookupTable·Histogram·CL = "Computes a lookup table that, when applied to an image with the histogram\n`in`, yields an image with a flat histogram (or rather a histogram that is as\nflat as possible).";
constexpr char const* dip·MatchingLookupTable·Histogram·CL·Histogram·CL = "Computes a lookup table that, when applied to an image with the histogram\n`in`, yields an image with a histogram as similar as possible to `example`.";
constexpr char const* dip·PerObjectHistogram·Image·CL·Image·CL·Image·CL·Histogram·Configuration··String·CL·String·CL = "Computes a histogram of grey values in `grey` for each object in `label`.";
constexpr char const* dip·LineIterator·T = "An iterator to iterate over all pixels of an image line.";
constexpr char const* dip·LineIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·LineIterator·T·value_type = "The data type of the pixel, obtained when dereferencing the iterator";
constexpr char const* dip·LineIterator·T·reference = "The type of a reference to a pixel";
constexpr char const* dip·LineIterator·T·pointer = "The type of a pointer to a pixel";
constexpr char const* dip·LineIterator·T·LineIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·LineIterator·T·LineIterator·Image·CL·UnsignedArray·CL·dip·uint· = "To construct a useful iterator, provide an image, the coordinate of the start\npixel, and the processing dimension";
constexpr char const* dip·LineIterator·T·LineIterator·pointer··dip·uint··dip·uint··dip·sint··dip·uint··dip·sint· = "To construct a useful iterator, provide a pointer, the offset within the line,\nthe length of the line, the stride, the number of tensor elements, and the\ntensor stride.";
constexpr char const* dip·LineIterator·T·LineIterator·pointer··dip·uint··dip·sint··dip·uint··dip·sint· = "To construct a useful iterator, provide a pointer, the length of the line, the\nstride, the number of tensor elements, and the tensor stride. The iterator\nstarts at the beginning of the line.";
constexpr char const* dip·LineIterator·T·LineIterator·pointer··dip·uint··dip·uint··dip·sint· = "To construct a useful iterator, provide a pointer, the offset within the line,\nthe length of the line, and the stride. A single tensor element is assumed.";
constexpr char const* dip·LineIterator·T·LineIterator·pointer··dip·uint··dip·sint· = "To construct a useful iterator, provide a pointer, the length of the line, and\nthe stride. A single tensor element is assumed. The iterator starts at the\nbeginning of the line.";
constexpr char const* dip·LineIterator·T·swap·LineIteratorgtTlt·L = "Swap";
constexpr char const* dip·LineIterator·T·operator_LineIteratorltvalue_type_constgt·C = "Convert from non-const iterator to const iterator";
constexpr char const* dip·LineIterator·T·operatortimes·C = "Dereference";
constexpr char const* dip·LineIterator·T·operatorminusgt·C = "Dereference";
constexpr char const* dip·LineIterator·T·operatorsqbra·dip·uint··C = "Index into tensor, `it[0]` is equal to `*it`, but `it[1]` is not equal to\n`*(++it)`.";
constexpr char const* dip·LineIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·LineIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·LineIterator·T·begin·C = "Get an iterator over the tensor for the current pixel";
constexpr char const* dip·LineIterator·T·end·C = "Get an end iterator over the tensor for the current pixel";
constexpr char const* dip·LineIterator·T·cbegin·C = "Get a const iterator over the tensor for the current pixel";
constexpr char const* dip·LineIterator·T·cend·C = "Get an end const iterator over the tensor for the current pixel";
constexpr char const* dip·LineIterator·T·operatoreqeq·LineIteratorgtTlt·CL·C = "Equality comparison";
constexpr char const* dip·LineIterator·T·operatornoteq·LineIteratorgtTlt·CL·C = "Inequality comparison";
constexpr char const* dip·LineIterator·T·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·LineIterator·T·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·LineIterator·T·Coordinate·C = "Return the current coordinate along the line";
constexpr char const* dip·LineIterator·T·Length·C = "Return the number of pixels along the line";
constexpr char const* dip·LineIterator·T·Pointer·C = "Return the current pointer";
constexpr char const* dip·ConstLineIterator·T = "A const iterator to iterate over all pixels of an image line.";
constexpr char const* dip·ImageIterator·T = "An iterator to iterate over all pixels of an image, or all lines of an image.";
constexpr char const* dip·ImageIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·ImageIterator·T·value_type = "The data type of the sample, obtained when dereferencing the iterator";
constexpr char const* dip·ImageIterator·T·reference = "The type of a reference to a sample";
constexpr char const* dip·ImageIterator·T·pointer = "The type of a pointer to a pixel";
constexpr char const* dip·ImageIterator·T·ImageIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator";
constexpr char const* dip·ImageIterator·T·ImageIterator·Image·CL·dip·uint· = "To construct a useful iterator, provide an image and optionally a processing\ndimension";
constexpr char const* dip·ImageIterator·T·ImageIterator·Image·CL·UnsignedArray·CL·UnsignedArray··UnsignedArray·CL·dip·uint· = "To construct a useful iterator, provide an image, an ROI, and optionally a\nprocessing dimension.";
constexpr char const* dip·ImageIterator·T·swap·ImageIteratorgtTlt·L = "Swap";
constexpr char const* dip·ImageIterator·T·operatortimes·C = "Dereference";
constexpr char const* dip·ImageIterator·T·operatorminusgt·C = "Dereference";
constexpr char const* dip·ImageIterator·T·operatorsqbra·dip·uint··C = "Index into tensor, `it[0]` is equal to `*it`, but `it[1]` is not equal to\n`*(++it)`.";
constexpr char const* dip·ImageIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·ImageIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·ImageIterator·T·begin·C = "Get an iterator over the tensor for the current pixel";
constexpr char const* dip·ImageIterator·T·end·C = "Get an end iterator over the tensor for the current pixel";
constexpr char const* dip·ImageIterator·T·cbegin·C = "Get a const iterator over the tensor for the current pixel";
constexpr char const* dip·ImageIterator·T·cend·C = "Get an end const iterator over the tensor for the current pixel";
constexpr char const* dip·ImageIterator·T·GetLineIterator·C = "Get an iterator over the current line";
constexpr char const* dip·ImageIterator·T·GetConstLineIterator·C = "Get a const iterator over the current line";
constexpr char const* dip·ImageIterator·T·operatoreqeq·ImageIteratorgtTlt·CL·C = "Equality comparison";
constexpr char const* dip·ImageIterator·T·operatornoteq·ImageIteratorgtTlt·CL·C = "Inequality comparison";
constexpr char const* dip·ImageIterator·T·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·ImageIterator·T·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·ImageIterator·T·Coordinates·C = "Return the current coordinates";
constexpr char const* dip·ImageIterator·T·SetCoordinates·UnsignedArray· = "Set the iterator to point at a different location in the image";
constexpr char const* dip·ImageIterator·T·Sizes·C = "Return the sizes of the image we're iterating over.";
constexpr char const* dip·ImageIterator·T·ProcessingDimensionSize·C = "Return the size along the processing dimension";
constexpr char const* dip·ImageIterator·T·Strides·C = "Return the strides used to iterate over the image.";
constexpr char const* dip·ImageIterator·T·ProcessingDimensionStride·C = "Return the stride along the processing dimension";
constexpr char const* dip·ImageIterator·T·IsOnEdge·C = "Return true if the iterator points at a pixel on the edge of the image.";
constexpr char const* dip·ImageIterator·T·Pointer·C = "Return the current pointer";
constexpr char const* dip·ImageIterator·T·Offset·C = "Return the current offset";
constexpr char const* dip·ImageIterator·T·Index·C = "Return the current index, which is computed: this function is not trivial";
constexpr char const* dip·ImageIterator·T·HasProcessingDimension·C = "True if the processing dimension is set";
constexpr char const* dip·ImageIterator·T·ProcessingDimension·C = "Return the processing dimension, the direction of the lines over which the\niterator iterates.";
constexpr char const* dip·ImageIterator·T·Reset = "Reset the iterator to the first pixel in the image (as it was when first\ncreated)";
constexpr char const* dip·ImageIterator·T·Optimize = "Optimizes the order in which the iterator visits the image pixels.";
constexpr char const* dip·ImageIterator·T·OptimizeAndFlatten = "Like `Optimize`, but additionally folds dimensions together where possible\n(flattens the image, so that the iterator has fewer dimensions to work with).\nThe processing dimension is not affected.";
constexpr char const* dip·ConstImageIterator·T = "A const iterator to iterate over all pixels of an image, or all lines of an\nimage.";
constexpr char const* dip·JointImageIterator·T = "An iterator to iterate over all pixels of multiple images.";
constexpr char const* dip·JointImageIterator·T·iterator_category = "Iterator category";
constexpr char const* dip·JointImageIterator·T·value_type·T = "The data type of the sample, obtained when dereferencing the iterator";
constexpr char const* dip·JointImageIterator·T·reference·T = "The type of a reference to a sample";
constexpr char const* dip·JointImageIterator·T·pointer·T = "The type of a pointer to a sample";
constexpr char const* dip·JointImageIterator·T·JointImageIterator = "Default constructor yields an invalid iterator that cannot be dereferenced,\nand is equivalent to an end iterator.";
constexpr char const* dip·JointImageIterator·T·JointImageIterator·ImageConstRefArray·CL·dip·uint· = "To construct a useful iterator, provide `N` images (`N` equal to the number of\ntemplate parameters), and optionally a processing dimension.";
constexpr char const* dip·JointImageIterator·T·swap·JointImageIteratorgtTypes_lt·L = "Swap";
constexpr char const* dip·JointImageIterator·T·Sample·T·dip·uint··C = "Index into image tensor for image `I`";
constexpr char const* dip·JointImageIterator·T·InSample·dip·uint··C = "Index into image tensor for image 0.";
constexpr char const* dip·JointImageIterator·T·OutSample·dip·uint··C = "Index into image tensor for image 1.";
constexpr char const* dip·JointImageIterator·T·Sample·T·C = "Get first tensor element for image `I`.";
constexpr char const* dip·JointImageIterator·T·In·C = "Get first tensor element for image 0.";
constexpr char const* dip·JointImageIterator·T·Out·C = "Get first tensor element for image 1.";
constexpr char const* dip·JointImageIterator·T·operatorplusplus = "Pre-increment";
constexpr char const* dip·JointImageIterator·T·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·JointImageIterator·T·begin·T·C = "Get an iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·JointImageIterator·T·end·T·C = "Get an end iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·JointImageIterator·T·cbegin·T·C = "Get a const iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·JointImageIterator·T·cend·T·C = "Get an end const iterator over the tensor for the current pixel of image `I`";
constexpr char const* dip·JointImageIterator·T·GetLineIterator·T·C = "Get an iterator over the current line of image `I`";
constexpr char const* dip·JointImageIterator·T·GetConstLineIterator·T·C = "Get a const iterator over the current line of image `I`";
constexpr char const* dip·JointImageIterator·T·operatoreqeq·T·JointImageIteratorgtOtherTypes_lt·CL·C = "Equality comparison, is equal if the two iterators have the same coordinates.\nIt is possible to compare `JointImageIterators` with different images and\ndifferent types.";
constexpr char const* dip·JointImageIterator·T·operatornoteq·T·JointImageIteratorgtOtherTypes_lt·CL·C = "Inequality comparison";
constexpr char const* dip·JointImageIterator·T·IsAtEnd·C = "Test to see if the iterator reached past the last pixel";
constexpr char const* dip·JointImageIterator·T·operator_bool·C = "Test to see if the iterator is still pointing at a pixel";
constexpr char const* dip·JointImageIterator·T·Coordinates·C = "Return the current coordinates";
constexpr char const* dip·JointImageIterator·T·SetCoordinates·UnsignedArray· = "Set the iterator to point at a different location in the image";
constexpr char const* dip·JointImageIterator·T·Sizes·C = "Return the sizes of the images we're iterating over.";
constexpr char const* dip·JointImageIterator·T·ProcessingDimensionSize·C = "Return the size along the processing dimension.";
constexpr char const* dip·JointImageIterator·T·Strides·T·C = "Return the strides used to iterate over the image `I`.";
constexpr char const* dip·JointImageIterator·T·ProcessingDimensionStride·T·C = "Return the stride along the processing dimension.";
constexpr char const* dip·JointImageIterator·T·IsOnEdge·C = "Return true if the iterator points at a pixel on the edge of the image.";
constexpr char const* dip·JointImageIterator·T·Pointer·T·C = "Return the current pointer for image `I`";
constexpr char const* dip·JointImageIterator·T·InPointer·C = "Return the current pointer for image 0.";
constexpr char const* dip·JointImageIterator·T·OutPointer·C = "Return the current pointer for image 1.";
constexpr char const* dip·JointImageIterator·T·Offset·T·C = "Return the current offset for image `I`";
constexpr char const* dip·JointImageIterator·T·InOffset·C = "Index into image tensor for image 0.";
constexpr char const* dip·JointImageIterator·T·OutOffset·C = "Index into image tensor for image 1.";
constexpr char const* dip·JointImageIterator·T·Index·C = "Return the current index, which is computed: this function is not trivial";
constexpr char const* dip·JointImageIterator·T·HasProcessingDimension·C = "True if the processing dimension is set";
constexpr char const* dip·JointImageIterator·T·ProcessingDimension·C = "Return the processing dimension, the direction of the lines over which the\niterator iterates.";
constexpr char const* dip·JointImageIterator·T·Reset = "Reset the iterator to the first pixel in the image (as it was when first\ncreated)";
constexpr char const* dip·JointImageIterator·T·Optimize·dip·uint· = "Optimizes the order in which the iterator visits the image pixels.";
constexpr char const* dip·JointImageIterator·T·OptimizeAndFlatten·dip·uint· = "Like `Optimize`, but additionally folds dimensions together where possible\n(flattens the image, so that the iterator has fewer dimensions to work with).\nThe processing dimension is not affected.";
constexpr char const* dip·javaio = "Contains all functionality for *DIPjavaio*.";
constexpr char const* dip·javaio·ImageReadJavaIO·Image·L·String·CL·String·CL·dip·uint· = "Reads the image in a file `filename` recognized by a Java `interface` and puts\nit in `out`.";
constexpr char const* dip·Kernel = "Represents the shape and size of a filtering kernel.";
constexpr char const* dip·Kernel·ShapeCode = "Possible shapes of a kernel";
constexpr char const* dip·Kernel·ShapeCode·RECTANGULAR = "A rectangular kernel, the user will use the string `\"rectangular\"`.";
constexpr char const* dip·Kernel·ShapeCode·ELLIPTIC = "An elliptical (or circular) kernel, corresponding to the string\n`\"elliptic\"`.";
constexpr char const* dip·Kernel·ShapeCode·DIAMOND = "A diamond-shaped kernel, corresponding to the string `\"diamond\"`.";
constexpr char const* dip·Kernel·ShapeCode·LINE = "A thin straight line, corresponding to the string `\"line\"`.";
constexpr char const* dip·Kernel·ShapeCode·LEFT_LINE = "The same as `dip::Kernel::ShapeCode::LINE`, but the origin is placed at the\nleftmost end of the line.";
constexpr char const* dip·Kernel·ShapeCode·CUSTOM = "The kernel shape and weights are given by an image.";
constexpr char const* dip·Kernel·Kernel = "The default kernel is a disk with a diameter of 7 pixels.";
constexpr char const* dip·Kernel·Kernel·String·CL = "A string implicitly converts to a kernel, it is interpreted as a shape.";
constexpr char const* dip·Kernel·Kernel·FloatArray··String·CL = "A `dip::FloatArray` implicitly converts to a kernel, it is interpreted as the\nparameter for each dimension. A second argument specifies the shape.";
constexpr char const* dip·Kernel·Kernel·dfloat··String·CL = "A floating-point value implicitly converts to a kernel, it is interpreted as\nthe parameter for all dimensions. A second argument specifies the shape.";
constexpr char const* dip·Kernel·Kernel·ShapeCode··FloatArray· = "Low-level constructor mostly for internal use.";
constexpr char const* dip·Kernel·Kernel·Image· = "An image implicitly converts to a kernel, optionally with weights.";
constexpr char const* dip·Kernel·Shift·IntegerArray· = "Shifts the kernel by the given amount along each of the axes.";
constexpr char const* dip·Kernel·Shift·C = "Retrieves the amount that the is shifted.";
constexpr char const* dip·Kernel·Mirror = "Mirrors the kernel. This has no effect on elliptic or diamond kernels, which\nare always symmetric.";
constexpr char const* dip·Kernel·IsMirrored·C = "True if kernel is mirrored";
constexpr char const* dip·Kernel·IgnoreZeros = "Causes zeros in the kernel image to be ignored when creating a\n`dip::PixelTable`.";
constexpr char const* dip·Kernel·PixelTable·dip·uint··dip·uint··C = "Creates a `dip::PixelTable` structure representing the shape of the kernel,\ngiven the dimensionality `nDim`. Pixel table runs will be along dimension\n`procDim`.";
constexpr char const* dip·Kernel·Sizes·dip·uint··C = "Retrieves the size of the kernel, adjusted to an image of size `imsz`. When\ncomputing required boundary extension, use `Boundary` instead.";
constexpr char const* dip·Kernel·Boundary·dip·uint··C = "Returns the size of the boundary extension along each dimension that is\nnecessary to accommodate the kernel on the edge pixels of the image, given an\nimage of size `imsz`.";
constexpr char const* dip·Kernel·Params·C = "Returns the kernel parameters, not adjusted to image dimensionality.";
constexpr char const* dip·Kernel·Shape·C = "Returns the kernel shape";
constexpr char const* dip·Kernel·ShapeString·C = "Returns the kernel shape";
constexpr char const* dip·Kernel·IsRectangular·C = "Tests to see if the kernel is rectangular";
constexpr char const* dip·Kernel·IsLine·C = "Tests to see if the kernel is a line";
constexpr char const* dip·Kernel·IsCustom·C = "Tests to see if the kernel is a custom shape";
constexpr char const* dip·Kernel·HasWeights·C = "Tests to see if the kernel has weights";
constexpr char const* dip·Kernel·HasComplexWeights·C = "Tests to see if the kernel has complex weights";
constexpr char const* dip·Kernel·NumberOfPixels·dip·uint··C = "Returns the number of pixels in the kernel, given the image dimensionality\n`nDims`. This requires the creation of a `dip::PixelTable` for the kernel, so\nis not a trivial function.";
constexpr char const* dip·LabelMap = "Represents a set of labels (object IDs), and maps them to new ones.";
constexpr char const* dip·LabelMap·LabelMap·T·std·vectorgtUnsignedIntegerTypelt·CL = "Construct a map that maps `objectIDs` to themselves.";
constexpr char const* dip·LabelMap·LabelMap·UnsignedArray·CL = "Construct a map that maps `objectIDs` to themselves.";
constexpr char const* dip·LabelMap·LabelMap·T·UnionFindgtIndexType___ValueType___UnionFunction_lt·CL = "Construct a map from the Union-Find data structure. Must call\n`labels.Relabel()` before converting to a `LabelMap`.";
constexpr char const* dip·LabelMap·LabelMap·LabelType· = "Construct a map that maps objectIDs 1 to `maxLabel` (inclusive) to themselves.";
constexpr char const* dip·LabelMap·DestroyUnknownLabels = "Causes the map, when applied, to map unknown labels to 0 (background).";
constexpr char const* dip·LabelMap·PreserveUnknownLabels = "Causes the map, when applied, to keep unknown labels unchanged. This is the\ndefault.";
constexpr char const* dip·LabelMap·Size·C = "Returns the number of labels known (i.e. explicitly listed in the mapping).\nSee also `dip::LabelMap::Count`.";
constexpr char const* dip·LabelMap·Apply·Image·CL·Image·L·C = "Applies the label map to a label image.";
constexpr char const* dip·LabelMap·Apply·Measurement·CL·C = "Applies the label map to measurement data.";
constexpr char const* dip·LabelMap·operatorandeq·LabelMap·CL = "Combines `*this` and `other` using logical AND.";
constexpr char const* dip·LabelMap·operatororeq·LabelMap·CL = "Combines `*this` and `other` using logical OR.";
constexpr char const* dip·LabelMap·operatorxoreq·LabelMap·CL = "Combines `*this` and `other` using logical XOR.";
constexpr char const* dip·LabelMap·Negate = "Modifies the map such that labels mapped to 0 instead map to themselves, and\nthose mapped to any non-zero label instead map to 0.";
constexpr char const* dip·LabelMap·Relabel = "Updates all target labels to be consecutive integers starting at 1. Zero\nmappings are not affected.";
constexpr char const* dip·LabelMap·operatorsqbra·LabelType· = "Looks up a label in the map and returns the target label by reference.";
constexpr char const* dip·LabelMap·operatorsqbra·LabelType··C = "Looks up a label in the map and returns the target label. If the label is not\npresent, instead returns the label (by default) or 0 (if\n`dip::LabelMap::DestroyUnknownLabels` was called previously).";
constexpr char const* dip·LabelMap·Contains·LabelType··C = "Checks to see if `label` is known (i.e. explicitly listed with a mapping).";
constexpr char const* dip·LabelMap·Count·C = "Counts how many labels have a non-zero mapping (i.e. how many objects are\nselected). See also `dip::LabelMap::Size`.";
constexpr char const* dip·operatorand·LabelMap··LabelMap·CL = "Combines two maps using logical AND. See `operator&=`.";
constexpr char const* dip·operatoror·LabelMap··LabelMap·CL = "Combines two maps using logical OR. See `operator|=`.";
constexpr char const* dip·operatorxor·LabelMap··LabelMap·CL = "Combines two maps using logical XOR. See `operator^=`.";
constexpr char const* dip·operatorneg·LabelMap· = "Applies logical NOT to the map. See `dip::LabelMap::Negate`.";
constexpr char const* dip·OneDimensionalFilter = "Describes a 1D filter";
constexpr char const* dip·OneDimensionalFilter·filter = "Filter weights.";
constexpr char const* dip·OneDimensionalFilter·origin = "Origin of the filter if non-negative.";
constexpr char const* dip·OneDimensionalFilter·symmetry = "Filter shape: `\"\"` == `\"general\"`, `\"even\"`, `\"odd\"`, `\"conj\"`,\n`\"d-even\"`, `\"d-odd\"` or `\"d-conj\"`.";
constexpr char const* dip·OneDimensionalFilter·isComplex = "If true, `filter` contains complex data.";
constexpr char const* dip·OneDimensionalFilterArray = "An array of 1D filters";
constexpr char const* dip·SeparateFilter·Image·CL = "Separates a linear filter (convolution kernel) into a set of 1D filters that\ncan be applied using `dip::SeparableConvolution`.";
constexpr char const* dip·SeparableConvolution·Image·CL·Image·L·OneDimensionalFilterArray·CL·StringArray·CL·BooleanArray· = "Applies a convolution with a filter kernel (PSF) that is separable.";
constexpr char const* dip·ConvolveFT·Image·CL·Image·CL·Image·L·String·CL·String·CL·String·CL·StringArray·CL = "Applies a convolution with a filter kernel (PSF) by multiplication in the\nFourier domain.";
constexpr char const* dip·GeneralConvolution·Image·CL·Image·CL·Image·L·StringArray·CL = "Applies a convolution with a filter kernel (PSF) by direct implementation of\nthe convolution sum.";
constexpr char const* dip·Convolution·Image·CL·Image·CL·Image·L·String·CL·StringArray·CL = "Applies a convolution with a filter kernel (PSF).";
constexpr char const* dip·Uniform·Image·CL·Image·L·Kernel·CL·StringArray·CL = "Applies a convolution with a kernel with uniform weights, leading to an\naverage (mean) filter.";
constexpr char const* dip·GaussFIR·Image·CL·Image·L·FloatArray··UnsignedArray··StringArray·CL·dfloat· = "Finite impulse response implementation of the Gaussian filter and its\nderivatives";
constexpr char const* dip·GaussFT·Image·CL·Image·L·FloatArray··UnsignedArray··dfloat··String·CL·String·CL·StringArray·CL = "Fourier implementation of the Gaussian filter and its derivatives";
constexpr char const* dip·GaussIIR·Image·CL·Image·L·FloatArray··UnsignedArray··StringArray·CL·UnsignedArray··String·CL·dfloat· = "Infinite impulse response implementation of the Gaussian filter and its\nderivatives";
constexpr char const* dip·Gauss·Image·CL·Image·L·FloatArray··UnsignedArray··String·CL·StringArray·CL·dfloat· = "Convolution with a Gaussian kernel and its derivatives";
constexpr char const* dip·FiniteDifference·Image·CL·Image·L·UnsignedArray··String·CL·StringArray·CL·BooleanArray· = "Finite difference derivatives";
constexpr char const* dip·SobelGradient·Image·CL·Image·L·dip·uint··StringArray·CL = "The Sobel derivative filter";
constexpr char const* dip·Derivative·Image·CL·Image·L·UnsignedArray··FloatArray··String·CL·StringArray·CL·dfloat· = "Computes derivatives";
constexpr char const* dip·Dx·Image·CL·Image·L·FloatArray· = "Computes the first derivative along x, see `dip::Derivative`.";
constexpr char const* dip·Dy·Image·CL·Image·L·FloatArray· = "Computes the first derivative along y, see `dip::Derivative`.";
constexpr char const* dip·Dz·Image·CL·Image·L·FloatArray· = "Computes the first derivative along z, see `dip::Derivative`.";
constexpr char const* dip·Dxx·Image·CL·Image·L·FloatArray· = "Computes the second derivative along x, see `dip::Derivative`.";
constexpr char const* dip·Dyy·Image·CL·Image·L·FloatArray· = "Computes the second derivative along y, see `dip::Derivative`.";
constexpr char const* dip·Dzz·Image·CL·Image·L·FloatArray· = "Computes the second derivative along z, see `dip::Derivative`.";
constexpr char const* dip·Dxy·Image·CL·Image·L·FloatArray· = "Computes the first derivative along x and y, see `dip::Derivative`.";
constexpr char const* dip·Dxz·Image·CL·Image·L·FloatArray· = "Computes the first derivative along x and z, see `dip::Derivative`.";
constexpr char const* dip·Dyz·Image·CL·Image·L·FloatArray· = "Computes the first derivative along y and z, see `dip::Derivative`.";
constexpr char const* dip·Gradient·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the gradient of the image, resulting in an *N*-vector image, if the\ninput was *N*-dimensional.";
constexpr char const* dip·GradientMagnitude·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the gradient magnitude of the image, equivalent to `dip::Norm(\ndip::Gradient( in ))`.";
constexpr char const* dip·GradientDirection·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the direction of the gradient of the image, equivalent to\n`dip::Angle( dip::Gradient( in ))`.";
constexpr char const* dip·Curl·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the curl (rotation) of the 2D or 3D vector field `in`.";
constexpr char const* dip·Divergence·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the divergence of the vector field `in`.";
constexpr char const* dip·Hessian·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the Hessian of the image, resulting in a symmetric *NxN* tensor\nimage, if the input was *N*-dimensional.";
constexpr char const* dip·Laplace·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the Laplacian of the image, equivalent to `dip::Trace( dip::Hessian(\nin ))`, but more efficient.";
constexpr char const* dip·Dgg·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Computes the second derivative in the gradient direction.";
constexpr char const* dip·LaplacePlusDgg·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Adds the second derivative in the gradient direction to the Laplacian.";
constexpr char const* dip·LaplaceMinusDgg·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·BooleanArray··dfloat· = "Subtracts the second derivative in the gradient direction from the Laplacian.";
constexpr char const* dip·Sharpen·Image·CL·Image·L·dfloat··FloatArray··String·CL·StringArray·CL·dfloat· = "Sharpens `in` by subtracting the Laplacian of the image.";
constexpr char const* dip·UnsharpMask·Image·CL·Image·L·dfloat··FloatArray··String·CL·StringArray·CL·dfloat· = "Sharpens `in` by subtracting the smoothed image.";
constexpr char const* dip·GaborFIR·Image·CL·Image·L·FloatArray··FloatArray·CL·StringArray·CL·BooleanArray··dfloat· = "Finite impulse response implementation of the Gabor filter";
constexpr char const* dip·GaborIIR·Image·CL·Image·L·FloatArray··FloatArray·CL·StringArray·CL·BooleanArray··IntegerArray·CL·dfloat· = "Recursive infinite impulse response implementation of the Gabor filter";
constexpr char const* dip·Gabor2D·Image·CL·Image·L·FloatArray··dfloat··dfloat··StringArray·CL·dfloat· = "2D Gabor filter with direction parameter";
constexpr char const* dip·LogGaborFilterBank·Image·CL·Image·L·FloatArray·CL·dfloat··dip·uint··String·CL·String·CL = "Applies a log-Gabor filter bank";
constexpr char const* dip·NormalizedConvolution·Image·CL·Image·CL·Image·L·FloatArray·CL·String·CL·StringArray·CL·dfloat· = "Computes the normalized convolution with a Gaussian kernel: a Gaussian\nconvolution for missing or uncertain data.";
constexpr char const* dip·NormalizedDifferentialConvolution·Image·CL·Image·CL·Image·L·dip·uint··FloatArray·CL·String·CL·StringArray·CL·dfloat· = "Computes the normalized differential convolution with a Gaussian kernel: a\nderivative operator for missing or uncertain data.";
constexpr char const* dip·MeanShiftVector·Image·CL·Image·L·FloatArray··String·CL·StringArray·CL·dfloat· = "Computes the mean shift vector for each pixel in the image";
constexpr char const* dip·LookupTable = "Encapsulates the concept of the look-up table (LUT).";
constexpr char const* dip·LookupTable·LookupTable·Image··FloatArray· = "The look-up table values are provided through an image. Optionally, provide\nthe index.";
constexpr char const* dip·LookupTable·HasIndex·C = "True if the LUT has an index.";
constexpr char const* dip·LookupTable·DataType·C = "Returns the data type of the LUT, which will also be the data type of the\nresult of applying the LUT.";
constexpr char const* dip·LookupTable·SetOutOfBoundsValue·dfloat· = "Sets out-of-bounds behavior to using `value`.";
constexpr char const* dip·LookupTable·SetOutOfBoundsValue·dfloat··dfloat· = "Sets out-of-bounds behavior to using `lowerValue` and `upperValue`.";
constexpr char const* dip·LookupTable·KeepInputValueOnOutOfBounds = "Sets out-of-bounds behavior to using the input value.";
constexpr char const* dip·LookupTable·ClampOutOfBoundsValues = "Returns out-of-bounds behavior to the default.";
constexpr char const* dip·LookupTable·Apply·Image·CL·Image·L·String·CL·C = "Apply the LUT to a scalar, real-valued image.";
constexpr char const* dip·LookupTable·Apply·dfloat··String·CL·C = "Apply the LUT to a scalar value.";
constexpr char const* dip·LookupTable·Convert·dip·DataType· = "Converts the LUT to a different data type. Values are clipped to the target\nrange and/or truncated, as applicable. Complex values are converted to non-\ncomplex values by taking the absolute value.";
constexpr char const* dip·Clip·Image·CL·Image·L·dfloat··dfloat··String·CL = "Clips the sample values in `in` to a specified range.";
constexpr char const* dip·ClipLow·Image·CL·Image·L·dfloat· = "Clips the sample values in `in`, putting all values below `low` to `low`.";
constexpr char const* dip·ClipHigh·Image·CL·Image·L·dfloat· = "Clips the sample values in `in`, putting all values above `high` to `high`.";
constexpr char const* dip·ErfClip·Image·CL·Image·L·dfloat··dfloat··String·CL = "Clips the sample values in `in` to a specified range, using the error\nfunction.";
constexpr char const* dip·Zero·Image·CL·Image·L·dfloat· = "Zeros the sample values in `in` that are below `threshold`.";
constexpr char const* dip·Shrinkage·Image·CL·Image·L·dfloat· = "Shrinkage function, also known as soft threshold.";
constexpr char const* dip·ContrastStretch·Image·CL·Image·L·dfloat··dfloat··dfloat··dfloat··String·CL·dfloat··dfloat· = "Applies a mapping function according to the input image's range and the given\noutput range.";
constexpr char const* dip·HistogramEqualization·Image·CL·Image·L·dip·uint· = "Modifies the image such that its histogram is as flat as possible.";
constexpr char const* dip·HistogramMatching·Image·CL·Image·L·Histogram·CL = "Modifies the image such that its histogram is as similar as possible to\n`example`.";
constexpr char const* dip·FlushToZero·Image·CL·Image·L = "Flushes denormal sample values to zero. Denormal floating-point values can\nslow down computation. Only defined for floating-point types, the output is\nthe same type.";
constexpr char const* dip·Round·Image·CL·Image·L = "Computes the nearest integer to each sample (rounds). Only defined for\nfloating-point types, the output is the same type.";
constexpr char const* dip·Ceil·Image·CL·Image·L = "Computes the smallest integer larger or equal to each sample (rounds up). Only\ndefined for floating-point types, the output is the same type.";
constexpr char const* dip·Floor·Image·CL·Image·L = "Computes the largest integer smaller or equal to each sample (rounds down).\nOnly defined for floating-point types, the output is the same type.";
constexpr char const* dip·Truncate·Image·CL·Image·L = "Computes the truncated value of each sample (rounds towards zero). Only\ndefined for floating-point types, the output is the same type.";
constexpr char const* dip·Fraction·Image·CL·Image·L = "Computes the fractional value of each sample (`out = in - dip::Truncate(in)`).\nOnly defined for floating-point types, the output is the same type.";
constexpr char const* dip·Reciprocal·Image·CL·Image·L = "Computes the reciprocal of each sample: `out = in == 0 ? 0 : 1/in`.";
constexpr char const* dip·Square·Image·CL·Image·L = "Computes the square of each sample.";
constexpr char const* dip·Sqrt·Image·CL·Image·L = "Computes the square root of each sample.";
constexpr char const* dip·Exp·Image·CL·Image·L = "Computes the base e exponent (natural exponential) of each sample.";
constexpr char const* dip·Exp2·Image·CL·Image·L = "Computes the base 2 exponent of each sample.";
constexpr char const* dip·Exp10·Image·CL·Image·L = "Computes the base 10 exponent of each sample.";
constexpr char const* dip·Ln·Image·CL·Image·L = "Computes the natural logarithm (base e logarithm) of each sample.";
constexpr char const* dip·Log2·Image·CL·Image·L = "Computes the base 2 logarithm of each sample.";
constexpr char const* dip·Log10·Image·CL·Image·L = "Computes the base 10 logarithm of each sample.";
constexpr char const* dip·Sin·Image·CL·Image·L = "Computes the sine of each sample.";
constexpr char const* dip·Cos·Image·CL·Image·L = "Computes the cosine of each sample.";
constexpr char const* dip·Tan·Image·CL·Image·L = "Computes the tangent of each sample.";
constexpr char const* dip·Asin·Image·CL·Image·L = "Computes the arc sine of each sample.";
constexpr char const* dip·Acos·Image·CL·Image·L = "Computes the arc cosine of each sample.";
constexpr char const* dip·Atan·Image·CL·Image·L = "Computes the arc tangent of each sample.";
constexpr char const* dip·Sinh·Image·CL·Image·L = "Computes the hyperbolic sine of each sample.";
constexpr char const* dip·Cosh·Image·CL·Image·L = "Computes the hyperbolic cosine of each sample.";
constexpr char const* dip·Tanh·Image·CL·Image·L = "Computes the hyperbolic tangent of each sample.";
constexpr char const* dip·BesselJ0·Image·CL·Image·L = "Computes the Bessel functions of the first kind of each sample, of order alpha\n= 0. Precise up to about 7 digits.";
constexpr char const* dip·BesselJ1·Image·CL·Image·L = "Computes the Bessel functions of the first kind of each sample, of order alpha\n= 1. Precise up to about 7 digits.";
constexpr char const* dip·BesselJN·Image·CL·Image·L·dip·uint· = "Computes the Bessel functions of the first kind of each sample, of order\n`alpha`. Precise up to about 7 digits.";
constexpr char const* dip·BesselY0·Image·CL·Image·L = "Computes the Bessel functions of the second kind of each sample, of order\nalpha = 0. Precise up to about 7 digits.";
constexpr char const* dip·BesselY1·Image·CL·Image·L = "Computes the Bessel functions of the second kind of each sample, of order\nalpha = 1. Precise up to about 7 digits.";
constexpr char const* dip·BesselYN·Image·CL·Image·L·dip·uint· = "Computes the Bessel functions of the second kind of each sample, of order\n`alpha`. Precise up to about 7 digits.";
constexpr char const* dip·LnGamma·Image·CL·Image·L = "Computes the natural logarithm of the gamma function of each sample.";
constexpr char const* dip·Erf·Image·CL·Image·L = "Computes the error function of each sample.";
constexpr char const* dip·Erfc·Image·CL·Image·L = "Computes the complementary error function of each sample.";
constexpr char const* dip·Sinc·Image·CL·Image·L = "Computes the sinc function of each sample. $mathrm{sinc}(x) = sin(x)/x$.";
constexpr char const* dip·IsNotANumber·Image·CL·Image·L = "True for each pixel that is NaN.";
constexpr char const* dip·IsInfinite·Image·CL·Image·L = "True for each pixel that is positive or negative infinity.";
constexpr char const* dip·IsFinite·Image·CL·Image·L = "True for each pixel that is not NaN nor infinity.";
constexpr char const* dip·Abs·Image·CL·Image·L = "Computes the absolute value of each sample.";
constexpr char const* dip·Modulus·Image·CL·Image·L = "Computes the modulus (absolute value) of each sample. `dip::Modulus` is an\nalias for `dip::Abs`.";
constexpr char const* dip·SquareModulus·Image·CL·Image·L = "Computes the square of the modulus of each sample.";
constexpr char const* dip·Phase·Image·CL·Image·L = "Computes the phase (angle on complex plane, through `std::arg`) of each\nsample.";
constexpr char const* dip·Real·Image·CL = "Returns the real component of a complex image. Returns `dip::Image::Real` if\nthe input is complex.";
constexpr char const* dip·Imaginary·Image·CL = "Returns the imaginary component of a complex image. Returns\n`dip::Image::Imaginary` if the input is complex";
constexpr char const* dip·Conjugate·Image·CL·Image·L = "Computes the complex conjugate of each sample.";
constexpr char const* dip·Sign·Image·CL·Image·L = "Computes the sign of each sample. Only defined for signed real data types\n(signed integers and floating-point types). Output is of type `dip::DT_SINT8`,\ncontaining values -1, 0 and 1.";
constexpr char const* dip·NearestInt·Image·CL·Image·L = "Computes the integer closest to the value of each sample. Only defined for\nfloating-point types, the output is of type `dip::DT_SINT32`.";
constexpr char const* dip·Supremum·ImageConstRefArray·CL·Image·L = "Computes the sample-wise supremum (maximum) over all the input images. For\nbinary images, this is the same as the union.";
constexpr char const* dip·Supremum·Image·CL·Image·CL·Image·L = "Computes the sample-wise supremum (maximum) of the two input images. For\nbinary images, this is the same as the union.";
constexpr char const* dip·Infimum·ImageConstRefArray·CL·Image·L = "Computes the sample-wise infimum (minimum) over all the input images. For\nbinary images, this is the same as the intersection.";
constexpr char const* dip·Infimum·Image·CL·Image·CL·Image·L = "Computes the sample-wise infimum (minimum) of the two input images. For binary\nimages, this is the same as the intersection.";
constexpr char const* dip·SignedInfimum·Image·CL·Image·CL·Image·L = "Computes the sample-wise signed infimum (minimum) of the two input images:\nreturns `-b` where `b < a`, a otherwise.";
constexpr char const* dip·LinearCombination·Image·CL·Image·CL·Image·L·dfloat··dfloat· = "Computes the linear combination of the two images, sample-wise.";
constexpr char const* dip·LinearCombination·Image·CL·Image·CL·Image·L·dcomplex··dcomplex· = "Computes the linear combination of the two complex images, sample-wise,\nyielding a complex output,";
constexpr char const* dip·Atan2·Image·CL·Image·CL·Image·L = "Computes the four-quadrant arc tangent of `y/x`.";
constexpr char const* dip·Hypot·Image·CL·Image·CL·Image·L = "Computes the square root of the sum of the squares of corresponding samples in\n`a` and `b`.";
constexpr char const* dip·Transpose·Image·CL = "Transposes the tensor image, the data are not copied.";
constexpr char const* dip·ConjugateTranspose·Image·CL·Image·L = "Computes the conjugate transpose of the tensor image `in`.";
constexpr char const* dip·DotProduct·Image·CL·Image·CL·Image·L = "Computes the dot product (inner product) of two vector images.";
constexpr char const* dip·CrossProduct·Image·CL·Image·CL·Image·L = "Computes the cross product (inner product) of two vector images.";
constexpr char const* dip·Norm·Image·CL·Image·L = "Computes the norm of the vector at each pixel in image `in`.";
constexpr char const* dip·SquareNorm·Image·CL·Image·L = "Computes the square of the norm of the vector at each pixel in image `in`.";
constexpr char const* dip·Angle·Image·CL·Image·L = "Computes the angle of the vector at each pixel in image `in`.";
constexpr char const* dip·Orientation·Image·CL·Image·L = "Computes the orientation of the vector at each pixel in image `in`.";
constexpr char const* dip·CartesianToPolar·Image·CL·Image·L = "Converts the vector at each pixel in image `in` from Cartesian coordinates to\npolar (or spherical) coordinates.";
constexpr char const* dip·PolarToCartesian·Image·CL·Image·L = "Converts the vector at each pixel in image `in` from polar (or spherical)\ncoordinates to Cartesian coordinates.";
constexpr char const* dip·Determinant·Image·CL·Image·L = "Computes the determinant of the square matrix at each pixel in image `in`.";
constexpr char const* dip·Trace·Image·CL·Image·L = "Computes the trace of the square matrix at each pixel in image `in`.";
constexpr char const* dip·Rank·Image·CL·Image·L = "Computes the rank of the square matrix at each pixel in image `in`. The output\nis DT_UINT8, under the assumption that we won't have tensor images with a rank\nhigher than 255.";
constexpr char const* dip·Eigenvalues·Image·CL·Image·L = "Computes the eigenvalues of the square matrix at each pixel in image `in`.";
constexpr char const* dip·LargestEigenvalue·Image·CL·Image·L = "Finds the largest eigenvalue of the square matrix at each pixel in image `in`.";
constexpr char const* dip·SmallestEigenvalue·Image·CL·Image·L = "Finds the smallest eigenvalue of the square matrix at each pixel in image\n`in`.";
constexpr char const* dip·EigenDecomposition·Image·CL·Image·L·Image·L = "Computes the eigenvalues and eigenvectors of the square matrix at each pixel\nin image `in`.";
constexpr char const* dip·LargestEigenvector·Image·CL·Image·L = "Finds the largest eigenvector of the symmetric matrix at each pixel in image\n`in`.";
constexpr char const* dip·SmallestEigenvector·Image·CL·Image·L = "Finds the smallest eigenvector of the symmetric matrix at each pixel in image\n`in`.";
constexpr char const* dip·Inverse·Image·CL·Image·L = "Computes the inverse of the square matrix at each pixel in image `in`.";
constexpr char const* dip·PseudoInverse·Image·CL·Image·L·dfloat· = "Computes the pseudo-inverse of the matrix at each pixel in image `in`.";
constexpr char const* dip·SingularValues·Image·CL·Image·L = "Computes the \"thin\" singular value decomposition of the matrix at each pixel\nin image `in`.";
constexpr char const* dip·SingularValueDecomposition·Image·CL·Image·L·Image·L·Image·L = "Computes the \"thin\" singular value decomposition of the matrix at each pixel\nin image `in`.";
constexpr char const* dip·Identity·Image·CL·Image·L = "Creates an image whose pixels are identity matrices.";
constexpr char const* dip·SumTensorElements·Image·CL·Image·L = "Adds all tensor elements, producing a scalar image.";
constexpr char const* dip·ProductTensorElements·Image·CL·Image·L = "Multiplies all tensor elements, producing a scalar image.";
constexpr char const* dip·AllTensorElements·Image·CL·Image·L = "Determines if all tensor elements are non-zero, producing a binary scalar\nimage.";
constexpr char const* dip·AnyTensorElement·Image·CL·Image·L = "Determines if any tensor element is non-zero, producing a binary scalar image.";
constexpr char const* dip·MaximumTensorElement·Image·CL·Image·L = "Takes the maximum tensor element at each pixel, producing a scalar image.";
constexpr char const* dip·MaximumAbsTensorElement·Image·CL·Image·L = "Takes the maximum absolute tensor element at each pixel, producing a scalar\nimage. For float and complex images only.";
constexpr char const* dip·MinimumTensorElement·Image·CL·Image·L = "Takes the minimum tensor element at each pixel, producing a scalar image.";
constexpr char const* dip·MinimumAbsTensorElement·Image·CL·Image·L = "Takes the minimum absolute tensor element at each pixel, producing a scalar\nimage. For float and complex images only.";
constexpr char const* dip·MeanTensorElement·Image·CL·Image·L = "Computes the mean tensor element value at each pixel, producing a scalar\nimage.";
constexpr char const* dip·GeometricMeanTensorElement·Image·CL·Image·L = "Computes the geometric mean tensor element value at each pixel, producing a\nscalar image.";
constexpr char const* dip·SortTensorElements·Image·L = "Sorts the tensor elements within each pixel from largest to smallest. Works\nin-place. `out` must be real-valued.";
constexpr char const* dip·SortTensorElementsByMagnitude·Image·L = "Sorts the tensor elements within each pixel by magnitude from largest to\nsmallest. Works in-place. `out` must be of a floating point or complex type.";
constexpr char const* dip·Select·Image·CL·Image·CL·Image·CL·Image·CL·Image·L·String·CL = "Compares `in1` to `in2` according to `selector`, and writes `in3` or `in4` to\n`out` depending on the result.";
constexpr char const* dip·Select·Image·CL·Image·CL·Image·CL·Image·L = "Writes either `in1` or `in2` to `out` depending on the value of `mask`.";
constexpr char const* dip·Toggle·Image·CL·Image·CL·Image·CL·Image·L = "Writes to `out` whichever of `in1` or `in2` is closest to `in`.";
constexpr char const* dip·Feature = "Contains classes that implement the measurement features.";
constexpr char const* dip·Feature·Type = "The types of measurement features";
constexpr char const* dip·Feature·Type·LINE_BASED = "The feature is derived from `dip::Feature::LineBased`";
constexpr char const* dip·Feature·Type·IMAGE_BASED = "The feature is derived from `dip::Feature::ImageBased`";
constexpr char const* dip·Feature·Type·CHAINCODE_BASED = "The feature is derived from `dip::Feature::ChainCodeBased`";
constexpr char const* dip·Feature·Type·POLYGON_BASED = "The feature is derived from `dip::Feature::PolygonBased`";
constexpr char const* dip·Feature·Type·CONVEXHULL_BASED = "The feature is derived from `dip::Feature::ConvexHullBased`";
constexpr char const* dip·Feature·Type·COMPOSITE = "The feature is derived from `dip::Feature::Composite`";
constexpr char const* dip·Feature·Information = "Information about a measurement feature";
constexpr char const* dip·Feature·Information·name = "The name of the feature, used to identify it";
constexpr char const* dip·Feature·Information·description = "A description of the feature, to be shown to the user";
constexpr char const* dip·Feature·Information·needsGreyValue = "Does the feature need a grey-value image?";
constexpr char const* dip·Feature·InformationArray = "Information about the known measurement features";
constexpr char const* dip·Feature·ValueInformation = "Information about a measurement value, one of the components of a feature";
constexpr char const* dip·Feature·ValueInformation·name = "A short string that identifies the value";
constexpr char const* dip·Feature·ValueInformation·units = "The units for the value";
constexpr char const* dip·Feature·ValueInformationArray = "Information about the values of a measurement feature, or all values of all\nmeasurement features in a `dip::Measurement` object.";
constexpr char const* dip·Feature·Base = "The abstract base class for all measurement features.";
constexpr char const* dip·Feature·Base·information = "Information on the feature";
constexpr char const* dip·Feature·Base·type = "The type of the measurement";
constexpr char const* dip·Feature·Base·Configure·String·CL·dfloat· = "A feature can have configurable parameters. Such a feature can define a\n`Configure` method that the user can access through\n`dip::MeasurementTool::Configure`.";
constexpr char const* dip·Feature·Base·Initialize·Image·CL·Image·CL·dip·uint· = "All measurement features define an `Initialize` method that prepares the\nfeature class to perform measurements on the image. It also gives information\non the feature as applied to that image.";
constexpr char const* dip·Feature·Base·Cleanup = "All measurement features define a `Cleanup` method that is called after\nfinishing the measurement process for one image.";
constexpr char const* dip·Feature·LineBased = "The abstract base class for all line-based measurement features.";
constexpr char const* dip·Feature·LineBased·ScanLine·LineIteratorgtLabelTypelt··LineIteratorgtdfloatlt··UnsignedArray··dip·uint··ObjectIdToIndexMap·CL = "Called once for each image line, to accumulate information about each object.\nThis function is not called in parallel, and hence does not need to be thread-\nsafe.";
constexpr char const* dip·Feature·LineBased·Finish·dip·uint··Measurement·ValueIterator· = "Called once for each object, to finalize the measurement.";
constexpr char const* dip·Feature·ImageBased = "The abstract base class for all image-based measurement features.";
constexpr char const* dip·Feature·ImageBased·Measure·Image·CL·Image·CL·Measurement·IteratorFeature·L = "Called once to compute measurements for all objects.";
constexpr char const* dip·Feature·ChainCodeBased = "The abstract base class for all chain-code--based measurement features.";
constexpr char const* dip·Feature·ChainCodeBased·Measure·ChainCode·CL·Measurement·ValueIterator· = "Called once for each object.";
constexpr char const* dip·Feature·PolygonBased = "The abstract base class for all polygon-based measurement features.";
constexpr char const* dip·Feature·PolygonBased·Measure·Polygon·CL·Measurement·ValueIterator· = "Called once for each object.";
constexpr char const* dip·Feature·ConvexHullBased = "The abstract base class for all convex-hull--based measurement features.";
constexpr char const* dip·Feature·ConvexHullBased·Measure·ConvexHull·CL·Measurement·ValueIterator· = "Called once for each object.";
constexpr char const* dip·Feature·Composite = "The abstract base class for all composite measurement features.";
constexpr char const* dip·Feature·Composite·Dependencies = "Lists the features that the measurement depends on. These features will be\ncomputed and made available to the `Measure` method. This function is always\ncalled after `dip::Feature::Base::Initialize`.";
constexpr char const* dip·Feature·Composite·Compose·Measurement·IteratorObject·L·Measurement·ValueIterator· = "Called once for each object, the input `dependencies` object contains the\nmeasurements for the object from all the features in the\n`dip::Feature::Composite::Dependencies` list.";
constexpr char const* dip·ObjectIdToIndexMap = "Maps object IDs to object indices";
constexpr char const* dip·Measurement = "Contains measurement results, as obtained through\n`dip::MeasurementTool::Measure`.";
constexpr char const* dip·Measurement·ValueType = "The type of the measurement data";
constexpr char const* dip·Measurement·ValueIterator = "A pointer to measurement data, which we can treat as an iterator";
constexpr char const* dip·Measurement·FeatureInformation = "Structure containing information about the features stored in a\n`dip::Measurement` object";
constexpr char const* dip·Measurement·FeatureInformation·name = "Name of the feature";
constexpr char const* dip·Measurement·FeatureInformation·startColumn = "Column for first value of feature";
constexpr char const* dip·Measurement·FeatureInformation·numberValues = "Number of vales in feature";
constexpr char const* dip·Measurement·IteratorFeature = "An iterator to visit all features (column groups) in the `dip::Measurement`\ntable. Can also be seen as a view over a specific feature.";
constexpr char const* dip·Measurement·IteratorFeature·Iterator = "An iterator to visit all objects (rows) within a feature (column group) of the\n`dip::Measurement` table.";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·operatorsqbra·dip·uint··C = "Index to access a specific value";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·operatortimes·C = "Dereference to access the first value";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·begin·C = "Iterator to the first value";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·end·C = "Iterator one past the last value";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·data·C = "A pointer to the first value";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·size·C = "Number of values";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·operatorplusplus = "Pre-increment, to access the next object";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·operatorplusplus·int· = "Post-increment, to access the next object";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·IsAtEnd·C = "True if done iterating (do not call other methods if this is true!)";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·operator_bool·C = "True if the iterator is valid and can be used";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·FeatureName·C = "Name of the feature";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·ObjectID·C = "ID of the object";
constexpr char const* dip·Measurement·IteratorFeature·Iterator·ObjectIndex·C = "Index of the object (row number)";
constexpr char const* dip·Measurement·IteratorFeature·FirstObject·C = "Iterator to the first object for this feature";
constexpr char const* dip·Measurement·IteratorFeature·operatorsqbra·dip·uint··C = "Iterator to the given object for this feature";
constexpr char const* dip·Measurement·IteratorFeature·operatorplusplus = "Pre-increment, to access the next feature";
constexpr char const* dip·Measurement·IteratorFeature·operatorplusplus·int· = "Post-increment, to access the next feature";
constexpr char const* dip·Measurement·IteratorFeature·Subset·dip·uint··dip·uint· = "Selects a subset of values from the current feature. This does not invalidate\nthe iterator.";
constexpr char const* dip·Measurement·IteratorFeature·IsAtEnd·C = "True if done iterating (do not call other methods if this is true!)";
constexpr char const* dip·Measurement·IteratorFeature·operator_bool·C = "True if the iterator is valid and can be used";
constexpr char const* dip·Measurement·IteratorFeature·FeatureName·C = "Name of the feature";
constexpr char const* dip·Measurement·IteratorFeature·Values·C = "Returns an array with names and units for each of the values for the feature.\n(Note: data are copied to output array, this is not a trivial function).";
constexpr char const* dip·Measurement·IteratorFeature·NumberOfValues·C = "Number of values";
constexpr char const* dip·Measurement·IteratorFeature·ObjectExists·dip·uint··C = "True if the object ID is available in `this`.";
constexpr char const* dip·Measurement·IteratorFeature·ObjectIndex·dip·uint··C = "Finds the index for the given object ID";
constexpr char const* dip·Measurement·IteratorFeature·ObjectIndices·C = "Returns the map that links object IDs to row indices.";
constexpr char const* dip·Measurement·IteratorFeature·Objects·C = "Returns a list of object IDs";
constexpr char const* dip·Measurement·IteratorFeature·NumberOfObjects·C = "Number of objects";
constexpr char const* dip·Measurement·IteratorFeature·Data·C = "A raw pointer to the data of the feature. All values for one object are\ncontiguous.";
constexpr char const* dip·Measurement·IteratorFeature·Stride·C = "The stride to use to access the next row of data (next object).";
constexpr char const* dip·Measurement·IteratorFeature·AsImage·C = "Returns an image that encapsulates the data in this feature for all objects.\nThe image doesn't own the data, the measurement must keep existing for as long\nas this image is used. The image's sizes are\n`NumberOfValues()`x`NumberOfObjects()`. This function is intended to simplify\nthe implementation of some of the functions that can be applied to a\n`IteratorFeature`.";
constexpr char const* dip·Measurement·IteratorFeature·AsScalarImage·dip·uint··C = "Identical to `dip::Measurement::IteratorFeature::AsImage`, but returns a 1D\nimage with the `value` element of this feature. `value` must be smaller than\n`dip::Measurement::IteratorFeature::NumberOfValues`, and defaults to the first\nvalue in the set. This function is intended to simplify the implementation of\nsome of the functions that can be applied to a `IteratorFeature`.";
constexpr char const* dip·Measurement·IteratorObject = "An iterator to visit all objects (rows) in the `dip::Measurement` table. Can\nalso be seen as a view over a specific object.";
constexpr char const* dip·Measurement·IteratorObject·Iterator = "An iterator to visit all features (columns) within an object (row) of the\n`dip::Measurement` table.";
constexpr char const* dip·Measurement·IteratorObject·Iterator·operatorsqbra·dip·uint··C = "Index to access a specific value";
constexpr char const* dip·Measurement·IteratorObject·Iterator·operatortimes·C = "Dereference to access the first value";
constexpr char const* dip·Measurement·IteratorObject·Iterator·begin·C = "Iterator to the first value";
constexpr char const* dip·Measurement·IteratorObject·Iterator·end·C = "Iterator one past the last value";
constexpr char const* dip·Measurement·IteratorObject·Iterator·data·C = "A pointer to the first value";
constexpr char const* dip·Measurement·IteratorObject·Iterator·size·C = "Number of values";
constexpr char const* dip·Measurement·IteratorObject·Iterator·operatorplusplus = "Pre-increment, to access the next feature";
constexpr char const* dip·Measurement·IteratorObject·Iterator·operatorplusplus·int· = "Post-increment, to access the next feature";
constexpr char const* dip·Measurement·IteratorObject·Iterator·IsAtEnd·C = "True if done iterating (do not call other methods if this is true!)";
constexpr char const* dip·Measurement·IteratorObject·Iterator·operator_bool·C = "True if the iterator is valid and can be used";
constexpr char const* dip·Measurement·IteratorObject·Iterator·FeatureName·C = "Name of the feature";
constexpr char const* dip·Measurement·IteratorObject·Iterator·ObjectID·C = "ID of the object";
constexpr char const* dip·Measurement·IteratorObject·Iterator·ObjectIndex·C = "Index of the object (row number)";
constexpr char const* dip·Measurement·IteratorObject·FirstFeature·C = "Iterator to the first feature for this object";
constexpr char const* dip·Measurement·IteratorObject·operatorsqbra·String·CL·C = "Iterator to the given feature for this object";
constexpr char const* dip·Measurement·IteratorObject·operatorplusplus = "Pre-increment, to access the next object";
constexpr char const* dip·Measurement·IteratorObject·operatorplusplus·int· = "Post-increment, to access the next object";
constexpr char const* dip·Measurement·IteratorObject·IsAtEnd·C = "True if done iterating (do not call other methods if this is true!)";
constexpr char const* dip·Measurement·IteratorObject·operator_bool·C = "True if the iterator is valid and can be used";
constexpr char const* dip·Measurement·IteratorObject·ObjectID·C = "ID of the object";
constexpr char const* dip·Measurement·IteratorObject·FeatureExists·String·CL·C = "True if the feature is available in `this`.";
constexpr char const* dip·Measurement·IteratorObject·Features·C = "Returns an array of feature names";
constexpr char const* dip·Measurement·IteratorObject·NumberOfFeatures·C = "Number of features";
constexpr char const* dip·Measurement·IteratorObject·ValueIndex·String·CL·C = "Returns the index to the first columns for the feature";
constexpr char const* dip·Measurement·IteratorObject·Values·String·CL·C = "Returns an array with names and units for each of the values for the feature.\n(Note: data are copied to output array, this is not a trivial function).";
constexpr char const* dip·Measurement·IteratorObject·Values·C = "Returns an array with names and units for each of the values (for all\nfeatures)";
constexpr char const* dip·Measurement·IteratorObject·NumberOfValues·C = "Returns the total number of feature values";
constexpr char const* dip·Measurement·IteratorObject·NumberOfValues·String·CL·C = "Returns the number of values for the given feature";
constexpr char const* dip·Measurement·IteratorObject·ObjectIndex·C = "Index of the object (row number)";
constexpr char const* dip·Measurement·IteratorObject·Data·C = "A raw pointer to the data of the object. All values are contiguous.";
constexpr char const* dip·Measurement·AddFeature·String·CL·Feature·ValueInformationArray·CL = "Adds a feature to a raw `Measurement` object.";
constexpr char const* dip·Measurement·EnsureFeature·String·CL·Feature·ValueInformationArray·CL = "Adds a feature to a raw `Measurement` object if it is not already there.";
constexpr char const* dip·Measurement·SetObjectIDs·UnsignedArray· = "Replaces all object IDs with a new list. The `Measurement` object must be raw.";
constexpr char const* dip·Measurement·SetObjectIDs·std·vectorgtLabelTypelt·CL = "Replaces all object IDs with a new list. The `Measurement` object must be raw.";
constexpr char const* dip·Measurement·AddObjectID·dip·uint· = "Adds an object ID to a raw `Measurement` object. It is not efficient to use\nthis function in a loop.";
constexpr char const* dip·Measurement·AddObjectIDs·UnsignedArray·CL = "Adds object IDs to a raw `Measurement` object.";
constexpr char const* dip·Measurement·Forge = "Forges the table, allocating space to hold measurement values. Will fail if\nthere are no features defined.";
constexpr char const* dip·Measurement·IsForged·C = "Tests if the object is forged (has data segment allocated). A table with zero\nobjects will always appear raw (non-forged) even if `Forge` was called.";
constexpr char const* dip·Measurement·FirstObject·C = "Creates an iterator (view) to the first object";
constexpr char const* dip·Measurement·operatorsqbra·dip·uint··C = "Creates and iterator (view) to the given object. The table must be forged.";
constexpr char const* dip·Measurement·FirstFeature·C = "Creates and iterator (view) to the first feature";
constexpr char const* dip·Measurement·operatorsqbra·String·CL·C = "Creates and iterator (view) to the given feature";
constexpr char const* dip·Measurement·FeatureValuesView·dip·uint··dip·uint··C = "Creates and iterator (view) to a subset of feature values";
constexpr char const* dip·Measurement·operatorsqbra·LabelMap·CL·C = "Syntactic sugar for `map.Apply( *this )`. See `dip::LabelMap::Apply`.";
constexpr char const* dip·Measurement·Data·C = "A raw pointer to the data of the table. All values for one object are\ncontiguous. The table must be forged.";
constexpr char const* dip·Measurement·Stride·C = "The stride to use to access the next row of data in the table (next object).";
constexpr char const* dip·Measurement·DataSize·C = "The total number of data values in the table, equal to the product of\n`NumberOfValues` and `NumberOfObjects`.";
constexpr char const* dip·Measurement·FeatureExists·String·CL·C = "True if the feature is available in `this`.";
constexpr char const* dip·Measurement·FeatureIndex·String·CL·C = "Finds the index into the `dip::Measurement::Features` array for the given\nfeature.";
constexpr char const* dip·Measurement·Features·C = "Returns an array of feature names";
constexpr char const* dip·Measurement·NumberOfFeatures·C = "Returns the number of features";
constexpr char const* dip·Measurement·ValueIndex·String·CL·C = "Finds the index into the `dip::Measurement::Values` array for the first value\nof the given feature.";
constexpr char const* dip·Measurement·Values·String·CL·C = "Returns an array with names and units for each of the values for the feature.\n(Note: data are copied to output array, this is not a trivial function).";
constexpr char const* dip·Measurement·Values·C = "Returns an array with names and units for each of the values (for all\nfeatures)";
constexpr char const* dip·Measurement·NumberOfValues·C = "Returns the total number of feature values";
constexpr char const* dip·Measurement·NumberOfValues·String·CL·C = "Returns the number of values for the given feature";
constexpr char const* dip·Measurement·ObjectExists·dip·uint··C = "True if the object ID is available in `this`.";
constexpr char const* dip·Measurement·ObjectIndex·dip·uint··C = "Finds the row index for the given object ID.";
constexpr char const* dip·Measurement·ObjectIndices·C = "Returns the map that links object IDs to row indices.";
constexpr char const* dip·Measurement·Objects·C = "Returns a list of object IDs";
constexpr char const* dip·Measurement·NumberOfObjects·C = "Returns the number of objects";
constexpr char const* dip·operatorplus·Measurement·CL·Measurement·CL = "The `+` operator merges two `dip::Measurement` objects.";
constexpr char const* dip·operatorltlt·std·ostream·L·Measurement·CL = "You can output a `dip::Measurement` to `std::cout` or any other stream to\nproduce a human-readable representation of the tabular data in it.";
constexpr char const* dip·MeasurementTool = "Performs measurements on images.";
constexpr char const* dip·MeasurementTool·MeasurementTool = "Constructor.";
constexpr char const* dip·MeasurementTool·Register·Feature·Base·P = "Registers a feature with this `MeasurementTool`.";
constexpr char const* dip·MeasurementTool·Configure·String·CL·String·CL·dfloat··C = "Sets a parameter of a feature registered with this `MeasurementTool`.";
constexpr char const* dip·MeasurementTool·Measure·Image·CL·Image·CL·StringArray··UnsignedArray·CL·dip·uint··C = "Measures one or more features on one or more objects in the labeled image.";
constexpr char const* dip·MeasurementTool·Features·C = "Returns a table with known feature names and descriptions, which can directly\nbe shown to the user. (Note: data is copied to output array, this is not a\ntrivial function).";
constexpr char const* dip·ObjectToMeasurement·Image·CL·Image·L·Measurement·IteratorFeature·CL = "Paints each object with the selected measurement feature values.";
constexpr char const* dip·MeasurementWriteCSV·Measurement·CL·String·CL·StringSet·CL = "Writes a `dip::Measurement` structure to a CSV file.";
constexpr char const* dip·Minimum·Measurement·IteratorFeature·CL = "Returns the smallest feature value in the first column of `featureValues`.";
constexpr char const* dip·Maximum·Measurement·IteratorFeature·CL = "Returns the largest feature value in the first column of `featureValues`.";
constexpr char const* dip·Percentile·Measurement·IteratorFeature·CL·dfloat· = "Returns the `percentile` feature value in the first column of `featureValues`.";
constexpr char const* dip·Median·Measurement·IteratorFeature·CL = "Returns the median feature value in the first column of `featureValues`.";
constexpr char const* dip·Mean·Measurement·IteratorFeature·CL = "Returns the mean feature value in the first column of `featureValues`.";
constexpr char const* dip·MaximumAndMinimum·Measurement·IteratorFeature·CL = "Returns the maximum and minimum feature values in the first column of\n`featureValues`.";
constexpr char const* dip·Quartiles·Measurement·IteratorFeature·CL = "Computes the minimum, lower quartile (25th percentile), median (50th\npercentile), upper quartile (75th percentile), and maximum.";
constexpr char const* dip·SampleStatistics·Measurement·IteratorFeature·CL = "Returns the first four central moments of the feature values in the first\ncolumn of `featureValues`.";
constexpr char const* dip·ObjectMinimum·Measurement·IteratorFeature·CL = "Returns the object ID with the smallest feature value in the first column of\n`featureValues`.";
constexpr char const* dip·ObjectMaximum·Measurement·IteratorFeature·CL = "Returns the object ID with the largest feature value in the first column of\n`featureValues`.";
constexpr char const* dip·operatoreqeq·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is equal to\n`value`.";
constexpr char const* dip·operatornoteq·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is unequal to\n`value`.";
constexpr char const* dip·operatorgt·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is greater than\n`value`.";
constexpr char const* dip·operatorgteq·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is not smaller than\n`value`.";
constexpr char const* dip·operatorlt·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is smaller than\n`value`.";
constexpr char const* dip·operatorlteq·Measurement·IteratorFeature·CL·Measurement·ValueType· = "Selects objects where the first element of `featureValues` is not greater than\n`value`.";
constexpr char const* dip·BeerLambertMapping·Image·CL·Image·L·Image·Pixel·CL = "Applies a logarithmic mapping to a transmittance image to obtain an absorbance\nimage";
constexpr char const* dip·InverseBeerLambertMapping·Image·CL·Image·L·Image·Pixel·CL = "Applies an exponential mapping to an absorbance image to obtain a\ntransmittance image";
constexpr char const* dip·UnmixStains·Image·CL·Image·L·std·vectorgtImage·Pixellt·CL = "Unmixes stains in a brightfield absorbance image or a fluorescence emission\nimage.";
constexpr char const* dip·MixStains·Image·CL·Image·L·std·vectorgtImage·Pixellt·CL = "Composes a color image given stain densities and stain absorbance values\n(brightfield) or stain emission values (fluorescence)";
constexpr char const* dip·MandersOverlapCoefficient·Image·CL·Image·CL·Image·CL = "Computes the Manders Overlap Coefficient.";
constexpr char const* dip·IntensityCorrelationQuotient·Image·CL·Image·CL·Image·CL = "Computes Li's Intensity Correlation Quotient.";
constexpr char const* dip·ColocalizationCoefficients = "Holds Colocalization Coefficients as described by Manders, see\n`dip::MandersColocalizationCoefficients`.";
constexpr char const* dip·ColocalizationCoefficients·M1 = "Proportional to the fraction of fluorescence in channel 1 that colocalizes.";
constexpr char const* dip·ColocalizationCoefficients·M2 = "Proportional to the fraction of fluorescence in channel 2 that colocalizes.";
constexpr char const* dip·MandersColocalizationCoefficients·Image·CL·Image·CL·Image·CL·dfloat··dfloat· = "Computes Manders' Colocalization Coefficients.";
constexpr char const* dip·CostesColocalizationCoefficients·Image·CL·Image·CL·Image·CL = "Computes Costes' colocalization coefficients.";
constexpr char const* dip·CostesSignificanceTest·Image·CL·Image·CL·Image·CL·Random·L·UnsignedArray··dip·uint· = "Computes Costes' test of significance of true colocalization";
constexpr char const* dip·CostesSignificanceTest·Image·CL·Image·CL·Image·CL·UnsignedArray··dip·uint· = "Like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·IncoherentOTF·Image·L·dfloat··dfloat··dfloat··String·CL = "Generates an incoherent OTF (optical transfer function)";
constexpr char const* dip·IncoherentOTF·UnsignedArray·CL·dfloat··dfloat··dfloat··String·CL = "Overload for the function above, which takes image sizes instead of an image.";
constexpr char const* dip·IncoherentOTF·dfloat··dfloat··dfloat··String·CL = "Overloaded version of the function above, defaulting to a 256x256 image.";
constexpr char const* dip·IncoherentPSF·Image·L·dfloat··dfloat· = "Generates an incoherent PSF (point spread function)";
constexpr char const* dip·ExponentialFitCorrection·Image·CL·Image·CL·Image·L·dfloat··String·CL·dfloat··String·CL = "3D fluorescence attenuation correction using an exponential fit";
constexpr char const* dip·AttenuationCorrection·Image·CL·Image·L·dfloat··dfloat··dfloat··dfloat··dfloat··dfloat··String·CL = "3D fluorescence attenuation correction using one of three iterative algorithms";
constexpr char const* dip·SimulatedAttenuation·Image·CL·Image·L·dfloat··dfloat··dfloat··dfloat··dip·uint··dfloat· = "3D fluorescence attenuation simulation";
constexpr char const* dip·StructuringElement = "Represents the shape and size of a structuring element.";
constexpr char const* dip·StructuringElement·ShapeCode = "Possible shapes of a structuring element";
constexpr char const* dip·StructuringElement·ShapeCode·RECTANGULAR = "Corresponding to string `\"rectangular\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·ELLIPTIC = "Corresponding to string `\"elliptic\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·DIAMOND = "Corresponding to string `\"diamond\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·OCTAGONAL = "Corresponding to string `\"octagonal\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·LINE = "Corresponding to string `\"line\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·FAST_LINE = "Corresponding to string `\"fast line\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·PERIODIC_LINE = "Corresponding to string `\"periodic line\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·DISCRETE_LINE = "Corresponding to string `\"discrete line\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·INTERPOLATED_LINE = "Corresponding to string `\"interpolated line\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·PARABOLIC = "Corresponding to string `\"parabolic\"`.";
constexpr char const* dip·StructuringElement·ShapeCode·CUSTOM = "Defined through an image.";
constexpr char const* dip·StructuringElement·StructuringElement = "The default structuring element is a disk with a diameter of 7 pixels.";
constexpr char const* dip·StructuringElement·StructuringElement·String·CL = "A string implicitly converts to a structuring element, it is interpreted as a\nshape.";
constexpr char const* dip·StructuringElement·StructuringElement·FloatArray··String·CL = "A `dip::FloatArray` implicitly converts to a structuring element, it is\ninterpreted as the parameter of the SE for all dimensions. A second argument\nspecifies the shape.";
constexpr char const* dip·StructuringElement·StructuringElement·dfloat··String·CL = "A floating-point value implicitly converts to a structuring element, it is\ninterpreted as the parameter of the SE along each dimension. A second argument\nspecifies the shape.";
constexpr char const* dip·StructuringElement·StructuringElement·Image·CL = "An image implicitly converts to a structuring element.";
constexpr char const* dip·StructuringElement·Mirror = "Mirrors the structuring element.";
constexpr char const* dip·StructuringElement·IsMirrored·C = "True if SE is mirrored.";
constexpr char const* dip·StructuringElement·Kernel·C = "Converts the Structuring element into a kernel";
constexpr char const* dip·StructuringElement·Params·UnsignedArray·CL·C = "Retrieves the size array, adjusted to an image of size `imsz`.";
constexpr char const* dip·StructuringElement·Params·C = "Returns the structuring element parameters, not adjusted to image\ndimensionality.";
constexpr char const* dip·StructuringElement·Shape·C = "Returns the structuring element shape";
constexpr char const* dip·StructuringElement·IsCustom·C = "Tests to see if the structuring element is a custom shape";
constexpr char const* dip·StructuringElement·IsFlat·C = "Tests to see if the structuring element is flat or grey-valued";
constexpr char const* dip·Dilation·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "Applies the dilation with a standard or custom structuring element.";
constexpr char const* dip·Erosion·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "Applies the erosion with a standard or custom structuring element.";
constexpr char const* dip·Closing·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "Applies the closing with a standard or custom structuring element.";
constexpr char const* dip·Opening·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "Applies the opening with a standard or custom structuring element.";
constexpr char const* dip·Tophat·Image·CL·Image·L·StructuringElement·CL·String·CL·String·CL·StringArray·CL = "The Top-hat operator and its variants";
constexpr char const* dip·MorphologicalThreshold·Image·CL·Image·L·StructuringElement·CL·String·CL·StringArray·CL = "A morphological smoothing filter";
constexpr char const* dip·MorphologicalGist·Image·CL·Image·L·StructuringElement·CL·String·CL·StringArray·CL = "Morphological gist operator and its variants";
constexpr char const* dip·MorphologicalRange·Image·CL·Image·L·StructuringElement·CL·String·CL·StringArray·CL = "A morphological edge detector";
constexpr char const* dip·MorphologicalGradientMagnitude·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "The morphological version of the gradient magnitude";
constexpr char const* dip·Lee·Image·CL·Image·L·StructuringElement·CL·String·CL·String·CL·StringArray·CL = "A morphological edge detector";
constexpr char const* dip·MorphologicalSmoothing·Image·CL·Image·L·StructuringElement·CL·String·CL·StringArray·CL = "A morphological smoothing filter";
constexpr char const* dip·MorphologicalSharpening·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "A morphological sharpening filter";
constexpr char const* dip·MultiScaleMorphologicalGradient·Image·CL·Image·L·dip·uint··dip·uint··String·CL·StringArray·CL = "A morphological edge detector";
constexpr char const* dip·MorphologicalLaplace·Image·CL·Image·L·StructuringElement·CL·StringArray·CL = "The morphological version of the Laplace operator";
constexpr char const* dip·RankFilter·Image·CL·Image·L·StructuringElement·CL·dip·uint··String·CL·StringArray·CL = "Applies the rank-order filter.";
constexpr char const* dip·RankMinClosing·Image·CL·Image·L·StructuringElement··dip·uint··StringArray·CL = "Applies the rank-min closing, a closing that is somewhat robust to noise.";
constexpr char const* dip·RankMaxOpening·Image·CL·Image·L·StructuringElement··dip·uint··StringArray·CL = "Applies the rank-max opening, an opening that is somewhat robust to noise.";
constexpr char const* dip·Watershed·Image·CL·Image·CL·Image·L·dip·uint··dfloat··dip·uint··StringSet· = "Computes the watershed of `in` within `mask`, with on-line merging of regions.";
constexpr char const* dip·SeededWatershed·Image·CL·Image·CL·Image·CL·Image·L·dip·uint··dfloat··dip·uint··StringSet·CL = "Computes the watershed of `in` within `mask`, starting at `seeds`, with on-\nline merging of regions.";
constexpr char const* dip·CompactWatershed·Image·CL·Image·CL·Image·CL·Image·L·dip·uint··dfloat··StringSet·CL = "Computes the compact watershed of `in` within `mask`, starting at `seeds`.";
constexpr char const* dip·StochasticWatershed·Image·CL·Image·L·Random·L·dip·uint··dip·uint··dfloat··String·CL = "Computes the stochastic watershed of `in`.";
constexpr char const* dip·StochasticWatershed·Image·CL·Image·L·dip·uint··dip·uint··dfloat··String·CL = "Like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·WatershedMinima·Image·CL·Image·CL·Image·L·dip·uint··dfloat··dip·uint··String·CL = "Marks significant local minima.";
constexpr char const* dip·WatershedMaxima·Image·CL·Image·CL·Image·L·dip·uint··dfloat··dip·uint··String·CL = "Marks significant local maxima.";
constexpr char const* dip·Minima·Image·CL·Image·L·dip·uint··String·CL = "Marks local minima.";
constexpr char const* dip·Maxima·Image·CL·Image·L·dip·uint··String·CL = "Marks local maxima.";
constexpr char const* dip·UpperSkeleton2D·Image·CL·Image·CL·Image·L·String·CL = "Grey-value skeleton (2D only).";
constexpr char const* dip·MorphologicalReconstruction·Image·CL·Image·CL·Image·L·dip·uint··String·CL = "Reconstruction by dilation or erosion, also known as inf-reconstruction and\nsup-reconstruction";
constexpr char const* dip·LimitedMorphologicalReconstruction·Image·CL·Image·CL·Image·L·dfloat··dip·uint··String·CL = "Reconstruction by dilation or erosion, but with a limited reach.";
constexpr char const* dip·HMinima·Image·CL·Image·L·dfloat··dip·uint· = "Computes the H-Minima filtered image";
constexpr char const* dip·HMaxima·Image·CL·Image·L·dfloat··dip·uint· = "Computes the H-Maxima filtered image";
constexpr char const* dip·ImposeMinima·Image·CL·Image·CL·Image·L·dip·uint· = "Impose minima.";
constexpr char const* dip·Leveling·Image·CL·Image·CL·Image·L·dip·uint· = "The leveling of `in` imposed by `marker`.";
constexpr char const* dip·AreaOpening·Image·CL·Image·CL·Image·L·dip·uint··dip·uint··String·CL = "Computes the area opening or closing. This is a parametric opening.";
constexpr char const* dip·AreaClosing·Image·CL·Image·CL·Image·L·dip·uint··dip·uint· = "Computes the area closing, calling `dip::AreaOpening` with\n`polarity=\"closing\"`.";
constexpr char const* dip·VolumeOpening·Image·CL·Image·CL·Image·L·dfloat··dip·uint··String·CL = "Computes the volume opening or closing. This is a parametric opening.";
constexpr char const* dip·VolumeClosing·Image·CL·Image·CL·Image·L·dfloat··dip·uint· = "Computes the area closing, calling `dip::VolumeOpening` with\n`polarity=\"closing\"`.";
constexpr char const* dip·PathOpening·Image·CL·Image·CL·Image·L·dip·uint··String·CL·StringSet·CL = "Applies a path opening or closing in all possible directions";
constexpr char const* dip·DirectedPathOpening·Image·CL·Image·CL·Image·L·IntegerArray··String·CL·StringSet·CL = "Applies a path opening or closing in a specific direction.";
constexpr char const* dip·OpeningByReconstruction·Image·CL·Image·L·StructuringElement·CL·dip·uint··StringArray·CL = "Opening by reconstruction";
constexpr char const* dip·ClosingByReconstruction·Image·CL·Image·L·StructuringElement·CL·dip·uint··StringArray·CL = "Closing by reconstruction";
constexpr char const* dip·AlternatingSequentialFilter·Image·CL·Image·L·Range·CL·String·CL·String·CL·String·CL·StringArray·CL = "Alternating sequential filters for smoothing";
constexpr char const* dip·HitAndMiss·Image·CL·Image·L·StructuringElement·CL·StructuringElement·CL·String·CL·StringArray·CL = "The Hit-and-Miss transform, uses two structuring elements, `hit` must be\nwithin the structures, `miss` must be without.";
constexpr char const* dip·HitAndMiss·Image·CL·Image·L·Image·CL·String·CL·StringArray·CL = "The Hit-and-Miss transform, uses a single structuring element in the form of a\nsmall image that has \"hit\", \"miss\" and \"don't care\" values.";
constexpr char const* dip·SetNumberOfThreads·dip·uint· = "Sets the maximum number of threads to be using in computations.";
constexpr char const* dip·GetNumberOfThreads = "Gets the maximum number of threads that can be used in computations.";
constexpr char const* dip·Metric = "Represents a metric to be used to create a `dip::NeighborList`";
constexpr char const* dip·Metric·TypeCode = "The type of metric";
constexpr char const* dip·Metric·TypeCode·CONNECTED = "A connectivity metric, where the neighbors are all at the same distance.";
constexpr char const* dip·Metric·TypeCode·CHAMFER = "A chamfer metric, where different neighbors have different distances.";
constexpr char const* dip·Metric·TypeCode·IMAGE = "Metric defined through an image.";
constexpr char const* dip·Metric·Metric·TypeCode··dip·uint· = "The default metric is the city distance (L^1^ metric).";
constexpr char const* dip·Metric·Metric·String·CL·dip·uint··dip·PixelSize·CL = "A string implicitly converts to a metric.";
constexpr char const* dip·Metric·Metric·dip·Image·CL = "An image implicitly converts to a metric.";
constexpr char const* dip·Metric·Type·C = "Retrieve the type code.";
constexpr char const* dip·Metric·Param·C = "Retrieve the parameter.";
constexpr char const* dip·Metric·Image·C = "Retrieve the image.";
constexpr char const* dip·Metric·PixelSize·C = "Retrieve the pixel size array. Note that this could be an empty array, or have\nany number of elements.";
constexpr char const* dip·Metric·HasPixelSize·C = "Returns true if the pixel size array is set (a non-empty array).";
constexpr char const* dip·Metric·SetPixelSize·dip·PixelSize·CL = "Sets the pixel size associated to the `Metric`. Will overwrite an earlier\ndefined pixel size. Note that when the `Metric` is defined by an image, the\npixel size is ignored.";
constexpr char const* dip·NeighborList = "Defines the neighborhood of a pixel as a set of coordinates, with optionally\ntheir distance.";
constexpr char const* dip·NeighborList·Iterator = "Iterates over the neighbors in the `NeighborList`.";
constexpr char const* dip·NeighborList·Iterator·iterator_category = "Iterator category";
constexpr char const* dip·NeighborList·Iterator·value_type = "The type that the iterator points at";
constexpr char const* dip·NeighborList·Iterator·reference = "The type you get when you dereference";
constexpr char const* dip·NeighborList·Iterator·Iterator = "Default constructible, yields an invalid iterator.";
constexpr char const* dip·NeighborList·Iterator·swap·Iterator·L = "Swap";
constexpr char const* dip·NeighborList·Iterator·operatortimes·C = "Dereference, yields the distance to the neighbor";
constexpr char const* dip·NeighborList·Iterator·Coordinates·C = "Get the coordinates for the current neighbor";
constexpr char const* dip·NeighborList·Iterator·operatorplusplus = "Pre-increment";
constexpr char const* dip·NeighborList·Iterator·operatorplusplus·int· = "Post-increment";
constexpr char const* dip·NeighborList·Iterator·operatoreqeq·Iterator·CL·C = "Equality comparison";
constexpr char const* dip·NeighborList·Iterator·operatornoteq·Iterator·CL·C = "Inequality comparison";
constexpr char const* dip·NeighborList·Iterator·IsInImage·UnsignedArray·CL·UnsignedArray·CL·C = "Returns true if the neighbor pointed to is within the image";
constexpr char const* dip·NeighborList·NeighborList·Metric·CL·dip·uint· = "Creates a `NeighborList` given the image dimensionality and a `dip::Metric`.";
constexpr char const* dip·NeighborList·ComputeOffsets·IntegerArray·CL·C = "Returns an array with offsets corresponding to each of the neighbors in the\nlist, given an image's strides array.";
constexpr char const* dip·NeighborList·CopyDistances·T·C = "Returns an array with the distances to each of the neighbors in the list.";
constexpr char const* dip·NeighborList·FindBackward·dip·uint··C = "Returns an array that is true for those neighbors that would be processed\nearlier if processing as `ImageIterator` and the like would. `procDim` must be\nthe iterator's processing dimension.";
constexpr char const* dip·NeighborList·FindForward·dip·uint··C = "Returns an array that is true for those neighbors that would be processed\nlater if processing as `ImageIterator` and the like would. `procDim` must be\nthe iterator's processing dimension.";
constexpr char const* dip·NeighborList·SelectBackward·dip·uint··C = "Returns a new `NeighborList` object containing only those neighbors that would\nbe processed earlier if processing as `ImageIterator` and the like would.\n`procDim` must be the iterator's processing dimension.";
constexpr char const* dip·NeighborList·SelectForward·dip·uint··C = "Returns a new `NeighborList` object containing only those neighbors that would\nbe processed later if processing as `ImageIterator` and the like would.\n`procDim` must be the iterator's processing dimension.";
constexpr char const* dip·NeighborList·Size·C = "Returns the number of neighbors.";
constexpr char const* dip·NeighborList·Dimensionality·C = "Returns the neighborhood dimensionality";
constexpr char const* dip·NeighborList·Border·C = "Returns the number of pixels, along each dimension, that the neighborhood\nextends outside of its central pixel.";
constexpr char const* dip·NeighborList·begin·C = "A forward iterator to the first neighbor";
constexpr char const* dip·NeighborList·end·C = "A forward iterator to one past the last neighbor";
constexpr char const* dip·NeighborList·Coordinates·dip·uint··C = "Retrieve neighbor coordinates by index";
constexpr char const* dip·NeighborList·Distance·dip·uint··C = "Retrieve neighbor distance by index";
constexpr char const* dip·NeighborList·IsInImage·dip·uint··UnsignedArray·CL·UnsignedArray·CL·C = "Returns true if the neighbor by index is within the image";
constexpr char const* dip·PercentileFilter·Image·CL·Image·L·dfloat··Kernel·CL·StringArray·CL = "Applies a percentile filter to `in`.";
constexpr char const* dip·MedianFilter·Image·CL·Image·L·Kernel·CL·StringArray·CL = "The median filter, a non-linear smoothing filter.";
constexpr char const* dip·VarianceFilter·Image·CL·Image·L·Kernel·CL·StringArray·CL = "Computes, for each pixel, the sample variance within a filter window around\nthe pixel.";
constexpr char const* dip·SelectionFilter·Image·CL·Image·CL·Image·L·Kernel·CL·dfloat··String·CL·StringArray·CL = "Selects, for each pixel, a value from within the filter window, where a\ncontrol image is minimal or maximal.";
constexpr char const* dip·Kuwahara·Image·CL·Image·L·Kernel··dfloat··StringArray·CL = "The Kuwahara-Nagao operator, a non-linear edge-preserving smoothing filter.";
constexpr char const* dip·NonMaximumSuppression·Image·CL·Image·CL·Image·CL·Image·L·String·CL = "Non-maximum suppression, as used in the Canny edge detector.";
constexpr char const* dip·MoveToLocalMinimum·Image·CL·Image·CL·Image·L = "Given a sparse binary image `bin`, moves each set pixel to the pixel in the\n3x3 neighborhood with lowest `weight`.";
constexpr char const* dip·PeronaMalikDiffusion·Image·CL·Image·L·dip·uint··dfloat··dfloat··String·CL = "Applies Perona-Malik anisotropic diffusion";
constexpr char const* dip·GaussianAnisotropicDiffusion·Image·CL·Image·L·dip·uint··dfloat··dfloat··String·CL = "Applies iterative generic anisotropic diffusion using Gaussian derivatives";
constexpr char const* dip·RobustAnisotropicDiffusion·Image·CL·Image·L·dip·uint··dfloat··dfloat· = "Applies iterative robust anisotropic diffusion";
constexpr char const* dip·CoherenceEnhancingDiffusion·Image·CL·Image·L·dfloat··dfloat··dip·uint··StringSet·CL = "Applies iterative coherence enhancing (anisotropic) diffusion";
constexpr char const* dip·AdaptiveGauss·Image·CL·ImageConstRefArray·CL·Image·L·FloatArray·CL·UnsignedArray·CL·dfloat··UnsignedArray·CL·String·CL·String·CL = "Adaptive Gaussian filtering.";
constexpr char const* dip·AdaptiveBanana·Image·CL·ImageConstRefArray·CL·Image·L·FloatArray·CL·UnsignedArray·CL·dfloat··UnsignedArray·CL·String·CL·String·CL = "Adaptive Gaussian filtering using curvature.";
constexpr char const* dip·FullBilateralFilter·Image·CL·Image·CL·Image·L·FloatArray··dfloat··dfloat··StringArray·CL = "Bilateral filter, brute-force full kernel implementation";
constexpr char const* dip·QuantizedBilateralFilter·Image·CL·Image·CL·Image·L·FloatArray··dfloat··FloatArray··dfloat··StringArray·CL = "Quantized (piecewise linear) bilateral filter";
constexpr char const* dip·SeparableBilateralFilter·Image·CL·Image·CL·Image·L·BooleanArray·CL·FloatArray··dfloat··dfloat··StringArray·CL = "Separable bilateral filter, a very fast approximation";
constexpr char const* dip·BilateralFilter·Image·CL·Image·CL·Image·L·FloatArray··dfloat··dfloat··String·CL·StringArray·CL = "Bilateral filter, convenience function that allows selecting an implementation";
constexpr char const* dip·PixelTableOffsets = "Represents an arbitrarily-shaped neighborhood (filter support) in an arbitrary\nnumber of dimensions.";
constexpr char const* dip·PixelTableOffsets·PixelRun = "The pixel table is formed of pixel runs, represented by this structure.";
constexpr char const* dip·PixelTableOffsets·PixelRun·offset = "the offset of the first pixel in a run, w.r.t. the origin.";
constexpr char const* dip·PixelTableOffsets·PixelRun·length = "the length of the run.";
constexpr char const* dip·PixelTableOffsets·PixelTableOffsets = "A default-constructed pixel table is kinda useless.";
constexpr char const* dip·PixelTableOffsets·PixelTableOffsets·PixelTable·CL·Image·CL = "A pixel table with offsets is constructed from a `dip::PixelTable` and a\n`dip::Image`.";
constexpr char const* dip·PixelTableOffsets·Runs·C = "Returns the vector of runs.";
constexpr char const* dip·PixelTableOffsets·Dimensionality·C = "Returns the dimensionality of the neighborhood.";
constexpr char const* dip·PixelTableOffsets·Sizes·C = "Returns the size of the bounding box of the neighborhood.";
constexpr char const* dip·PixelTableOffsets·Origin·C = "Returns the coordinates of the top-left corner of the bounding box w.r.t. the\norigin of the neighborhood.";
constexpr char const* dip·PixelTableOffsets·NumberOfPixels·C = "Returns the number of pixels in the neighborhood.";
constexpr char const* dip·PixelTableOffsets·ProcessingDimension·C = "Returns the processing dimension, the dimension along which pixel runs are\nlaid out.";
constexpr char const* dip·PixelTableOffsets·Stride·C = "Returns the stride along the processing dimension used by the iterator.";
constexpr char const* dip·PixelTableOffsets·begin·C = "A const iterator to the first pixel in the neighborhood.";
constexpr char const* dip·PixelTableOffsets·end·C = "A const iterator to one past the last pixel in the neighborhood.";
constexpr char const* dip·PixelTableOffsets·HasWeights·C = "Tests if there are weights associated to each pixel in the neighborhood.";
constexpr char const* dip·PixelTableOffsets·WeightsAreComplex·C = "Tests if the weights associated to each pixel, if any, are complex-valued.";
constexpr char const* dip·PixelTableOffsets·Weights·C = "Returns a const reference to the weights array.";
constexpr char const* dip·PixelTableOffsets·Offsets·C = "Computes an array with the offsets.";
constexpr char const* dip·PixelTableOffsets·iterator = "An iterator that visits each of the neighborhood's pixels in turn.";
constexpr char const* dip·PixelTableOffsets·iterator·iterator_category = "Iterator category.";
constexpr char const* dip·PixelTableOffsets·iterator·value_type = "The value obtained by dereferencing is an offset.";
constexpr char const* dip·PixelTableOffsets·iterator·reference = "The type of a reference, but we don't return by reference, it's just as easy\nto copy.";
constexpr char const* dip·PixelTableOffsets·iterator·iterator = "Default constructor yields an invalid iterator that cannot be dereferenced.";
constexpr char const* dip·PixelTableOffsets·iterator·iterator·PixelTableOffsets·CL = "Constructs an iterator to the first pixel in the neighborhood.";
constexpr char const* dip·PixelTableOffsets·iterator·end·PixelTableOffsets·CL = "Constructs an end iterator.";
constexpr char const* dip·PixelTableOffsets·iterator·swap·iterator·L = "Swap.";
constexpr char const* dip·PixelTableOffsets·iterator·operatortimes·C = "Dereference.";
constexpr char const* dip·PixelTableOffsets·iterator·Offset·C = "Get offset, identical to dereferencing.";
constexpr char const* dip·PixelTableOffsets·iterator·Index·C = "Get index within run.";
constexpr char const* dip·PixelTableOffsets·iterator·operatorplusplus = "Pre-increment.";
constexpr char const* dip·PixelTableOffsets·iterator·operatorplusplus·int· = "Post-increment.";
constexpr char const* dip·PixelTableOffsets·iterator·operatoreqeq·iterator·CL·C = "Equality comparison, is true if the two iterators reference the same pixel in\nthe same pixel table, even if they use the strides of different images.";
constexpr char const* dip·PixelTableOffsets·iterator·operatornoteq·iterator·CL·C = "Inequality comparison.";
constexpr char const* dip·PixelTableOffsets·iterator·IsAtEnd·C = "Test to see if the iterator reached past the last pixel.";
constexpr char const* dip·PixelTableOffsets·iterator·operator_bool·C = "Test to see if the iterator is still pointing at a pixel.";
constexpr char const* dip·PixelTable = "Represents an arbitrarily-shaped neighborhood (filter support) in an arbitrary\nnumber of dimensions.";
constexpr char const* dip·PixelTable·PixelRun = "The pixel table is formed of pixel runs, represented by this structure.";
constexpr char const* dip·PixelTable·PixelRun·coordinates = "The coordinates of the first pixel in a run, w.r.t. the origin.";
constexpr char const* dip·PixelTable·PixelRun·length = "The length of the run, expected to always be larger than 0.";
constexpr char const* dip·PixelTable·PixelTable = "A default-constructed pixel table is kinda useless.";
constexpr char const* dip·PixelTable·PixelTable·String·CL·FloatArray··dip·uint· = "Construct a pixel table for default filter shapes.";
constexpr char const* dip·PixelTable·PixelTable·Image·CL·IntegerArray·CL·dip·uint· = "Construct a pixel table for an arbitrary shape defined by a binary image.";
constexpr char const* dip·PixelTable·Runs·C = "Returns the vector of runs.";
constexpr char const* dip·PixelTable·Dimensionality·C = "Returns the dimensionality of the neighborhood.";
constexpr char const* dip·PixelTable·Sizes·C = "Returns the size of the bounding box of the neighborhood.";
constexpr char const* dip·PixelTable·Origin·C = "Returns the coordinates of the top-left corner of the bounding box w.r.t. the\norigin.";
constexpr char const* dip·PixelTable·Boundary·C = "Returns the size of the boundary extension along each dimension that is\nnecessary to accommodate the neighborhood on the edge pixels of the image.";
constexpr char const* dip·PixelTable·ShiftOrigin·IntegerArray·CL = "Shifts the origin of the neighborhood by the given amount.";
constexpr char const* dip·PixelTable·MirrorOrigin = "Shifts the origin of neighborhood by one pixel to the left for even-sized\ndimensions. This is useful for neighborhoods with their origin in the default\nlocation, that have been mirrored.";
constexpr char const* dip·PixelTable·Mirror = "Mirrors the neighborhood.";
constexpr char const* dip·PixelTable·NumberOfPixels·C = "Returns the number of pixels in the neighborhood.";
constexpr char const* dip·PixelTable·ProcessingDimension·C = "Returns the processing dimension, the dimension along which pixel runs are\nlaid out.";
constexpr char const* dip·PixelTable·begin·C = "A const iterator to the first pixel in the neighborhood.";
constexpr char const* dip·PixelTable·end·C = "A const iterator to one past the last pixel in the neighborhood.";
constexpr char const* dip·PixelTable·AsImage·C = "Creates a binary image representing the neighborhood, or a `dfloat` one if\nthere are weights associated.";
constexpr char const* dip·PixelTable·AsImage·Image·L·C = "Same as previous overload, but writing into the given image.";
constexpr char const* dip·PixelTable·Prepare·Image·CL·C = "Prepare the pixel table to be applied to a specific image.";
constexpr char const* dip·PixelTable·AddWeights·Image·CL = "Add weights to each pixel in the neighborhood, taken from an image. The image\nmust be of the same sizes as the `PixelTable`'s bounding box (i.e. the image\nused to construct the pixel table), scalar, and not binary (i.e. integer,\nfloat or complex).";
constexpr char const* dip·PixelTable·AddDistanceToOriginAsWeights = "Add weights to each pixel in the neighborhood, using the Euclidean distance to\nthe origin as the weight. This is useful for algorithms that need to, for\nexample, sort the pixels in the neighborhood by distance to the origin.";
constexpr char const* dip·PixelTable·HasWeights·C = "Tests if there are weights associated to each pixel in the neighborhood.";
constexpr char const* dip·PixelTable·WeightsAreComplex·C = "Tests if the weights associated to each pixel, if any, are complex-valued.";
constexpr char const* dip·PixelTable·Weights·C = "Returns a const reference to the weights array.";
constexpr char const* dip·PixelTable·iterator = "An iterator that visits each of the neighborhood's pixels in turn.";
constexpr char const* dip·PixelTable·iterator·iterator_category = "Iterator category.";
constexpr char const* dip·PixelTable·iterator·value_type = "The value obtained by dereferencing are coordinates.";
constexpr char const* dip·PixelTable·iterator·reference = "The type of a reference.";
constexpr char const* dip·PixelTable·iterator·iterator = "Default constructor yields an invalid iterator that cannot be dereferenced.";
constexpr char const* dip·PixelTable·iterator·iterator·PixelTable·CL = "Constructs an iterator to the first pixel in the neighborhood.";
constexpr char const* dip·PixelTable·iterator·end·PixelTable·CL = "Constructs an end iterator.";
constexpr char const* dip·PixelTable·iterator·swap·iterator·L = "Swap.";
constexpr char const* dip·PixelTable·iterator·operatortimes·C = "Dereference.";
constexpr char const* dip·PixelTable·iterator·operatorplusplus = "Pre-increment.";
constexpr char const* dip·PixelTable·iterator·operatorplusplus·int· = "Post-increment.";
constexpr char const* dip·PixelTable·iterator·operatoreqeq·iterator·CL·C = "Equality comparison, is true if the two iterators reference the same pixel in\nthe same pixel table.";
constexpr char const* dip·PixelTable·iterator·operatornoteq·iterator·CL·C = "Inequality comparison.";
constexpr char const* dip·PixelTable·iterator·IsAtEnd·C = "Test to see if the iterator reached past the last pixel.";
constexpr char const* dip·PixelTable·iterator·operator_bool·C = "Test to see if the iterator is still pointing at a pixel.";
constexpr char const* dip·Random = "A pseudo-random number generator with excellent statistical properties, and\nit's also fast.";
constexpr char const* dip·Random·result_type = "The type of the integer returned by the generator.";
constexpr char const* dip·Random·state_type = "The type of the internal state of the generator.";
constexpr char const* dip·Random·min = "The minimum possible value returned by the generator.";
constexpr char const* dip·Random·max = "The maximum possible value returned by the generator.";
constexpr char const* dip·Random·Random = "The default random generator is initialized using `std::random_device`.";
constexpr char const* dip·Random·Random·dip·uint· = "Provide a seed to create a random generator that gives the same sequence every\ntime.";
constexpr char const* dip·Random·Seed = "Reseed the random generator using `std::random_device`.";
constexpr char const* dip·Random·Seed·dip·uint· = "Reseed the random generator using `seed`.";
constexpr char const* dip·Random·operatorparen = "Get the next random value.";
constexpr char const* dip·Random·Advance·dip·uint· = "Advance the generator `n` steps without producing output, takes log(`n`) time.";
constexpr char const* dip·Random·SetStream = "Set the stream for the generator using a random value from the generator\nitself.";
constexpr char const* dip·Random·SetStream·state_type· = "Set the stream for the generator to `n`.";
constexpr char const* dip·Random·Split = "Create a copy of the random generator, and set it to a random stream. Used by\nparallel algorithms to provide a different random generator to each thread.";
constexpr char const* dip·UniformRandomGenerator = "Generates random floating-point values taken from a uniform distribution.";
constexpr char const* dip·UniformRandomGenerator·UniformRandomGenerator·Random·L = "Constructor";
constexpr char const* dip·UniformRandomGenerator·operatorparen·dfloat··dfloat· = "Get the next random value, using the given parameters.";
constexpr char const* dip·GaussianRandomGenerator = "Generates random floating-point values taken from a normal distribution.";
constexpr char const* dip·GaussianRandomGenerator·GaussianRandomGenerator·Random·L = "Constructor";
constexpr char const* dip·GaussianRandomGenerator·operatorparen·dfloat··dfloat· = "Get the next random value, using the given parameters.";
constexpr char const* dip·PoissonRandomGenerator = "Generates random integer values taken from a poisson distribution.";
constexpr char const* dip·PoissonRandomGenerator·PoissonRandomGenerator·Random·L = "Constructor";
constexpr char const* dip·PoissonRandomGenerator·operatorparen·dfloat· = "Get the next random value, using the given parameter.";
constexpr char const* dip·BinaryRandomGenerator = "Generates random binary values.";
constexpr char const* dip·BinaryRandomGenerator·BinaryRandomGenerator·Random·L = "Constructor";
constexpr char const* dip·BinaryRandomGenerator·operatorparen·dfloat· = "Get the next random value, using the given parameter.";
constexpr char const* dip·Label·Image·CL·Image·L·dip·uint··dip·uint··dip·uint··StringArray··String·CL = "Labels the connected components in a binary image";
constexpr char const* dip·ListObjectLabels·Image·CL·Image·CL·String·CL·String·CL = "Gets a list of object labels in the labeled image. A labeled image must be of\nan unsigned type.";
constexpr char const* dip·Relabel·Image·CL·Image·L = "Re-assigns labels to objects in a labeled image, such that all labels are\nconsecutive.";
constexpr char const* dip·Relabel·Image·CL·Image·L·Graph·CL = "Re-assigns labels to objects in a labeled image, such that regions joined by\nan edge in `graph` obtain the same label.";
constexpr char const* dip·Relabel·Image·CL·Image·L·DirectedGraph·CL = "Re-assigns labels to objects in a labeled image, such that regions joined by\nan edge in `graph` obtain the same label.";
constexpr char const* dip·SmallObjectsRemove·Image·CL·Image·L·dip·uint··dip·uint· = "Removes small objects from a labeled or binary image.";
constexpr char const* dip·GrowRegions·Image·CL·Image·CL·Image·L·dip·sint··dip·uint· = "Grow (dilate) labeled regions uniformly.";
constexpr char const* dip·GrowRegionsWeighted·Image·CL·Image·CL·Image·CL·Image·L·dfloat· = "Grow labeled regions with a speed function given by a grey-value image.";
constexpr char const* dip·SplitRegions·Image·CL·Image·L·dip·uint· = "Ensures a gap between regions with unequal labels.";
constexpr char const* dip·MakeRegionsConvex2D·Image·CL·Image·L·String·CL = "Make each object a single, convex shape.";
constexpr char const* dip·GetLabelBoundingBox·Image·CL·LabelType· = "Returns the bounding box for all pixels with label `objectID` in the labeled\nor binary image `label`.";
constexpr char const* dip·RegionAdjacencyGraph·Image·CL·String·CL = "Construct a graph for the given labeled image.";
constexpr char const* dip·RegionAdjacencyGraph·Image·CL·Measurement·IteratorFeature·CL·String·CL = "Construct a graph for the given labeled image.";
constexpr char const* dip·saturated_add·T·T··T· = "Adds two values using saturated arithmetic.";
constexpr char const* dip·saturated_sub·T·T··T· = "Subtracts two values using saturated arithmetic.";
constexpr char const* dip·saturated_mul·T·T··T· = "Multiplies two values using saturated arithmetic.";
constexpr char const* dip·saturated_div·T·T··T· = "Divides two values using saturated arithmetic.";
constexpr char const* dip·saturated_safediv·T·T··T· = "Divides two values using saturated arithmetic. Tests for division by zero,\nreturn 0 rather than infinity or NaN (or an exception).";
constexpr char const* dip·saturated_inv·T·T· = "Inverts a value using saturated arithmetic. This is the same as negation, but\nnot for unsigned values.";
constexpr char const* dip·KMeansClustering·Image·CL·Image·L·Random·L·dip·uint· = "Applies k-means clustering to an image, yielding `nClusters` labeled regions.";
constexpr char const* dip·KMeansClustering·Image·CL·Image·L·dip·uint· = "Like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·MinimumVariancePartitioning·Image·CL·Image·L·dip·uint· = "Spatially partitions an image into `nClusters` partitions iteratively,\nminimizing the variance of the partitions.";
constexpr char const* dip·IsodataThreshold·Image·CL·Image·CL·Image·L·dip·uint· = "Thresholds the image `in` using `nThresholds` thresholds, determined using the\nIsodata algorithm (k-means clustering), and the histogram of `in`.";
constexpr char const* dip·OtsuThreshold·Image·CL·Image·CL·Image·L = "Thresholds the image `in` using the maximal inter-class variance method by\nOtsu, and the histogram of `in`.";
constexpr char const* dip·MinimumErrorThreshold·Image·CL·Image·CL·Image·L = "Thresholds the image `in` using the minimal error method by Kittler and\nIllingworth, and the histogram of `in`.";
constexpr char const* dip·GaussianMixtureModelThreshold·Image·CL·Image·CL·Image·L·dip·uint· = "Thresholds the image `in` using `nThresholds` thresholds, determined by\nfitting a Gaussian Mixture Model to the histogram of `in`.";
constexpr char const* dip·TriangleThreshold·Image·CL·Image·CL·Image·L·dfloat· = "Thresholds the image `in` using the chord method (a.k.a. skewed bi-modality,\nmaximum distance to triangle), and the histogram of `in`.";
constexpr char const* dip·BackgroundThreshold·Image·CL·Image·CL·Image·L·dfloat··dfloat· = "Thresholds the image `in` using the unimodal background-symmetry method, and\nthe histogram of `in`.";
constexpr char const* dip·VolumeThreshold·Image·CL·Image·CL·Image·L·dfloat· = "Thresholds an image such that a fraction `volumeFraction` of pixels is\nforeground.";
constexpr char const* dip·FixedThreshold·Image·CL·Image·L·dfloat··dfloat··dfloat··String·CL = "Thresholds an image at the `threshold` value.";
constexpr char const* dip·RangeThreshold·Image·CL·Image·L·dfloat··dfloat··String·CL·dfloat··dfloat· = "Thresholds an image at two values, equivalent to `lowerBound <= in && in <=\nupperBound`.";
constexpr char const* dip·HysteresisThreshold·Image·CL·Image·L·dfloat··dfloat· = "Hysteresis threshold.";
constexpr char const* dip·MultipleThresholds·Image·CL·Image·L·FloatArray·CL = "Thresholds an image at multiple values, yielding a labeled image.";
constexpr char const* dip·Threshold·Image·CL·Image·CL·Image·L·String·CL·dfloat· = "Automated threshold using `method`.";
constexpr char const* dip·PerObjectEllipsoidFitParameters = "Defines the parameters for the `PerObjectEllipsoidFit` function.";
constexpr char const* dip·PerObjectEllipsoidFitParameters·minSize = "Area in pixels of the smallest object detected";
constexpr char const* dip·PerObjectEllipsoidFitParameters·maxArea = "Area in pixels of the largest object detected";
constexpr char const* dip·PerObjectEllipsoidFitParameters·minEllipsoidFit = "Smallest allowed ratio of object size vs fitted ellipse size";
constexpr char const* dip·PerObjectEllipsoidFitParameters·minAspectRatio = "Smallest allowed aspect ratio of ellipse (largest radius divided by smallest\nradius); 1.0 is a circle/sphere";
constexpr char const* dip·PerObjectEllipsoidFitParameters·maxAspectRatio = "Largest allowed aspect ratio";
constexpr char const* dip·PerObjectEllipsoidFitParameters·minThreshold = "Smallest allowed threshold";
constexpr char const* dip·PerObjectEllipsoidFitParameters·maxThreshold = "Largest allowed threshold";
constexpr char const* dip·PerObjectEllipsoidFit·Image·CL·Image·L·PerObjectEllipsoidFitParameters·CL = "Finds a per-object threshold such that found objects are maximally\nellipsoidal.";
constexpr char const* dip·Canny·Image·CL·Image·L·FloatArray·CL·dfloat··dfloat··String·CL = "Detect edges in the grey-value image by finding salient ridges in the gradient\nmagnitude";
constexpr char const* dip·Superpixels·Image·CL·Image·L·Random·L·dfloat··dfloat··String·CL·StringSet·CL = "Generates superpixels (oversegmentation)";
constexpr char const* dip·Superpixels·Image·CL·Image·L·dfloat··dfloat··String·CL·StringSet·CL = "Like above, using a default-initialized `dip::Random` object.";
constexpr char const* dip·GraphCut·Image·CL·Image·CL·Image·L·dfloat··dfloat··dfloat· = "Graph-cut segmentation";
constexpr char const* dip·ImageRead·Image·L·String·CL·String· = "Reads the image in a file `filename`, and puts it in `out`.";
constexpr char const* dip·ImageWrite·Image·CL·String·CL·String··String·CL = "Writes `image` to file.";
constexpr char const* dip·Count·Image·CL·Image·CL = "Counts the number of non-zero pixels in a scalar image.";
constexpr char const* dip·MaximumPixel·Image·CL·Image·CL·String·CL = "Returns the coordinates of the maximum pixel in the image.";
constexpr char const* dip·MinimumPixel·Image·CL·Image·CL·String·CL = "Returns the coordinates of the minimum pixel in the image.";
constexpr char const* dip·CumulativeSum·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the cumulative sum of the pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·MaximumAndMinimum·Image·CL·Image·CL = "Finds the largest and smallest value in the image, within an optional mask.";
constexpr char const* dip·Quartiles·Image·CL·Image·CL = "Computes the minimum, lower quartile (25th percentile), median (50th\npercentile), upper quartile (75th percentile), and maximum.";
constexpr char const* dip·SampleStatistics·Image·CL·Image·CL = "Computes the first four central moments of the pixel intensities, within an\noptional mask.";
constexpr char const* dip·Covariance·Image·CL·Image·CL·Image·CL = "Computes the covariance and correlation between the two images, within an\noptional mask.";
constexpr char const* dip·PearsonCorrelation·Image·CL·Image·CL·Image·CL = "Computes the Pearson correlation coefficient. See `dip::Covariance`.";
constexpr char const* dip·SpearmanRankCorrelation·Image·CL·Image·CL·Image·CL = "Computes the Spearman rank correlation coefficient.";
constexpr char const* dip·CenterOfMass·Image·CL·Image·CL = "Computes the center of mass (first order moments) of the image `in`,\noptionally using only those pixels selected by `mask`.";
constexpr char const* dip·Moments·Image·CL·Image·CL = "Computes the first order normalized moments and second order normalized\ncentral moments of the image `in`, optionally using only those pixels selected\nby `mask`.";
constexpr char const* dip·Mean·Image·CL·Image·CL·Image·L·String·CL·BooleanArray·CL = "Calculates the (arithmetic) mean of the pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·Sum·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the sum of the pixel values over all those dimensions which are\nspecified by `process`.";
constexpr char const* dip·GeometricMean·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the geometric mean of the pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·Product·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the product of the pixel values over all those dimensions which are\nspecified by `process`.";
constexpr char const* dip·MeanAbs·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the mean of the absolute pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·MeanModulus·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the mean of the modulus of the pixel values. Alias to\n`dip::MeanAbs`.";
constexpr char const* dip·SumAbs·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the sum of the absolute pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·SumModulus·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the sum of the modulus of the pixel values. Alias to `dip::SumAbs`.";
constexpr char const* dip·MeanSquare·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the mean of the square pixel values over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·SumSquare·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the sum of the square pixel values over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·MeanSquareModulus·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the mean of the square modulus of the pixel values over all those\ndimensions which are specified by `process`.";
constexpr char const* dip·SumSquareModulus·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the sum of the square modulus of the pixel values over all those\ndimensions which are specified by `process`.";
constexpr char const* dip·Variance·Image·CL·Image·CL·Image·L·String··BooleanArray·CL = "Calculates the variance of the pixel values over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·StandardDeviation·Image·CL·Image·CL·Image·L·String··BooleanArray·CL = "Calculates the standard deviation of the pixel values over all those\ndimensions which are specified by `process`.";
constexpr char const* dip·Maximum·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the maximum of the pixel values over all those dimensions which are\nspecified by `process`.";
constexpr char const* dip·Minimum·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the minimum of the pixel values over all those dimensions which are\nspecified by `process`.";
constexpr char const* dip·MaximumAbs·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the maximum of the absolute pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·MinimumAbs·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the minimum of the absolute pixel values over all those dimensions\nwhich are specified by `process`.";
constexpr char const* dip·Percentile·Image·CL·Image·CL·Image·L·dfloat··BooleanArray·CL = "Calculates the percentile of the pixel values over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·Median·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Calculates the median of the pixel values over all those dimensions which are\nspecified by `process`.";
constexpr char const* dip·MedianAbsoluteDeviation·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Computes the median absolute deviation (MAD)";
constexpr char const* dip·All·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Determines if all pixels have non-zero values over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·Any·Image·CL·Image·CL·Image·L·BooleanArray·CL = "Determines if any pixel has a non-zero value over all those dimensions which\nare specified by `process`.";
constexpr char const* dip·PositionMaximum·Image·CL·Image·CL·Image·L·dip·uint··String·CL = "Calculates the position of the maximum of the pixel values in a single\ndimension specified by `dim`.";
constexpr char const* dip·PositionMinimum·Image·CL·Image·CL·Image·L·dip·uint··String·CL = "Calculates the position of the minimum of the pixel values in a single\ndimension specified by `dim`.";
constexpr char const* dip·PositionPercentile·Image·CL·Image·CL·Image·L·dfloat··dip·uint··String·CL = "Calculates the position of the percentile of the pixel values in a single\ndimension specified by `dim`.";
constexpr char const* dip·PositionMedian·Image·CL·Image·CL·Image·L·dip·uint··String·CL = "Calculates the position of the median of the pixel values in a single\ndimension specified by `dim`.";
constexpr char const* dip·RadialSum·Image·CL·Image·CL·Image·L·dfloat··String·CL·FloatArray·CL = "Computes the radial projection of the sum of the pixel values of `in`.";
constexpr char const* dip·RadialMean·Image·CL·Image·CL·Image·L·dfloat··String·CL·FloatArray·CL = "Computes the radial projection of the mean of the pixel values of `in`.";
constexpr char const* dip·RadialMinimum·Image·CL·Image·CL·Image·L·dfloat··String·CL·FloatArray·CL = "Computes the radial projection of the minimum of the pixel values of `in`.";
constexpr char const* dip·RadialMaximum·Image·CL·Image·CL·Image·L·dfloat··String·CL·FloatArray·CL = "Computes the radial projection of the maximum of the pixel values of `in`.";
constexpr char const* dip·MeanError·Image·CL·Image·CL·Image·CL = "Calculates the mean error difference between corresponding sample values of\n`in` and `reference`.";
constexpr char const* dip·MeanSquareError·Image·CL·Image·CL·Image·CL = "Calculates the mean square error difference between corresponding sample\nvalues of `in` and `reference`.";
constexpr char const* dip·RootMeanSquareError·Image·CL·Image·CL·Image·CL = "Calculates the root mean square (RMS) error difference between corresponding\nsample values of `in` and `reference`.";
constexpr char const* dip·MeanAbsoluteError·Image·CL·Image·CL·Image·CL = "Calculates the mean absolute error difference between corresponding sample\nvalues of `in` and `reference`.";
constexpr char const* dip·MaximumAbsoluteError·Image·CL·Image·CL·Image·CL = "Calculates the maximum absolute error difference between corresponding sample\nvalues of `in` and `reference`.";
constexpr char const* dip·MeanRelativeError·Image·CL·Image·CL·Image·CL = "Calculates the mean relative error difference between corresponding sample\nvalues of `in` and `reference`.";
constexpr char const* dip·MaximumRelativeError·Image·CL·Image·CL·Image·CL = "Calculates the maximum relative error difference between corresponding sample\nvalues of `in` and `reference`.";
constexpr char const* dip·IDivergence·Image·CL·Image·CL·Image·CL = "Calculates the I-divergence between corresponding sample values of `in` and\n`reference`.";
constexpr char const* dip·InProduct·Image·CL·Image·CL·Image·CL = "Calculates the sum of the product of corresponding sample values of `in` and\n`reference`.";
constexpr char const* dip·LnNormError·Image·CL·Image·CL·Image·CL·dfloat· = "Calculates the `order` norm difference between corresponding sample values of\n`in` and `reference`.";
constexpr char const* dip·PSNR·Image·CL·Image·CL·Image·CL·dfloat· = "Calculates the peak signal-to-noise ratio, in dB.";
constexpr char const* dip·SSIM·Image·CL·Image·CL·Image·CL·dfloat··dfloat··dfloat· = "Calculates the structural similarity index (a visual similarity measure)";
constexpr char const* dip·MutualInformation·Image·CL·Image·CL·Image·CL·dip·uint· = "Calculates the mutual information, in bits, using a histogram with\n`nBins`-by-`nBins` bins.";
constexpr char const* dip·SpatialOverlapMetrics = "Holds return values for the function `dip::SpatialOverlap`.";
constexpr char const* dip·SpatialOverlapMetrics·truePositives = "Number of true positives";
constexpr char const* dip·SpatialOverlapMetrics·trueNegatives = "Number of true negatives";
constexpr char const* dip·SpatialOverlapMetrics·falsePositives = "Number of false positives";
constexpr char const* dip·SpatialOverlapMetrics·falseNegatives = "Number of false negatives";
constexpr char const* dip·SpatialOverlapMetrics·diceCoefficient = "The F1-measure, harmonic mean between `precision` (PPV) and `sensitivity`\n(recall, TPR).";
constexpr char const* dip·SpatialOverlapMetrics·jaccardIndex = "The ratio of the intersection to the union.";
constexpr char const* dip·SpatialOverlapMetrics·sensitivity = "Also called recall, true positive rate (TPR).";
constexpr char const* dip·SpatialOverlapMetrics·specificity = "Also called true negative rate (TNR).";
constexpr char const* dip·SpatialOverlapMetrics·fallout = "Also called false positive rate (FPR), equal to 1-specificity.";
constexpr char const* dip·SpatialOverlapMetrics·accuracy = "Fraction of correctly segmented pixels.";
constexpr char const* dip·SpatialOverlapMetrics·precision = "Also called positive predictive value (PPV).";
constexpr char const* dip·SpatialOverlap·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`.";
constexpr char const* dip·DiceCoefficient·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the Dice coefficient.";
constexpr char const* dip·JaccardIndex·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the Jaccard index.";
constexpr char const* dip·Specificity·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the specificity of the segmentation.";
constexpr char const* dip·Sensitivity·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the sensitivity of the segmentation.";
constexpr char const* dip·Accuracy·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the accuracy of the segmentation.";
constexpr char const* dip·Precision·Image·CL·Image·CL = "Compares a segmentation result `in` to the ground truth `reference`,\ndetermining the precision of the segmentation.";
constexpr char const* dip·HausdorffDistance·Image·CL·Image·CL = "Computes the Hausdorff distance between two binary images.";
constexpr char const* dip·ModifiedHausdorffDistance·Image·CL·Image·CL = "Computes the modified Hausdorff distance between two binary images.";
constexpr char const* dip·SumOfMinimalDistances·Image·CL·Image·CL = "Computes the sum of minimal distances (SMD) between two binary images.";
constexpr char const* dip·ComplementWeightedSumOfMinimalDistances·Image·CL·Image·CL = "Computes the complement weighted sum of minimal distances (CWSMD) between two\nbinary images.";
constexpr char const* dip·Entropy·Image·CL·Image·CL·dip·uint· = "Calculates the entropy, in bits, using a histogram with `nBins` bins.";
constexpr char const* dip·EstimateNoiseVariance·Image·CL·Image·CL = "Estimates the variance of white Gaussian noise in an image.";
constexpr char const* dip·testing = "Tools for testing and debugging.";
constexpr char const* dip·testing·PrintPixelValues·T·Image·CL = "Outputs pixel values of a small image to `stdout`.";
constexpr char const* dip·testing·CompareImages·Image·CL·Image·CL·Option·CompareImagesMode··dfloat· = "Compares two images. Returns test result and prints to `stdout` the reason of\nfailure if the test fails.";
constexpr char const* dip·testing·Timer = "A timer object to help time algorithm execution.";
constexpr char const* dip·testing·Timer·Timer = "The default-constructed object records its creation time as the start time for\nthe timer.";
constexpr char const* dip·testing·Timer·Reset = "Records the current time as the start time for the timer.";
constexpr char const* dip·testing·Timer·Stop = "Records the current time as the stop time for the timer.";
constexpr char const* dip·testing·Timer·GetCpu·C = "Returns the CPU time in seconds elapsed in between the creation of the timer\n(or the last call to `Reset`) and the last call to `Stop`.";
constexpr char const* dip·testing·Timer·GetWall·C = "Returns the wall time in seconds elapsed in between the creation of the timer\n(or the last call to `Reset`) and the last call to `Stop`.";
constexpr char const* dip·testing·Timer·CpuResolution = "Returns the number of clock ticks per second for the CPU clock.";
constexpr char const* dip·testing·Timer·WallResolution = "Returns the number of clock ticks per second for the wall clock.";
constexpr char const* dip·testing·operatorltlt·std·ostream·L·Timer·CL = "Reports elapsed time to a stream.";
constexpr char const* dip·FourierTransform·Image·CL·Image·L·StringSet·CL·BooleanArray· = "Computes the forward and inverse Fourier Transform";
constexpr char const* dip·InverseFourierTransform·Image·CL·Image·L·StringSet··BooleanArray· = "Inverse Fourier Transform. Convenience function that calls\n`dip::FourierTransform` after adding \"inverse\" to `options`.";
constexpr char const* dip·OptimalFourierTransformSize·dip·uint··dip·String·CL·dip·String·CL = "Returns the next larger (or smaller) multiple of small integers. An image of\nthis size is more efficient for FFT computations.";
constexpr char const* dip·RieszTransform·Image·CL·Image·L·String·CL·String·CL·BooleanArray· = "Computes the Riesz transform of a scalar image.";
constexpr char const* dip·StationaryWaveletTransform·Image·CL·Image·L·dip·uint··StringArray·CL·BooleanArray·CL = "Computes a stationary wavelet transform (also called à-trous wavelet\ndecomposition).";
constexpr char const* dip·HaarWaveletTransform·Image·CL·Image·L·dip·uint··String·CL·BooleanArray· = "Computes the Haar wavelet transform or its inverse.";
constexpr char const* dip·UnionFind·T = "An STL-like data structure for the union-find algorithm.";
constexpr char const* dip·UnionFind·T·IndexType = "The type of the index (or label) that identifies each tree element";
constexpr char const* dip·UnionFind·T·ValueType = "The type of the additional data stored for each tree element";
constexpr char const* dip·UnionFind·T·UnionFind·UnionFunction_·CL = "Default constructor, creates an empty structure";
constexpr char const* dip·UnionFind·T·UnionFind·dip·uint··ValueType··UnionFunction_·CL = "Alternate constructor, creates `n` trees initialized to `value`.";
constexpr char const* dip·UnionFind·T·Size·C = "Returns the number of elements in the data structure. Note that the 0th\nelement is counted but not used. This is not the number of trees.";
constexpr char const* dip·UnionFind·T·FindRoot·IndexType··C = "Returns the index (label) for the root of the tree that contains `index`.";
constexpr char const* dip·UnionFind·T·Create·ValueType·CL = "Creates a new element, and places it in its own tree.";
constexpr char const* dip·UnionFind·T·Union·IndexType··IndexType· = "Merges two trees. Returns the index of the new root.";
constexpr char const* dip·UnionFind·T·Value·IndexType· = "Returns a reference to the value associated to the tree that contains `index`.";
constexpr char const* dip·UnionFind·T·Value·IndexType··C = "Returns a reference to the value associated to the tree that contains `index`.";
constexpr char const* dip·UnionFind·T·Iterate·T·Function· = "Calls `function` for each tree root.";
constexpr char const* dip·UnionFind·T·Relabel = "Assigns a new label to each of the trees.";
constexpr char const* dip·UnionFind·T·Relabel·T·Constraint· = "Assigns a new label to the trees that satisfy `constraint`, and 0 to the\nremainder.";
constexpr char const* dip·UnionFind·T·Label·IndexType··C = "Returns the new label associated to the tree that contains `index`. Only\nuseful after calling `Relabel`.";
constexpr char const* dip·UnionFind·T·LabelValue·IndexType··C = "Returns a const reference to the value associated to the tree that contains\n`index`. Only useful after calling `Relabel`.";
constexpr char const* dip·SimpleUnionFind·T = "A simplified version of `dip::UnionFind` that doesn't store any information\nabout the regions, only equivalences.";
constexpr char const* dip·SimpleUnionFind·T·SimpleUnionFind = "Default constructor, creates an empty structure";
constexpr char const* dip·SimpleUnionFind·T·SimpleUnionFind·dip·uint· = "Alternate constructor, creates `n` trees.";
constexpr char const* macro··DML_MIN_ARGS = "Tests to ensure the MEX-file has been called with sufficient inputs.";
constexpr char const* macro··DML_MAX_ARGS = "Tests to ensure the MEX-file has not been called with too many inputs.";
constexpr char const* macro··DML_CATCH = "Catch exceptions thrown in a MEX-file.";
constexpr char const* macro··DIP_ADD_STACK_TRACE = "Adds information from current function (including source file and location\nwithin file) to the `dip::Error`.";
constexpr char const* macro··DIP_THROW = "Throw a `dip::ParameterError`.";
constexpr char const* macro··DIP_THROW_INVALID_FLAG = "Throw a `dip::ParameterError` that reads \"Invalid flag: <flag>\".";
constexpr char const* macro··DIP_THROW_IF = "Test a condition, throw a `dip::ParameterError` if the condition is met.";
constexpr char const* macro··DIP_THROW_RUNTIME = "Throw a `dip::RunTimeError`.";
constexpr char const* macro··DIP_THROW_ASSERTION = "Throw a `dip::AssertionError`.";
constexpr char const* macro··DIP_ASSERT = "Test a condition, throw a `dip::AssertionError` if the condition is not met.";
constexpr char const* macro··DIP_START_STACK_TRACE = "Starts a try/catch block that builds a stack trace when an exception is\nthrown.";
constexpr char const* macro··DIP_END_STACK_TRACE = "Ends a try/catch block that builds a stack trace when an exception is thrown.\nSee `DIP_START_STACK_TRACE`.";
constexpr char const* macro··DIP_STACK_TRACE_THIS = "Encapsulates a statement in a try/catch block that builds a stack trace when\nan exception is thrown.";
constexpr char const* macro··DIP_PARALLEL_ERROR_DECLARE = "Declarations needed before an OpenMP parallel section to catch exceptions.";
constexpr char const* macro··DIP_PARALLEL_ERROR_START = "Starts a try/catch block. Do not use without a `DIP_PARALLEL_ERROR_END`. See\n`DIP_PARALLEL_ERROR_DECLARE` for details.";
constexpr char const* macro··DIP_PARALLEL_ERROR_END = "Ends a try/catch block started by `DIP_PARALLEL_ERROR_START`. See\n`DIP_PARALLEL_ERROR_DECLARE` for details.";
constexpr char const* macro··DIP_EXPORT = "Indicates that the function or class is exported from the shared/dynamic-load\nlibrary.";
constexpr char const* macro··DIP_NO_EXPORT = "Indicates that the function or class is not exported from the shared/dynamic-\nload library.";
constexpr char const* macro··DIP_CLASS_EXPORT = "Specifically for classes in a inheritance hierarchy and that must be passed\nacross the executable/shared library interface.";
constexpr char const* macro··DIP_NODISCARD = "If your compiler supports it, adds `[[nodiscard]]` to a function definition.";
constexpr char const* macro··DIP_DECLARE_OPTIONS = "Declare a type used to pass enumerated options to a function or class.";
constexpr char const* macro··DIP_OVL_CALL_BINARY = "Calls the overloaded function for the binary type.";
constexpr char const* macro··DIP_OVL_CALL_UINT = "Calls the overloaded function for all unsigned integer types.";
constexpr char const* macro··DIP_OVL_CALL_SINT = "Calls the overloaded function for all signed integer types.";
constexpr char const* macro··DIP_OVL_CALL_FLOAT = "Calls the overloaded function for all float types.";
constexpr char const* macro··DIP_OVL_CALL_COMPLEX = "Calls the overloaded function for all complex types.";
constexpr char const* macro··DIP_OVL_CALL_INTEGER = "Calls the overloaded function for all integer types.";
constexpr char const* macro··DIP_OVL_CALL_INT_OR_BIN = "Calls the overloaded function for all integer and binary types.";
constexpr char const* macro··DIP_OVL_CALL_UNSIGNED = "Calls the overloaded function for all unsigned types.";
constexpr char const* macro··DIP_OVL_CALL_SIGNED = "Calls the overloaded function for all signed (integer + float + complex)\ntypes.";
constexpr char const* macro··DIP_OVL_CALL_REAL = "Calls the overloaded function for all real (integer + float) types.";
constexpr char const* macro··DIP_OVL_CALL_SIGNEDREAL = "Calls the overloaded function for all signed real (integer + float) types.";
constexpr char const* macro··DIP_OVL_CALL_NONCOMPLEX = "Calls the overloaded function for all non-complex types.";
constexpr char const* macro··DIP_OVL_CALL_FLEX = "Calls the overloaded function for all floating-point and complex types.";
constexpr char const* macro··DIP_OVL_CALL_FLEXBIN = "Calls the overloaded function for all floating-point, complex and binary\ntypes.";
constexpr char const* macro··DIP_OVL_CALL_NONBINARY = "Calls the overloaded function for all types but binary.";
constexpr char const* macro··DIP_OVL_CALL_ALL = "Calls the overloaded function for all types.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_BINARY = "Calls the overloaded function for the binary type, and assigns the output\nvalue to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_UINT = "Calls the overloaded function for all unsigned integer types, and assigns the\noutput value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_SINT = "Calls the overloaded function for all signed integer types, and assigns the\noutput value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_FLOAT = "Calls the overloaded function for all float types, and assigns the output\nvalue to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_COMPLEX = "Calls the overloaded function for all complex types, and assigns the output\nvalue to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_INTEGER = "Calls the overloaded function for all integer types, and assigns the output\nvalue to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_INT_OR_BIN = "Calls the overloaded function for all integer and binary types, and assigns\nthe output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_UNSIGNED = "Calls the overloaded function function for all unsigned types, and assigns the\noutput value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_SIGNED = "Calls the overloaded function for all signed (integer + float + complex)\ntypes, and assigns the output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_REAL = "Calls the overloaded function for all real (integer + float) types, and\nassigns the output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_SIGNEDREAL = "Calls the overloaded function for all signed real (integer + float) types, and\nassigns the output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_NONCOMPLEX = "Calls the overloaded function for all non-complex types, and assigns the\noutput value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_FLEX = "Calls the overloaded function for all floating-point and complex types, and\nassigns the output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_FLEXBIN = "Calls the overloaded function for all floating-point, complex and binary\ntypes, and assigns the output value to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_NONBINARY = "Calls the overloaded function for all types but binary, and assigns the output\nvalue to variable `x`.";
constexpr char const* macro··DIP_OVL_CALL_ASSIGN_ALL = "Calls the overloaded function for all types, and assigns the output value to\nvariable `x`.";
constexpr char const* macro··DIP_OVL_ASSIGN_BINARY = "Assigns a pointer to the overloaded function for the binary type to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_UINT = "Assigns a pointer to the overloaded function for all unsigned integer types to\nthe variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_SINT = "Assigns a pointer to the overloaded function for all signed integer types to\nthe variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_FLOAT = "Assigns a pointer to the overloaded function for all float types to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_COMPLEX = "Assigns a pointer to the overloaded function for all complex types to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_INTEGER = "Assigns a pointer to the overloaded function for all integer types to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_INT_OR_BIN = "Assigns a pointer to the overloaded function for all integer and binary types\nto the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_UNSIGNED = "Assigns a pointer to the overloaded function for all unsigned types to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_SIGNED = "Assigns a pointer to the overloaded function for all signed (integer + float +\ncomplex) types to the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_REAL = "Assigns a pointer to the overloaded function for all real (integer + float)\ntypes to the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_SIGNEDREAL = "Assigns a pointer to the overloaded function for all signed real (integer +\nfloat) types to the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_NONCOMPLEX = "Assigns a pointer to the overloaded function for all non-complex types to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_FLEX = "Assigns a pointer to the overloaded function for all floating-point and\ncomplex types to the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_FLEXBIN = "Assigns a pointer to the overloaded function for all floating-point, complex\nand binary types to the variable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_NONBINARY = "Assigns a pointer to the overloaded function for all types but binary to the\nvariable `f`.";
constexpr char const* macro··DIP_OVL_ASSIGN_ALL = "Assigns a pointer to the overloaded function for all types to the variable\n`f`.";
constexpr char const* macro··DIP_OVL_NEW_BINARY = "Assigns a pointer to the overloaded class for the binary type to the variable\n`x`.";
constexpr char const* macro··DIP_OVL_NEW_UINT = "Assigns a pointer to the overloaded class for all unsigned integer types to\nthe variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_SINT = "Assigns a pointer to the overloaded class for all signed integer types to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_FLOAT = "Assigns a pointer to the overloaded class for all float types to the variable\n`x`.";
constexpr char const* macro··DIP_OVL_NEW_COMPLEX = "Assigns a pointer to the overloaded class for all complex types to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_INTEGER = "Assigns a pointer to the overloaded class for all integer types to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_INT_OR_BIN = "Assigns a pointer to the overloaded class for all integer and binary types to\nthe variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_UNSIGNED = "Assigns a pointer to the overloaded class for all unsigned types to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_SIGNED = "Assigns a pointer to the overloaded class for all signed (integer + float +\ncomplex) types to the variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_REAL = "Assigns a pointer to the overloaded class for all real (integer + float) types\nto the variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_SIGNEDREAL = "Assigns a pointer to the overloaded class for all signed real (integer +\nfloat) types to the variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_NONCOMPLEX = "Assigns a pointer to the overloaded class for all non-complex types to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_FLEX = "Assigns a pointer to the overloaded class for all floating-point and complex\ntypes to the variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_FLEXBIN = "Assigns a pointer to the overloaded class for all floating-point, complex and\nbinary types to the variable `x`.";
constexpr char const* macro··DIP_OVL_NEW_NONBINARY = "Assigns a pointer to the overloaded class for all types but binary to the\nvariable `x`.";
constexpr char const* macro··DIP_OVL_NEW_ALL = "Assigns a pointer to the overloaded class for all types to the variable `x`.";
constexpr char const* macro··DIPVIEWER_EXPORT = "Indicates that the function or class is exported from the shared library.";
constexpr char const* macro··DIPVIEWER_NO_EXPORT = "Indicates that the function or class is not exported from the shared library.";
constexpr char const* macro··DIPVIEWER_CLASS_EXPORT = "Specifically for classes in a inheritance hierarchy and that must be passed\nacross the executable/shared library interface. See `DIP_CLASS_EXPORT` for\nmore details.";
} // namespace doc_strings
